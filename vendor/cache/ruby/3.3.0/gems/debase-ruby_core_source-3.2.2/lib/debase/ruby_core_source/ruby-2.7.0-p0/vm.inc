/* -*- C -*- */

/* This is  an auto-generated file  and is a  part of the  programming language
 * Ruby.   The person  who  created  a program  to  generate  this file  (``I''
 * hereafter) would like  to refrain from defining licensing  of this generated
 * source code.
 *
 * This file consists of many small  parts of codes copyrighted by each author,
 * not  only  the  ``I''  person.   Those  original  authors  agree  with  some
 * open-source license.  I  believe that the license we agree  is the condition
 * mentioned in  the file COPYING.  It  states "4.  You may  modify and include
 * the part of the software into any  other software ...".  But the problem is,
 * the license never makes it clear if  such modified parts still remain in the
 * same  license, or  not.   The fact  that  we agree  with  the source  code's
 * licensing terms does not automatically  define that of generated ones.  This
 * is the reason why this file is  under an unclear situation.  All what I know
 * is that above provision guarantees this file to exist.
 *
 * Please let me hesitate to declare  something about this nuanced contract.  I
 * am not in the position to take  over other authors' license to merge into my
 * one.  Changing them to (say) GPLv3 is not doable by myself.  Perhaps someday
 * it might turn  out to be okay to  say this file is under a  license.  I wish
 * the situation would become more clear in the future. */

/*******************************************************************/
/*******************************************************************/
/*******************************************************************/
/**
  This file is VM main loop.

  ----
  This file is auto generated by insns2vm.rb
  DO NOT TOUCH!

  If you want to fix something, you must edit "tool/ruby_vm/views/vm.inc.erb"
  or tool/insns2vm.rb
 */

#include "vm_insnhelper.h"

/* insn nop()()() */
INSN_ENTRY(nop)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(nop);
    DEBUG_ENTER_INSN("nop");

    /* ###  Declare and assign variables. ### */
#   define INSN_ATTR(x) attr_ ## x ## _nop()
    bool leaf = INSN_ATTR(leaf);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(nop);
}

/* insn getlocal(idx, level)()(val) */
INSN_ENTRY(getlocal)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(getlocal);
    DEBUG_ENTER_INSN("getlocal");

    /* ###  Declare and assign variables. ### */
    lindex_t idx = (lindex_t)GET_OPERAND(1);
    rb_num_t level = (rb_num_t)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _getlocal(idx, level)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, level);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN getlocal
#   line 81 "insns.def"
{
    val = *(vm_get_ep(GET_EP(), level) - idx);
    RB_DEBUG_COUNTER_INC(lvar_get);
    (void)RB_DEBUG_COUNTER_INC_IF(lvar_get_dynamic, level > 0);
}
#   line 96 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(getlocal);
}

/* insn setlocal(idx, level)(val)() */
INSN_ENTRY(setlocal)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(setlocal);
    DEBUG_ENTER_INSN("setlocal");

    /* ###  Declare and assign variables. ### */
    lindex_t idx = (lindex_t)GET_OPERAND(1);
    rb_num_t level = (rb_num_t)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _setlocal(idx, level)
    bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, level);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN setlocal
#   line 95 "insns.def"
{
    vm_env_write(vm_get_ep(GET_EP(), level), -(int)idx, val);
    RB_DEBUG_COUNTER_INC(lvar_set);
    (void)RB_DEBUG_COUNTER_INC_IF(lvar_set_dynamic, level > 0);
}
#   line 142 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(setlocal);
}

/* insn getblockparam(idx, level)()(val) */
INSN_ENTRY(getblockparam)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(getblockparam);
    DEBUG_ENTER_INSN("getblockparam");

    /* ###  Declare and assign variables. ### */
    lindex_t idx = (lindex_t)GET_OPERAND(1);
    rb_num_t level = (rb_num_t)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _getblockparam(idx, level)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, level);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN getblockparam
#   line 107 "insns.def"
{
    const VALUE *ep = vm_get_ep(GET_EP(), level);
    VM_ASSERT(VM_ENV_LOCAL_P(ep));

    if (!VM_ENV_FLAGS(ep, VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM)) {
	val = rb_vm_bh_to_procval(ec, VM_ENV_BLOCK_HANDLER(ep));
	vm_env_write(ep, -(int)idx, val);
	VM_ENV_FLAGS_SET(ep, VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM);
    }
    else {
	val = *(ep - idx);
	RB_DEBUG_COUNTER_INC(lvar_get);
	(void)RB_DEBUG_COUNTER_INC_IF(lvar_get_dynamic, level > 0);
    }
}
#   line 195 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(getblockparam);
}

/* insn setblockparam(idx, level)(val)() */
INSN_ENTRY(setblockparam)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(setblockparam);
    DEBUG_ENTER_INSN("setblockparam");

    /* ###  Declare and assign variables. ### */
    lindex_t idx = (lindex_t)GET_OPERAND(1);
    rb_num_t level = (rb_num_t)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _setblockparam(idx, level)
    bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, level);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN setblockparam
#   line 129 "insns.def"
{
    const VALUE *ep = vm_get_ep(GET_EP(), level);
    VM_ASSERT(VM_ENV_LOCAL_P(ep));

    vm_env_write(ep, -(int)idx, val);
    RB_DEBUG_COUNTER_INC(lvar_set);
    (void)RB_DEBUG_COUNTER_INC_IF(lvar_set_dynamic, level > 0);

    VM_ENV_FLAGS_SET(ep, VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM);
}
#   line 246 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(setblockparam);
}

/* insn getblockparamproxy(idx, level)()(val) */
INSN_ENTRY(getblockparamproxy)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(getblockparamproxy);
    DEBUG_ENTER_INSN("getblockparamproxy");

    /* ###  Declare and assign variables. ### */
    lindex_t idx = (lindex_t)GET_OPERAND(1);
    rb_num_t level = (rb_num_t)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _getblockparamproxy(idx, level)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, level);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN getblockparamproxy
#   line 148 "insns.def"
{
    const VALUE *ep = vm_get_ep(GET_EP(), level);
    VM_ASSERT(VM_ENV_LOCAL_P(ep));

    if (!VM_ENV_FLAGS(ep, VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM)) {
	VALUE block_handler = VM_ENV_BLOCK_HANDLER(ep);

	if (block_handler) {
	    switch (vm_block_handler_type(block_handler)) {
	      case block_handler_type_iseq:
	      case block_handler_type_ifunc:
		val = rb_block_param_proxy;
		break;
	      case block_handler_type_symbol:
		val = rb_sym_to_proc(VM_BH_TO_SYMBOL(block_handler));
		goto INSN_LABEL(set);
	      case block_handler_type_proc:
		val = VM_BH_TO_PROC(block_handler);
		goto INSN_LABEL(set);
	      default:
		VM_UNREACHABLE(getblockparamproxy);
	    }
	}
	else {
	    val = Qnil;
	  INSN_LABEL(set):
	    vm_env_write(ep, -(int)idx, val);
	    VM_ENV_FLAGS_SET(ep, VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM);
	}
    }
    else {
	val = *(ep - idx);
	RB_DEBUG_COUNTER_INC(lvar_get);
	(void)RB_DEBUG_COUNTER_INC_IF(lvar_get_dynamic, level > 0);
    }
}
#   line 320 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(getblockparamproxy);
}

/* insn getspecial(key, type)()(val) */
INSN_ENTRY(getspecial)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(getspecial);
    DEBUG_ENTER_INSN("getspecial");

    /* ###  Declare and assign variables. ### */
    rb_num_t key = (rb_num_t)GET_OPERAND(1);
    rb_num_t type = (rb_num_t)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _getspecial(key, type)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, key);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, type);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN getspecial
#   line 193 "insns.def"
{
    val = vm_getspecial(ec, GET_LEP(), key, type);
}
#   line 364 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(getspecial);
}

/* insn setspecial(key)(obj)() */
INSN_ENTRY(setspecial)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(setspecial);
    DEBUG_ENTER_INSN("setspecial");

    /* ###  Declare and assign variables. ### */
    rb_num_t key = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _setspecial(key)
    bool leaf = INSN_ATTR(leaf);
    VALUE obj = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, key);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN setspecial
#   line 203 "insns.def"
{
    lep_svar_set(ec, GET_LEP(), key, obj);
}
#   line 406 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(setspecial);
}

/* insn getinstancevariable(id, ic)()(val) */
INSN_ENTRY(getinstancevariable)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(getinstancevariable);
    DEBUG_ENTER_INSN("getinstancevariable");

    /* ###  Declare and assign variables. ### */
    ID id = (ID)GET_OPERAND(1);
    IVC ic = (IVC)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _getinstancevariable(id, ic)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, ic);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN getinstancevariable
#   line 215 "insns.def"
{
    val = vm_getinstancevariable(GET_SELF(), id, ic);
}
#   line 447 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(getinstancevariable);
}

/* insn setinstancevariable(id, ic)(val)() */
INSN_ENTRY(setinstancevariable)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(setinstancevariable);
    DEBUG_ENTER_INSN("setinstancevariable");

    /* ###  Declare and assign variables. ### */
    ID id = (ID)GET_OPERAND(1);
    IVC ic = (IVC)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _setinstancevariable(id, ic)
    bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, ic);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN setinstancevariable
#   line 226 "insns.def"
{
    vm_setinstancevariable(GET_SELF(), id, val, ic);
}
#   line 491 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(setinstancevariable);
}

/* insn getclassvariable(id)()(val) */
INSN_ENTRY(getclassvariable)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(getclassvariable);
    DEBUG_ENTER_INSN("getclassvariable");

    /* ###  Declare and assign variables. ### */
    ID id = (ID)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _getclassvariable(id)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN getclassvariable
#   line 238 "insns.def"
{
    val = rb_cvar_get(vm_get_cvar_base(vm_get_cref(GET_EP()), GET_CFP()), id);
}
#   line 530 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(getclassvariable);
}

/* insn setclassvariable(id)(val)() */
INSN_ENTRY(setclassvariable)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(setclassvariable);
    DEBUG_ENTER_INSN("setclassvariable");

    /* ###  Declare and assign variables. ### */
    ID id = (ID)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _setclassvariable(id)
    bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN setclassvariable
#   line 250 "insns.def"
{
    vm_ensure_not_refinement_module(GET_SELF());
    rb_cvar_set(vm_get_cvar_base(vm_get_cref(GET_EP()), GET_CFP()), id, val);
}
#   line 573 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(setclassvariable);
}

/* insn getconstant(id)(klass, allow_nil)(val) */
INSN_ENTRY(getconstant)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(getconstant);
    DEBUG_ENTER_INSN("getconstant");

    /* ###  Declare and assign variables. ### */
    ID id = (ID)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _getconstant(id)
    bool leaf = INSN_ATTR(leaf);
    VALUE klass = TOPN(1);
    VALUE allow_nil = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN getconstant
#   line 266 "insns.def"
{
    val = vm_get_ev_const(ec, klass, id, allow_nil == Qtrue, 0);
}
#   line 614 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(getconstant);
}

/* insn setconstant(id)(val, cbase)() */
INSN_ENTRY(setconstant)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(setconstant);
    DEBUG_ENTER_INSN("setconstant");

    /* ###  Declare and assign variables. ### */
    ID id = (ID)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _setconstant(id)
    bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(1);
    VALUE cbase = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN setconstant
#   line 282 "insns.def"
{
    vm_check_if_namespace(cbase);
    vm_ensure_not_refinement_module(GET_SELF());
    rb_const_set(cbase, id, val);
}
#   line 659 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(setconstant);
}

/* insn getglobal(entry)()(val) */
INSN_ENTRY(getglobal)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(getglobal);
    DEBUG_ENTER_INSN("getglobal");

    /* ###  Declare and assign variables. ### */
    GENTRY entry = (GENTRY)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _getglobal(entry)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, entry);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN getglobal
#   line 295 "insns.def"
{
    struct rb_global_entry *gentry = (void *)entry;
    val = rb_gvar_get(gentry);
}
#   line 699 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(getglobal);
}

/* insn setglobal(entry)(val)() */
INSN_ENTRY(setglobal)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(setglobal);
    DEBUG_ENTER_INSN("setglobal");

    /* ###  Declare and assign variables. ### */
    GENTRY entry = (GENTRY)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _setglobal(entry)
    bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, entry);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN setglobal
#   line 307 "insns.def"
{
    struct rb_global_entry *gentry = (void *)entry;
    rb_gvar_set(gentry, val);
}
#   line 742 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(setglobal);
}

/* insn putnil()()(val) */
INSN_ENTRY(putnil)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(putnil);
    DEBUG_ENTER_INSN("putnil");

    /* ###  Declare and assign variables. ### */
#   define INSN_ATTR(x) attr_ ## x ## _putnil()
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN putnil
#   line 322 "insns.def"
{
    val = Qnil;
}
#   line 779 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(putnil);
}

/* insn putself()()(val) */
INSN_ENTRY(putself)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(putself);
    DEBUG_ENTER_INSN("putself");

    /* ###  Declare and assign variables. ### */
#   define INSN_ATTR(x) attr_ ## x ## _putself()
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN putself
#   line 332 "insns.def"
{
    val = GET_SELF();
}
#   line 819 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(putself);
}

/* insn putobject(val)()(val) */
INSN_ENTRY(putobject)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(putobject);
    DEBUG_ENTER_INSN("putobject");

    /* ###  Declare and assign variables. ### */
    VALUE val = (VALUE)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _putobject(val)
    bool leaf = INSN_ATTR(leaf);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, val);

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(putobject);
}

/* insn putspecialobject(value_type)()(val) */
INSN_ENTRY(putspecialobject)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(putspecialobject);
    DEBUG_ENTER_INSN("putspecialobject");

    /* ###  Declare and assign variables. ### */
    rb_num_t value_type = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _putspecialobject(value_type)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, value_type);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN putspecialobject
#   line 354 "insns.def"
{
    enum vm_special_object_type type;

    type = (enum vm_special_object_type)value_type;
    val = vm_get_special_object(GET_EP(), type);
}
#   line 894 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(putspecialobject);
}

/* insn putstring(str)()(val) */
INSN_ENTRY(putstring)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(putstring);
    DEBUG_ENTER_INSN("putstring");

    /* ###  Declare and assign variables. ### */
    VALUE str = (VALUE)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _putstring(str)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, str);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN putstring
#   line 367 "insns.def"
{
    val = rb_str_resurrect(str);
}
#   line 936 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(putstring);
}

/* insn concatstrings(num)(...)(val) */
INSN_ENTRY(concatstrings)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(concatstrings);
    DEBUG_ENTER_INSN("concatstrings");

    /* ###  Declare and assign variables. ### */
    rb_num_t num = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _concatstrings(num)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, num);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN concatstrings
#   line 381 "insns.def"
{
    val = rb_str_concat_literals(num, STACK_ADDR_FROM_TOP(num));
}
#   line 978 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(concatstrings);
}

/* insn tostring()(val, str)(val) */
INSN_ENTRY(tostring)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(tostring);
    DEBUG_ENTER_INSN("tostring");

    /* ###  Declare and assign variables. ### */
#   define INSN_ATTR(x) attr_ ## x ## _tostring()
    bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(1);
    VALUE str = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN tostring
#   line 391 "insns.def"
{
    val = rb_obj_as_string_result(str, val);
}
#   line 1019 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(tostring);
}

/* insn freezestring(debug_info)(str)(str) */
INSN_ENTRY(freezestring)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(freezestring);
    DEBUG_ENTER_INSN("freezestring");

    /* ###  Declare and assign variables. ### */
    VALUE debug_info = (VALUE)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _freezestring(debug_info)
    bool leaf = INSN_ATTR(leaf);
    VALUE str = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, debug_info);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN freezestring
#   line 401 "insns.def"
{
    vm_freezestring(str, debug_info);
}
#   line 1061 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = str;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(freezestring);
}

/* insn toregexp(opt, cnt)(...)(val) */
INSN_ENTRY(toregexp)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(toregexp);
    DEBUG_ENTER_INSN("toregexp");

    /* ###  Declare and assign variables. ### */
    rb_num_t opt = (rb_num_t)GET_OPERAND(1);
    rb_num_t cnt = (rb_num_t)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _toregexp(opt, cnt)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, opt);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cnt);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN toregexp
#   line 417 "insns.def"
{
    const VALUE ary = rb_ary_tmp_new_from_values(0, cnt, STACK_ADDR_FROM_TOP(cnt));
    val = rb_reg_new_ary(ary, (int)opt);
    rb_ary_clear(ary);
}
#   line 1107 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(toregexp);
}

/* insn intern()(str)(sym) */
INSN_ENTRY(intern)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(intern);
    DEBUG_ENTER_INSN("intern");

    /* ###  Declare and assign variables. ### */
#   define INSN_ATTR(x) attr_ ## x ## _intern()
    bool leaf = INSN_ATTR(leaf);
    VALUE str = TOPN(0);
    VALUE sym;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN intern
#   line 429 "insns.def"
{
    sym = rb_str_intern(str);
}
#   line 1148 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = sym;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(intern);
}

/* insn newarray(num)(...)(val) */
INSN_ENTRY(newarray)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(newarray);
    DEBUG_ENTER_INSN("newarray");

    /* ###  Declare and assign variables. ### */
    rb_num_t num = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _newarray(num)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, num);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN newarray
#   line 440 "insns.def"
{
    val = rb_ary_new4(num, STACK_ADDR_FROM_TOP(num));
}
#   line 1190 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(newarray);
}

/* insn newarraykwsplat(num)(...)(val) */
INSN_ENTRY(newarraykwsplat)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(newarraykwsplat);
    DEBUG_ENTER_INSN("newarraykwsplat");

    /* ###  Declare and assign variables. ### */
    rb_num_t num = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _newarraykwsplat(num)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, num);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN newarraykwsplat
#   line 455 "insns.def"
{
    if (RHASH_EMPTY_P(*STACK_ADDR_FROM_TOP(1))) {
        val = rb_ary_new4(num-1, STACK_ADDR_FROM_TOP(num));
    }
    else {
        val = rb_ary_new4(num, STACK_ADDR_FROM_TOP(num));
    }
}
#   line 1237 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(newarraykwsplat);
}

/* insn duparray(ary)()(val) */
INSN_ENTRY(duparray)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(duparray);
    DEBUG_ENTER_INSN("duparray");

    /* ###  Declare and assign variables. ### */
    VALUE ary = (VALUE)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _duparray(ary)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ary);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN duparray
#   line 470 "insns.def"
{
    RUBY_DTRACE_CREATE_HOOK(ARRAY, RARRAY_LEN(ary));
    val = rb_ary_resurrect(ary);
}
#   line 1280 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(duparray);
}

/* insn duphash(hash)()(val) */
INSN_ENTRY(duphash)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(duphash);
    DEBUG_ENTER_INSN("duphash");

    /* ###  Declare and assign variables. ### */
    VALUE hash = (VALUE)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _duphash(hash)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, hash);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN duphash
#   line 481 "insns.def"
{
    RUBY_DTRACE_CREATE_HOOK(HASH, RHASH_SIZE(hash) << 1);
    val = rb_hash_resurrect(hash);
}
#   line 1323 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(duphash);
}

/* insn expandarray(num, flag)(..., ary)(...) */
INSN_ENTRY(expandarray)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(expandarray);
    DEBUG_ENTER_INSN("expandarray");

    /* ###  Declare and assign variables. ### */
    rb_num_t num = (rb_num_t)GET_OPERAND(1);
    rb_num_t flag = (rb_num_t)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _expandarray(num, flag)
    bool leaf = INSN_ATTR(leaf);
    VALUE ary = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, num);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, flag);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN expandarray
#   line 502 "insns.def"
{
    vm_expandarray(GET_SP(), ary, num, (int)flag);
}
#   line 1366 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(expandarray);
}

/* insn concatarray()(ary1, ary2)(ary) */
INSN_ENTRY(concatarray)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(concatarray);
    DEBUG_ENTER_INSN("concatarray");

    /* ###  Declare and assign variables. ### */
#   define INSN_ATTR(x) attr_ ## x ## _concatarray()
    bool leaf = INSN_ATTR(leaf);
    VALUE ary1 = TOPN(1);
    VALUE ary2 = TOPN(0);
    VALUE ary;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN concatarray
#   line 513 "insns.def"
{
    ary = vm_concat_array(ary1, ary2);
}
#   line 1404 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = ary;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(concatarray);
}

/* insn splatarray(flag)(ary)(obj) */
INSN_ENTRY(splatarray)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(splatarray);
    DEBUG_ENTER_INSN("splatarray");

    /* ###  Declare and assign variables. ### */
    VALUE flag = (VALUE)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _splatarray(flag)
    bool leaf = INSN_ATTR(leaf);
    VALUE ary = TOPN(0);
    VALUE obj;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, flag);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN splatarray
#   line 524 "insns.def"
{
    obj = vm_splat_array(flag, ary);
}
#   line 1447 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = obj;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(splatarray);
}

/* insn newhash(num)(...)(val) */
INSN_ENTRY(newhash)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(newhash);
    DEBUG_ENTER_INSN("newhash");

    /* ###  Declare and assign variables. ### */
    rb_num_t num = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _newhash(num)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, num);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN newhash
#   line 536 "insns.def"
{
    RUBY_DTRACE_CREATE_HOOK(HASH, num);

    val = rb_hash_new_with_size(num / 2);

    if (num) {
        rb_hash_bulk_insert(num, STACK_ADDR_FROM_TOP(num), val);
    }
}
#   line 1495 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(newhash);
}

/* insn newrange(flag)(low, high)(val) */
INSN_ENTRY(newrange)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(newrange);
    DEBUG_ENTER_INSN("newrange");

    /* ###  Declare and assign variables. ### */
    rb_num_t flag = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _newrange(flag)
    bool leaf = INSN_ATTR(leaf);
    VALUE low = TOPN(1);
    VALUE high = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, flag);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN newrange
#   line 554 "insns.def"
{
    val = rb_range_new(low, high, (int)flag);
}
#   line 1539 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(newrange);
}

/* insn pop()(val)() */
INSN_ENTRY(pop)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(pop);
    DEBUG_ENTER_INSN("pop");

    /* ###  Declare and assign variables. ### */
#   define INSN_ATTR(x) attr_ ## x ## _pop()
    bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN pop
#   line 568 "insns.def"
{
    (void)val;
    /* none */
}
#   line 1580 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(pop);
}

/* insn dup()(val)(val1, val2) */
INSN_ENTRY(dup)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(dup);
    DEBUG_ENTER_INSN("dup");

    /* ###  Declare and assign variables. ### */
#   define INSN_ATTR(x) attr_ ## x ## _dup()
    bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);
    VALUE val1;
    VALUE val2;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN dup
#   line 579 "insns.def"
{
    val1 = val2 = val;
}
#   line 1619 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val2;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    TOPN(1) = val1;
    VM_ASSERT(!RB_TYPE_P(TOPN(1), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(1), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(dup);
}

/* insn dupn(n)(...)(...) */
INSN_ENTRY(dupn)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(dupn);
    DEBUG_ENTER_INSN("dupn");

    /* ###  Declare and assign variables. ### */
    rb_num_t n = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _dupn(n)
    bool leaf = INSN_ATTR(leaf);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, n);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN dupn
#   line 590 "insns.def"
{
    void *dst = GET_SP();
    void *src = STACK_ADDR_FROM_TOP(n);

    MEMCPY(dst, src, VALUE, n);
}
#   line 1665 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(dupn);
}

/* insn swap()(val, obj)(obj, val) */
INSN_ENTRY(swap)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(swap);
    DEBUG_ENTER_INSN("swap");

    /* ###  Declare and assign variables. ### */
#   define INSN_ATTR(x) attr_ ## x ## _swap()
    bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(1);
    VALUE obj = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    TOPN(1) = obj;
    VM_ASSERT(!RB_TYPE_P(TOPN(1), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(1), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(swap);
}

/* insn reverse(n)(...)(...) */
INSN_ENTRY(reverse)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(reverse);
    DEBUG_ENTER_INSN("reverse");

    /* ###  Declare and assign variables. ### */
    rb_num_t n = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _reverse(n)
    bool leaf = INSN_ATTR(leaf);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, n);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN reverse
#   line 614 "insns.def"
{
    rb_num_t i;
    VALUE *sp = STACK_ADDR_FROM_TOP(n);

    for (i=0; i<n/2; i++) {
	VALUE v0 = sp[i];
	VALUE v1 = TOPN(i);
	sp[i] = v1;
	TOPN(i) = v0;
    }
}
#   line 1742 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(reverse);
}

/* insn topn(n)(...)(val) */
INSN_ENTRY(topn)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(topn);
    DEBUG_ENTER_INSN("topn");

    /* ###  Declare and assign variables. ### */
    rb_num_t n = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _topn(n)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, n);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN topn
#   line 644 "insns.def"
{
    val = TOPN(n);
}
#   line 1780 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(topn);
}

/* insn setn(n)(..., val)(val) */
INSN_ENTRY(setn)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(setn);
    DEBUG_ENTER_INSN("setn");

    /* ###  Declare and assign variables. ### */
    rb_num_t n = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _setn(n)
    bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, n);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN setn
#   line 655 "insns.def"
{
    TOPN(n) = val;
}
#   line 1822 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(setn);
}

/* insn adjuststack(n)(...)(...) */
INSN_ENTRY(adjuststack)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(adjuststack);
    DEBUG_ENTER_INSN("adjuststack");

    /* ###  Declare and assign variables. ### */
    rb_num_t n = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _adjuststack(n)
    bool leaf = INSN_ATTR(leaf);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, n);

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(adjuststack);
}

/* insn defined(op_type, obj, needstr)(v)(val) */
INSN_ENTRY(defined)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(defined);
    DEBUG_ENTER_INSN("defined");

    /* ###  Declare and assign variables. ### */
    rb_num_t op_type = (rb_num_t)GET_OPERAND(1);
    VALUE obj = (VALUE)GET_OPERAND(2);
    VALUE needstr = (VALUE)GET_OPERAND(3);
#   define INSN_ATTR(x) attr_ ## x ## _defined(op_type, obj, needstr)
    bool leaf = INSN_ATTR(leaf);
    VALUE v = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, op_type);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, obj);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 2, needstr);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN defined
#   line 681 "insns.def"
{
    val = vm_defined(ec, GET_CFP(), op_type, obj, needstr, v);
}
#   line 1896 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(defined);
}

/* insn checkmatch(flag)(target, pattern)(result) */
INSN_ENTRY(checkmatch)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(checkmatch);
    DEBUG_ENTER_INSN("checkmatch");

    /* ###  Declare and assign variables. ### */
    rb_num_t flag = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _checkmatch(flag)
    bool leaf = INSN_ATTR(leaf);
    VALUE target = TOPN(1);
    VALUE pattern = TOPN(0);
    VALUE result;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, flag);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN checkmatch
#   line 698 "insns.def"
{
    result = vm_check_match(ec, target, pattern, flag);
}
#   line 1940 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = result;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(checkmatch);
}

/* insn checkkeyword(kw_bits_index, keyword_index)()(ret) */
INSN_ENTRY(checkkeyword)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(checkkeyword);
    DEBUG_ENTER_INSN("checkkeyword");

    /* ###  Declare and assign variables. ### */
    lindex_t kw_bits_index = (lindex_t)GET_OPERAND(1);
    lindex_t keyword_index = (lindex_t)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _checkkeyword(kw_bits_index, keyword_index)
    bool leaf = INSN_ATTR(leaf);
    VALUE ret;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, kw_bits_index);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, keyword_index);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN checkkeyword
#   line 708 "insns.def"
{
    ret = vm_check_keyword(kw_bits_index, keyword_index, GET_EP());
}
#   line 1984 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = ret;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(checkkeyword);
}

/* insn checktype(type)(val)(ret) */
INSN_ENTRY(checktype)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(checktype);
    DEBUG_ENTER_INSN("checktype");

    /* ###  Declare and assign variables. ### */
    rb_num_t type = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _checktype(type)
    bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);
    VALUE ret;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, type);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN checktype
#   line 718 "insns.def"
{
    ret = (TYPE(val) == (int)type) ? Qtrue : Qfalse;
}
#   line 2027 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = ret;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(checktype);
}

/* insn defineclass(id, class_iseq, flags)(cbase, super)(val) */
INSN_ENTRY(defineclass)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(defineclass);
    DEBUG_ENTER_INSN("defineclass");

    /* ###  Declare and assign variables. ### */
    ID id = (ID)GET_OPERAND(1);
    ISEQ class_iseq = (ISEQ)GET_OPERAND(2);
    rb_num_t flags = (rb_num_t)GET_OPERAND(3);
#   define INSN_ATTR(x) attr_ ## x ## _defineclass(id, class_iseq, flags)
    bool leaf = INSN_ATTR(leaf);
    VALUE cbase = TOPN(1);
    VALUE super = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, class_iseq);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 2, flags);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN defineclass
#   line 734 "insns.def"
{
    VALUE klass = vm_find_or_create_class_by_id(id, flags, cbase, super);

    rb_iseq_check(class_iseq);

    /* enter scope */
    vm_push_frame(ec, class_iseq, VM_FRAME_MAGIC_CLASS | VM_ENV_FLAG_LOCAL, klass,
		  GET_BLOCK_HANDLER(),
		  (VALUE)vm_cref_push(ec, klass, NULL, FALSE),
		  class_iseq->body->iseq_encoded, GET_SP(),
		  class_iseq->body->local_table_size,
		  class_iseq->body->stack_max);
    RESTORE_REGS();
    NEXT_INSN();
}
#   line 2088 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    PUSH(val);
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(defineclass);
}

/* insn definemethod(id, iseq)()() */
INSN_ENTRY(definemethod)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(definemethod);
    DEBUG_ENTER_INSN("definemethod");

    /* ###  Declare and assign variables. ### */
    ID id = (ID)GET_OPERAND(1);
    ISEQ iseq = (ISEQ)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _definemethod(id, iseq)
    bool leaf = INSN_ATTR(leaf);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, iseq);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN definemethod
#   line 755 "insns.def"
{
    vm_define_method(ec, Qnil, id, (VALUE)iseq, FALSE);
}
#   line 2129 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(definemethod);
}

/* insn definesmethod(id, iseq)(obj)() */
INSN_ENTRY(definesmethod)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(definesmethod);
    DEBUG_ENTER_INSN("definesmethod");

    /* ###  Declare and assign variables. ### */
    ID id = (ID)GET_OPERAND(1);
    ISEQ iseq = (ISEQ)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _definesmethod(id, iseq)
    bool leaf = INSN_ATTR(leaf);
    VALUE obj = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, iseq);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN definesmethod
#   line 764 "insns.def"
{
    vm_define_method(ec, obj, id, (VALUE)iseq, TRUE);
}
#   line 2170 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(definesmethod);
}

/* insn send(cd, blockiseq)(...)(val) */
INSN_ENTRY(send)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(send);
    DEBUG_ENTER_INSN("send");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
    ISEQ blockiseq = (ISEQ)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _send(cd, blockiseq)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, blockiseq);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN send
#   line 780 "insns.def"
{
    VALUE bh = vm_caller_setup_arg_block(ec, GET_CFP(), &cd->ci, blockiseq, false);
    val = vm_sendish(ec, GET_CFP(), cd, bh, vm_search_method_wrap);

    if (val == Qundef) {
        RESTORE_REGS();
        NEXT_INSN();
    }
}
#   line 2217 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    PUSH(val);
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(send);
}

/* insn opt_send_without_block(cd)(...)(val) */
INSN_ENTRY(opt_send_without_block)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_send_without_block);
    DEBUG_ENTER_INSN("opt_send_without_block");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_send_without_block(cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_send_without_block
#   line 799 "insns.def"
{
    VALUE bh = VM_BLOCK_HANDLER_NONE;
    val = vm_sendish(ec, GET_CFP(), cd, bh, vm_search_method_wrap);

    if (val == Qundef) {
        RESTORE_REGS();
        NEXT_INSN();
    }
}
#   line 2263 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    PUSH(val);
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_send_without_block);
}

/* insn opt_str_freeze(str, cd)()(val) */
INSN_ENTRY(opt_str_freeze)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_str_freeze);
    DEBUG_ENTER_INSN("opt_str_freeze");

    /* ###  Declare and assign variables. ### */
    VALUE str = (VALUE)GET_OPERAND(1);
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _opt_str_freeze(str, cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, str);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_str_freeze
#   line 814 "insns.def"
{
    val = vm_opt_str_freeze(str, BOP_FREEZE, idFreeze);

    if (val == Qundef) {
        PUSH(rb_str_resurrect(str));
        CALL_SIMPLE_METHOD();
    }
}
#   line 2309 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_str_freeze);
}

/* insn opt_nil_p(cd)(recv)(val) */
INSN_ENTRY(opt_nil_p)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_nil_p);
    DEBUG_ENTER_INSN("opt_nil_p");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_nil_p(cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_nil_p
#   line 829 "insns.def"
{
    val = vm_opt_nil_p(cd, recv);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 2356 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_nil_p);
}

/* insn opt_str_uminus(str, cd)()(val) */
INSN_ENTRY(opt_str_uminus)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_str_uminus);
    DEBUG_ENTER_INSN("opt_str_uminus");

    /* ###  Declare and assign variables. ### */
    VALUE str = (VALUE)GET_OPERAND(1);
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _opt_str_uminus(str, cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, str);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_str_uminus
#   line 842 "insns.def"
{
    val = vm_opt_str_freeze(str, BOP_UMINUS, idUMinus);

    if (val == Qundef) {
        PUSH(rb_str_resurrect(str));
        CALL_SIMPLE_METHOD();
    }
}
#   line 2405 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_str_uminus);
}

/* insn opt_newarray_max(num)(...)(val) */
INSN_ENTRY(opt_newarray_max)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_newarray_max);
    DEBUG_ENTER_INSN("opt_newarray_max");

    /* ###  Declare and assign variables. ### */
    rb_num_t num = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_newarray_max(num)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, num);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_newarray_max
#   line 862 "insns.def"
{
    val = vm_opt_newarray_max(num, STACK_ADDR_FROM_TOP(num));
}
#   line 2447 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_newarray_max);
}

/* insn opt_newarray_min(num)(...)(val) */
INSN_ENTRY(opt_newarray_min)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_newarray_min);
    DEBUG_ENTER_INSN("opt_newarray_min");

    /* ###  Declare and assign variables. ### */
    rb_num_t num = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_newarray_min(num)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, num);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_newarray_min
#   line 874 "insns.def"
{
    val = vm_opt_newarray_min(num, STACK_ADDR_FROM_TOP(num));
}
#   line 2489 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_newarray_min);
}

/* insn invokesuper(cd, blockiseq)(...)(val) */
INSN_ENTRY(invokesuper)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(invokesuper);
    DEBUG_ENTER_INSN("invokesuper");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
    ISEQ blockiseq = (ISEQ)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _invokesuper(cd, blockiseq)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, blockiseq);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN invokesuper
#   line 886 "insns.def"
{
    VALUE bh = vm_caller_setup_arg_block(ec, GET_CFP(), &cd->ci, blockiseq, true);
    val = vm_sendish(ec, GET_CFP(), cd, bh, vm_search_super_method);

    if (val == Qundef) {
        RESTORE_REGS();
        NEXT_INSN();
    }
}
#   line 2540 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    PUSH(val);
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(invokesuper);
}

/* insn invokeblock(cd)(...)(val) */
INSN_ENTRY(invokeblock)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(invokeblock);
    DEBUG_ENTER_INSN("invokeblock");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _invokeblock(cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN invokeblock
#   line 905 "insns.def"
{
    if (UNLIKELY(cd->cc.call != vm_invokeblock_i)) {
        cd->cc.call = vm_invokeblock_i; // check before setting to avoid CoW
    }

    VALUE bh = VM_BLOCK_HANDLER_NONE;
    val = vm_sendish(ec, GET_CFP(), cd, bh, vm_search_invokeblock);

    if (val == Qundef) {
        RESTORE_REGS();
        NEXT_INSN();
    }
}
#   line 2590 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    PUSH(val);
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(invokeblock);
}

/* insn leave()(val)(val) */
INSN_ENTRY(leave)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(leave);
    DEBUG_ENTER_INSN("leave");

    /* ###  Declare and assign variables. ### */
#   define INSN_ATTR(x) attr_ ## x ## _leave()
    bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN leave
#   line 930 "insns.def"
{
    if (OPT_CHECKED_RUN) {
        const VALUE *const bp = vm_base_ptr(GET_CFP());
        if (GET_SP() != bp) {
            vm_stack_consistency_error(ec, GET_CFP(), bp);
	}
    }

    if (vm_pop_frame(ec, GET_CFP(), GET_EP())) {
#   if OPT_CALL_THREADED_CODE
	rb_ec_thread_ptr(ec)->retval = val;
	return 0;
#   else
	return val;
#   endif
    }
    else {
	RESTORE_REGS();
    }
}
#   line 2645 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    PUSH(val);
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(leave);
}

/* insn throw(throw_state)(throwobj)(val) */
INSN_ENTRY(throw)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(throw);
    DEBUG_ENTER_INSN("throw");

    /* ###  Declare and assign variables. ### */
    rb_num_t throw_state = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _throw(throw_state)
    bool leaf = INSN_ATTR(leaf);
    VALUE throwobj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, throw_state);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN throw
#   line 963 "insns.def"
{
    val = vm_throw(ec, GET_CFP(), throw_state, throwobj);
    THROW_EXCEPTION(val);
    /* unreachable */
}
#   line 2687 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(throw);
}

/* insn jump(dst)()() */
INSN_ENTRY(jump)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(jump);
    DEBUG_ENTER_INSN("jump");

    /* ###  Declare and assign variables. ### */
    OFFSET dst = (OFFSET)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _jump(dst)
    bool leaf = INSN_ATTR(leaf);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, dst);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN jump
#   line 981 "insns.def"
{
    RUBY_VM_CHECK_INTS(ec);
    JUMP(dst);
}
#   line 2729 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(jump);
}

/* insn branchif(dst)(val)() */
INSN_ENTRY(branchif)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(branchif);
    DEBUG_ENTER_INSN("branchif");

    /* ###  Declare and assign variables. ### */
    OFFSET dst = (OFFSET)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _branchif(dst)
    bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, dst);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN branchif
#   line 994 "insns.def"
{
    if (RTEST(val)) {
	RUBY_VM_CHECK_INTS(ec);
	JUMP(dst);
    }
}
#   line 2771 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(branchif);
}

/* insn branchunless(dst)(val)() */
INSN_ENTRY(branchunless)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(branchunless);
    DEBUG_ENTER_INSN("branchunless");

    /* ###  Declare and assign variables. ### */
    OFFSET dst = (OFFSET)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _branchunless(dst)
    bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, dst);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN branchunless
#   line 1009 "insns.def"
{
    if (!RTEST(val)) {
	RUBY_VM_CHECK_INTS(ec);
	JUMP(dst);
    }
}
#   line 2813 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(branchunless);
}

/* insn branchnil(dst)(val)() */
INSN_ENTRY(branchnil)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(branchnil);
    DEBUG_ENTER_INSN("branchnil");

    /* ###  Declare and assign variables. ### */
    OFFSET dst = (OFFSET)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _branchnil(dst)
    bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, dst);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN branchnil
#   line 1024 "insns.def"
{
    if (NIL_P(val)) {
	RUBY_VM_CHECK_INTS(ec);
	JUMP(dst);
    }
}
#   line 2855 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(branchnil);
}

/* insn opt_getinlinecache(dst, ic)()(val) */
INSN_ENTRY(opt_getinlinecache)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_getinlinecache);
    DEBUG_ENTER_INSN("opt_getinlinecache");

    /* ###  Declare and assign variables. ### */
    OFFSET dst = (OFFSET)GET_OPERAND(1);
    IC ic = (IC)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _opt_getinlinecache(dst, ic)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, dst);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, ic);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_getinlinecache
#   line 1041 "insns.def"
{
    if (vm_ic_hit_p(ic, GET_EP())) {
	val = ic->value;
	JUMP(dst);
    }
    else {
	val = Qnil;
    }
}
#   line 2902 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_getinlinecache);
}

/* insn opt_setinlinecache(ic)(val)(val) */
INSN_ENTRY(opt_setinlinecache)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_setinlinecache);
    DEBUG_ENTER_INSN("opt_setinlinecache");

    /* ###  Declare and assign variables. ### */
    IC ic = (IC)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_setinlinecache(ic)
    bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ic);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_setinlinecache
#   line 1057 "insns.def"
{
    vm_ic_update(ic, val, GET_EP());
}
#   line 2944 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_setinlinecache);
}

/* insn once(iseq, ise)()(val) */
INSN_ENTRY(once)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(once);
    DEBUG_ENTER_INSN("once");

    /* ###  Declare and assign variables. ### */
    ISEQ iseq = (ISEQ)GET_OPERAND(1);
    ISE ise = (ISE)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _once(iseq, ise)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, iseq);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, ise);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN once
#   line 1067 "insns.def"
{
    val = vm_once_dispatch(ec, iseq, ise);
}
#   line 2989 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    PUSH(val);
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(once);
}

/* insn opt_case_dispatch(hash, else_offset)(..., key)() */
INSN_ENTRY(opt_case_dispatch)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_case_dispatch);
    DEBUG_ENTER_INSN("opt_case_dispatch");

    /* ###  Declare and assign variables. ### */
    CDHASH hash = (CDHASH)GET_OPERAND(1);
    OFFSET else_offset = (OFFSET)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _opt_case_dispatch(hash, else_offset)
    bool leaf = INSN_ATTR(leaf);
    VALUE key = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, hash);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, else_offset);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_case_dispatch
#   line 1078 "insns.def"
{
    OFFSET dst = vm_case_dispatch(hash, else_offset, key);

    if (dst) {
	JUMP(dst);
    }
}
#   line 3034 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_case_dispatch);
}

/* insn opt_plus(cd)(recv, obj)(val) */
INSN_ENTRY(opt_plus)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_plus);
    DEBUG_ENTER_INSN("opt_plus");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_plus(cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_plus
#   line 1094 "insns.def"
{
    val = vm_opt_plus(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3079 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_plus);
}

/* insn opt_minus(cd)(recv, obj)(val) */
INSN_ENTRY(opt_minus)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_minus);
    DEBUG_ENTER_INSN("opt_minus");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_minus(cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_minus
#   line 1108 "insns.def"
{
    val = vm_opt_minus(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3127 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_minus);
}

/* insn opt_mult(cd)(recv, obj)(val) */
INSN_ENTRY(opt_mult)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_mult);
    DEBUG_ENTER_INSN("opt_mult");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_mult(cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_mult
#   line 1122 "insns.def"
{
    val = vm_opt_mult(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3175 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_mult);
}

/* insn opt_div(cd)(recv, obj)(val) */
INSN_ENTRY(opt_div)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_div);
    DEBUG_ENTER_INSN("opt_div");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_div(cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_div
#   line 1139 "insns.def"
{
    val = vm_opt_div(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3223 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_div);
}

/* insn opt_mod(cd)(recv, obj)(val) */
INSN_ENTRY(opt_mod)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_mod);
    DEBUG_ENTER_INSN("opt_mod");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_mod(cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_mod
#   line 1155 "insns.def"
{
    val = vm_opt_mod(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3271 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_mod);
}

/* insn opt_eq(cd)(recv, obj)(val) */
INSN_ENTRY(opt_eq)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_eq);
    DEBUG_ENTER_INSN("opt_eq");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_eq(cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_eq
#   line 1169 "insns.def"
{
    val = opt_eq_func(recv, obj, cd);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3319 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_eq);
}

/* insn opt_neq(cd_eq, cd)(recv, obj)(val) */
INSN_ENTRY(opt_neq)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_neq);
    DEBUG_ENTER_INSN("opt_neq");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd_eq = (CALL_DATA)GET_OPERAND(1);
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _opt_neq(cd_eq, cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd_eq);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_neq
#   line 1183 "insns.def"
{
    val = vm_opt_neq(cd, cd_eq, recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3369 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_neq);
}

/* insn opt_lt(cd)(recv, obj)(val) */
INSN_ENTRY(opt_lt)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_lt);
    DEBUG_ENTER_INSN("opt_lt");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_lt(cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_lt
#   line 1197 "insns.def"
{
    val = vm_opt_lt(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3417 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_lt);
}

/* insn opt_le(cd)(recv, obj)(val) */
INSN_ENTRY(opt_le)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_le);
    DEBUG_ENTER_INSN("opt_le");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_le(cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_le
#   line 1211 "insns.def"
{
    val = vm_opt_le(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3465 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_le);
}

/* insn opt_gt(cd)(recv, obj)(val) */
INSN_ENTRY(opt_gt)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_gt);
    DEBUG_ENTER_INSN("opt_gt");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_gt(cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_gt
#   line 1225 "insns.def"
{
    val = vm_opt_gt(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3513 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_gt);
}

/* insn opt_ge(cd)(recv, obj)(val) */
INSN_ENTRY(opt_ge)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_ge);
    DEBUG_ENTER_INSN("opt_ge");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_ge(cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_ge
#   line 1239 "insns.def"
{
    val = vm_opt_ge(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3561 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_ge);
}

/* insn opt_ltlt(cd)(recv, obj)(val) */
INSN_ENTRY(opt_ltlt)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_ltlt);
    DEBUG_ENTER_INSN("opt_ltlt");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_ltlt(cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_ltlt
#   line 1257 "insns.def"
{
    val = vm_opt_ltlt(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3609 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_ltlt);
}

/* insn opt_and(cd)(recv, obj)(val) */
INSN_ENTRY(opt_and)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_and);
    DEBUG_ENTER_INSN("opt_and");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_and(cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_and
#   line 1271 "insns.def"
{
    val = vm_opt_and(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3657 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_and);
}

/* insn opt_or(cd)(recv, obj)(val) */
INSN_ENTRY(opt_or)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_or);
    DEBUG_ENTER_INSN("opt_or");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_or(cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_or
#   line 1285 "insns.def"
{
    val = vm_opt_or(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3705 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_or);
}

/* insn opt_aref(cd)(recv, obj)(val) */
INSN_ENTRY(opt_aref)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_aref);
    DEBUG_ENTER_INSN("opt_aref");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_aref(cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_aref
#   line 1304 "insns.def"
{
    val = vm_opt_aref(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3753 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_aref);
}

/* insn opt_aset(cd)(recv, obj, set)(val) */
INSN_ENTRY(opt_aset)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_aset);
    DEBUG_ENTER_INSN("opt_aset");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_aset(cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(2);
    VALUE obj = TOPN(1);
    VALUE set = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_aset
#   line 1321 "insns.def"
{
    val = vm_opt_aset(recv, obj, set);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3802 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_aset);
}

/* insn opt_aset_with(key, cd)(recv, val)(val) */
INSN_ENTRY(opt_aset_with)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_aset_with);
    DEBUG_ENTER_INSN("opt_aset_with");

    /* ###  Declare and assign variables. ### */
    VALUE key = (VALUE)GET_OPERAND(1);
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _opt_aset_with(key, cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, key);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_aset_with
#   line 1337 "insns.def"
{
    VALUE tmp = vm_opt_aset_with(recv, key, val);

    if (tmp != Qundef) {
	val = tmp;
    }
    else {
#   ifndef MJIT_HEADER
	TOPN(0) = rb_str_resurrect(key);
	PUSH(val);
#   endif
        CALL_SIMPLE_METHOD();
    }
}
#   line 3858 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_aset_with);
}

/* insn opt_aref_with(key, cd)(recv)(val) */
INSN_ENTRY(opt_aref_with)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_aref_with);
    DEBUG_ENTER_INSN("opt_aref_with");

    /* ###  Declare and assign variables. ### */
    VALUE key = (VALUE)GET_OPERAND(1);
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _opt_aref_with(key, cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, key);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_aref_with
#   line 1360 "insns.def"
{
    val = vm_opt_aref_with(recv, key);

    if (val == Qundef) {
#   ifndef MJIT_HEADER
	PUSH(rb_str_resurrect(key));
#   endif
        CALL_SIMPLE_METHOD();
    }
}
#   line 3910 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_aref_with);
}

/* insn opt_length(cd)(recv)(val) */
INSN_ENTRY(opt_length)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_length);
    DEBUG_ENTER_INSN("opt_length");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_length(cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_length
#   line 1377 "insns.def"
{
    val = vm_opt_length(recv, BOP_LENGTH);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3957 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_length);
}

/* insn opt_size(cd)(recv)(val) */
INSN_ENTRY(opt_size)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_size);
    DEBUG_ENTER_INSN("opt_size");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_size(cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_size
#   line 1391 "insns.def"
{
    val = vm_opt_length(recv, BOP_SIZE);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 4004 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_size);
}

/* insn opt_empty_p(cd)(recv)(val) */
INSN_ENTRY(opt_empty_p)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_empty_p);
    DEBUG_ENTER_INSN("opt_empty_p");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_empty_p(cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_empty_p
#   line 1405 "insns.def"
{
    val = vm_opt_empty_p(recv);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 4051 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_empty_p);
}

/* insn opt_succ(cd)(recv)(val) */
INSN_ENTRY(opt_succ)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_succ);
    DEBUG_ENTER_INSN("opt_succ");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_succ(cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_succ
#   line 1419 "insns.def"
{
    val = vm_opt_succ(recv);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 4098 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_succ);
}

/* insn opt_not(cd)(recv)(val) */
INSN_ENTRY(opt_not)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_not);
    DEBUG_ENTER_INSN("opt_not");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_not(cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_not
#   line 1433 "insns.def"
{
    val = vm_opt_not(cd, recv);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 4145 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_not);
}

/* insn opt_regexpmatch2(cd)(obj2, obj1)(val) */
INSN_ENTRY(opt_regexpmatch2)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_regexpmatch2);
    DEBUG_ENTER_INSN("opt_regexpmatch2");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_regexpmatch2(cd)
    bool leaf = INSN_ATTR(leaf);
    VALUE obj2 = TOPN(1);
    VALUE obj1 = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_regexpmatch2
#   line 1448 "insns.def"
{
    val = vm_opt_regexpmatch2(obj2, obj1);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 4193 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_regexpmatch2);
}

/* insn opt_call_c_function(funcptr)()() */
INSN_ENTRY(opt_call_c_function)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_call_c_function);
    DEBUG_ENTER_INSN("opt_call_c_function");

    /* ###  Declare and assign variables. ### */
    rb_insn_func_t funcptr = (rb_insn_func_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_call_c_function(funcptr)
    bool leaf = INSN_ATTR(leaf);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, funcptr);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_call_c_function
#   line 1464 "insns.def"
{
    reg_cfp = (funcptr)(ec, reg_cfp);

    if (reg_cfp == 0) {
	VALUE err = ec->errinfo;
	ec->errinfo = Qnil;
	THROW_EXCEPTION(err);
    }

    RESTORE_REGS();
    NEXT_INSN();
}
#   line 4244 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_call_c_function);
}

/* insn invokebuiltin(bf)(...)(ret) */
INSN_ENTRY(invokebuiltin)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(invokebuiltin);
    DEBUG_ENTER_INSN("invokebuiltin");

    /* ###  Declare and assign variables. ### */
    RB_BUILTIN bf = (RB_BUILTIN)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _invokebuiltin(bf)
    bool leaf = INSN_ATTR(leaf);
    VALUE ret;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, bf);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN invokebuiltin
#   line 1485 "insns.def"
{
    ret = vm_invoke_builtin(ec, reg_cfp, bf, STACK_ADDR_FROM_TOP(bf->argc));
}
#   line 4282 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = ret;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(invokebuiltin);
}

/* insn opt_invokebuiltin_delegate(bf, index)()(ret) */
INSN_ENTRY(opt_invokebuiltin_delegate)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_invokebuiltin_delegate);
    DEBUG_ENTER_INSN("opt_invokebuiltin_delegate");

    /* ###  Declare and assign variables. ### */
    RB_BUILTIN bf = (RB_BUILTIN)GET_OPERAND(1);
    rb_num_t index = (rb_num_t)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _opt_invokebuiltin_delegate(bf, index)
    bool leaf = INSN_ATTR(leaf);
    VALUE ret;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, bf);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, index);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_invokebuiltin_delegate
#   line 1496 "insns.def"
{
    ret = vm_invoke_builtin_delegate(ec, reg_cfp, bf, (unsigned int)index);
}
#   line 4326 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = ret;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_invokebuiltin_delegate);
}

/* insn opt_invokebuiltin_delegate_leave(bf, index)()(val) */
INSN_ENTRY(opt_invokebuiltin_delegate_leave)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_invokebuiltin_delegate_leave);
    DEBUG_ENTER_INSN("opt_invokebuiltin_delegate_leave");

    /* ###  Declare and assign variables. ### */
    RB_BUILTIN bf = (RB_BUILTIN)GET_OPERAND(1);
    rb_num_t index = (rb_num_t)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _opt_invokebuiltin_delegate_leave(bf, index)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, bf);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, index);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_invokebuiltin_delegate_leave
#   line 1507 "insns.def"
{
    val = vm_invoke_builtin_delegate(ec, reg_cfp, bf, (unsigned int)index);

    /* leave fastpath */
    /* TracePoint/return should fallback this insn to opt_invokebuiltin_delegate */
    if (vm_pop_frame(ec, GET_CFP(), GET_EP())) {
#   if OPT_CALL_THREADED_CODE
        rb_ec_thread_ptr(ec)->retval = val;
        return 0;
#   else
        return val;
#   endif
    }
    else {
        RESTORE_REGS();
    }
}
#   line 4384 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_invokebuiltin_delegate_leave);
}

/* insn getlocal_WC_0(idx)()(val) */
INSN_ENTRY(getlocal_WC_0)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(getlocal_WC_0);
    DEBUG_ENTER_INSN("getlocal_WC_0");

    /* ###  Declare and assign variables. ### */
#line 10 "defs/opt_operand.def"
    const rb_num_t level = 0;
#line 4411 "vm.inc"
    lindex_t idx = (lindex_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _getlocal_WC_0(idx)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN getlocal_WC_0
#   line 81 "insns.def"
{
    val = *(vm_get_ep(GET_EP(), level) - idx);
    RB_DEBUG_COUNTER_INC(lvar_get);
    (void)RB_DEBUG_COUNTER_INC_IF(lvar_get_dynamic, level > 0);
}
#   line 4431 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(getlocal_WC_0);
}

/* insn getlocal_WC_1(idx)()(val) */
INSN_ENTRY(getlocal_WC_1)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(getlocal_WC_1);
    DEBUG_ENTER_INSN("getlocal_WC_1");

    /* ###  Declare and assign variables. ### */
#line 11 "defs/opt_operand.def"
    const rb_num_t level = 1;
#line 4458 "vm.inc"
    lindex_t idx = (lindex_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _getlocal_WC_1(idx)
    bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN getlocal_WC_1
#   line 81 "insns.def"
{
    val = *(vm_get_ep(GET_EP(), level) - idx);
    RB_DEBUG_COUNTER_INC(lvar_get);
    (void)RB_DEBUG_COUNTER_INC_IF(lvar_get_dynamic, level > 0);
}
#   line 4478 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(getlocal_WC_1);
}

/* insn setlocal_WC_0(idx)(val)() */
INSN_ENTRY(setlocal_WC_0)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(setlocal_WC_0);
    DEBUG_ENTER_INSN("setlocal_WC_0");

    /* ###  Declare and assign variables. ### */
#line 12 "defs/opt_operand.def"
    const rb_num_t level = 0;
#line 4505 "vm.inc"
    lindex_t idx = (lindex_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _setlocal_WC_0(idx)
    bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN setlocal_WC_0
#   line 95 "insns.def"
{
    vm_env_write(vm_get_ep(GET_EP(), level), -(int)idx, val);
    RB_DEBUG_COUNTER_INC(lvar_set);
    (void)RB_DEBUG_COUNTER_INC_IF(lvar_set_dynamic, level > 0);
}
#   line 4525 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(setlocal_WC_0);
}

/* insn setlocal_WC_1(idx)(val)() */
INSN_ENTRY(setlocal_WC_1)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(setlocal_WC_1);
    DEBUG_ENTER_INSN("setlocal_WC_1");

    /* ###  Declare and assign variables. ### */
#line 13 "defs/opt_operand.def"
    const rb_num_t level = 1;
#line 4549 "vm.inc"
    lindex_t idx = (lindex_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _setlocal_WC_1(idx)
    bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN setlocal_WC_1
#   line 95 "insns.def"
{
    vm_env_write(vm_get_ep(GET_EP(), level), -(int)idx, val);
    RB_DEBUG_COUNTER_INC(lvar_set);
    (void)RB_DEBUG_COUNTER_INC_IF(lvar_set_dynamic, level > 0);
}
#   line 4569 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(setlocal_WC_1);
}

/* insn putobject_INT2FIX_0_()()(val) */
INSN_ENTRY(putobject_INT2FIX_0_)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(putobject_INT2FIX_0_);
    DEBUG_ENTER_INSN("putobject_INT2FIX_0_");

    /* ###  Declare and assign variables. ### */
#line 15 "defs/opt_operand.def"
    const VALUE val = INT2FIX(0);
#line 4593 "vm.inc"
#   define INSN_ATTR(x) attr_ ## x ## _putobject_INT2FIX_0_()
    bool leaf = INSN_ATTR(leaf);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(putobject_INT2FIX_0_);
}

/* insn putobject_INT2FIX_1_()()(val) */
INSN_ENTRY(putobject_INT2FIX_1_)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(putobject_INT2FIX_1_);
    DEBUG_ENTER_INSN("putobject_INT2FIX_1_");

    /* ###  Declare and assign variables. ### */
#line 16 "defs/opt_operand.def"
    const VALUE val = INT2FIX(1);
#line 4624 "vm.inc"
#   define INSN_ATTR(x) attr_ ## x ## _putobject_INT2FIX_1_()
    bool leaf = INSN_ATTR(leaf);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(putobject_INT2FIX_1_);
}

/* insn trace_nop(...)(...)(...) */
INSN_ENTRY(trace_nop)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(nop);
    END_INSN(trace_nop);
}

/* insn trace_getlocal(...)(...)(...) */
INSN_ENTRY(trace_getlocal)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(getlocal);
    END_INSN(trace_getlocal);
}

/* insn trace_setlocal(...)(...)(...) */
INSN_ENTRY(trace_setlocal)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(setlocal);
    END_INSN(trace_setlocal);
}

/* insn trace_getblockparam(...)(...)(...) */
INSN_ENTRY(trace_getblockparam)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(getblockparam);
    END_INSN(trace_getblockparam);
}

/* insn trace_setblockparam(...)(...)(...) */
INSN_ENTRY(trace_setblockparam)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(setblockparam);
    END_INSN(trace_setblockparam);
}

/* insn trace_getblockparamproxy(...)(...)(...) */
INSN_ENTRY(trace_getblockparamproxy)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(getblockparamproxy);
    END_INSN(trace_getblockparamproxy);
}

/* insn trace_getspecial(...)(...)(...) */
INSN_ENTRY(trace_getspecial)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(getspecial);
    END_INSN(trace_getspecial);
}

/* insn trace_setspecial(...)(...)(...) */
INSN_ENTRY(trace_setspecial)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(setspecial);
    END_INSN(trace_setspecial);
}

/* insn trace_getinstancevariable(...)(...)(...) */
INSN_ENTRY(trace_getinstancevariable)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(getinstancevariable);
    END_INSN(trace_getinstancevariable);
}

/* insn trace_setinstancevariable(...)(...)(...) */
INSN_ENTRY(trace_setinstancevariable)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(setinstancevariable);
    END_INSN(trace_setinstancevariable);
}

/* insn trace_getclassvariable(...)(...)(...) */
INSN_ENTRY(trace_getclassvariable)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(getclassvariable);
    END_INSN(trace_getclassvariable);
}

/* insn trace_setclassvariable(...)(...)(...) */
INSN_ENTRY(trace_setclassvariable)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(setclassvariable);
    END_INSN(trace_setclassvariable);
}

/* insn trace_getconstant(...)(...)(...) */
INSN_ENTRY(trace_getconstant)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(getconstant);
    END_INSN(trace_getconstant);
}

/* insn trace_setconstant(...)(...)(...) */
INSN_ENTRY(trace_setconstant)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(setconstant);
    END_INSN(trace_setconstant);
}

/* insn trace_getglobal(...)(...)(...) */
INSN_ENTRY(trace_getglobal)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(getglobal);
    END_INSN(trace_getglobal);
}

/* insn trace_setglobal(...)(...)(...) */
INSN_ENTRY(trace_setglobal)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(setglobal);
    END_INSN(trace_setglobal);
}

/* insn trace_putnil(...)(...)(...) */
INSN_ENTRY(trace_putnil)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(putnil);
    END_INSN(trace_putnil);
}

/* insn trace_putself(...)(...)(...) */
INSN_ENTRY(trace_putself)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(putself);
    END_INSN(trace_putself);
}

/* insn trace_putobject(...)(...)(...) */
INSN_ENTRY(trace_putobject)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(putobject);
    END_INSN(trace_putobject);
}

/* insn trace_putspecialobject(...)(...)(...) */
INSN_ENTRY(trace_putspecialobject)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(putspecialobject);
    END_INSN(trace_putspecialobject);
}

/* insn trace_putstring(...)(...)(...) */
INSN_ENTRY(trace_putstring)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(putstring);
    END_INSN(trace_putstring);
}

/* insn trace_concatstrings(...)(...)(...) */
INSN_ENTRY(trace_concatstrings)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(concatstrings);
    END_INSN(trace_concatstrings);
}

/* insn trace_tostring(...)(...)(...) */
INSN_ENTRY(trace_tostring)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(tostring);
    END_INSN(trace_tostring);
}

/* insn trace_freezestring(...)(...)(...) */
INSN_ENTRY(trace_freezestring)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(freezestring);
    END_INSN(trace_freezestring);
}

/* insn trace_toregexp(...)(...)(...) */
INSN_ENTRY(trace_toregexp)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(toregexp);
    END_INSN(trace_toregexp);
}

/* insn trace_intern(...)(...)(...) */
INSN_ENTRY(trace_intern)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(intern);
    END_INSN(trace_intern);
}

/* insn trace_newarray(...)(...)(...) */
INSN_ENTRY(trace_newarray)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(newarray);
    END_INSN(trace_newarray);
}

/* insn trace_newarraykwsplat(...)(...)(...) */
INSN_ENTRY(trace_newarraykwsplat)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(newarraykwsplat);
    END_INSN(trace_newarraykwsplat);
}

/* insn trace_duparray(...)(...)(...) */
INSN_ENTRY(trace_duparray)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(duparray);
    END_INSN(trace_duparray);
}

/* insn trace_duphash(...)(...)(...) */
INSN_ENTRY(trace_duphash)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(duphash);
    END_INSN(trace_duphash);
}

/* insn trace_expandarray(...)(...)(...) */
INSN_ENTRY(trace_expandarray)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(expandarray);
    END_INSN(trace_expandarray);
}

/* insn trace_concatarray(...)(...)(...) */
INSN_ENTRY(trace_concatarray)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(concatarray);
    END_INSN(trace_concatarray);
}

/* insn trace_splatarray(...)(...)(...) */
INSN_ENTRY(trace_splatarray)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(splatarray);
    END_INSN(trace_splatarray);
}

/* insn trace_newhash(...)(...)(...) */
INSN_ENTRY(trace_newhash)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(newhash);
    END_INSN(trace_newhash);
}

/* insn trace_newrange(...)(...)(...) */
INSN_ENTRY(trace_newrange)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(newrange);
    END_INSN(trace_newrange);
}

/* insn trace_pop(...)(...)(...) */
INSN_ENTRY(trace_pop)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(pop);
    END_INSN(trace_pop);
}

/* insn trace_dup(...)(...)(...) */
INSN_ENTRY(trace_dup)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(dup);
    END_INSN(trace_dup);
}

/* insn trace_dupn(...)(...)(...) */
INSN_ENTRY(trace_dupn)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(dupn);
    END_INSN(trace_dupn);
}

/* insn trace_swap(...)(...)(...) */
INSN_ENTRY(trace_swap)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(swap);
    END_INSN(trace_swap);
}

/* insn trace_reverse(...)(...)(...) */
INSN_ENTRY(trace_reverse)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(reverse);
    END_INSN(trace_reverse);
}

/* insn trace_topn(...)(...)(...) */
INSN_ENTRY(trace_topn)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(topn);
    END_INSN(trace_topn);
}

/* insn trace_setn(...)(...)(...) */
INSN_ENTRY(trace_setn)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(setn);
    END_INSN(trace_setn);
}

/* insn trace_adjuststack(...)(...)(...) */
INSN_ENTRY(trace_adjuststack)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(adjuststack);
    END_INSN(trace_adjuststack);
}

/* insn trace_defined(...)(...)(...) */
INSN_ENTRY(trace_defined)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(defined);
    END_INSN(trace_defined);
}

/* insn trace_checkmatch(...)(...)(...) */
INSN_ENTRY(trace_checkmatch)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(checkmatch);
    END_INSN(trace_checkmatch);
}

/* insn trace_checkkeyword(...)(...)(...) */
INSN_ENTRY(trace_checkkeyword)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(checkkeyword);
    END_INSN(trace_checkkeyword);
}

/* insn trace_checktype(...)(...)(...) */
INSN_ENTRY(trace_checktype)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(checktype);
    END_INSN(trace_checktype);
}

/* insn trace_defineclass(...)(...)(...) */
INSN_ENTRY(trace_defineclass)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(defineclass);
    END_INSN(trace_defineclass);
}

/* insn trace_definemethod(...)(...)(...) */
INSN_ENTRY(trace_definemethod)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(definemethod);
    END_INSN(trace_definemethod);
}

/* insn trace_definesmethod(...)(...)(...) */
INSN_ENTRY(trace_definesmethod)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(definesmethod);
    END_INSN(trace_definesmethod);
}

/* insn trace_send(...)(...)(...) */
INSN_ENTRY(trace_send)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(send);
    END_INSN(trace_send);
}

/* insn trace_opt_send_without_block(...)(...)(...) */
INSN_ENTRY(trace_opt_send_without_block)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_send_without_block);
}

/* insn trace_opt_str_freeze(...)(...)(...) */
INSN_ENTRY(trace_opt_str_freeze)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_str_freeze);
    END_INSN(trace_opt_str_freeze);
}

/* insn trace_opt_nil_p(...)(...)(...) */
INSN_ENTRY(trace_opt_nil_p)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_nil_p);
    END_INSN(trace_opt_nil_p);
}

/* insn trace_opt_str_uminus(...)(...)(...) */
INSN_ENTRY(trace_opt_str_uminus)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_str_uminus);
    END_INSN(trace_opt_str_uminus);
}

/* insn trace_opt_newarray_max(...)(...)(...) */
INSN_ENTRY(trace_opt_newarray_max)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_newarray_max);
    END_INSN(trace_opt_newarray_max);
}

/* insn trace_opt_newarray_min(...)(...)(...) */
INSN_ENTRY(trace_opt_newarray_min)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_newarray_min);
    END_INSN(trace_opt_newarray_min);
}

/* insn trace_invokesuper(...)(...)(...) */
INSN_ENTRY(trace_invokesuper)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(invokesuper);
    END_INSN(trace_invokesuper);
}

/* insn trace_invokeblock(...)(...)(...) */
INSN_ENTRY(trace_invokeblock)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(invokeblock);
    END_INSN(trace_invokeblock);
}

/* insn trace_leave(...)(...)(...) */
INSN_ENTRY(trace_leave)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(leave);
    END_INSN(trace_leave);
}

/* insn trace_throw(...)(...)(...) */
INSN_ENTRY(trace_throw)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(throw);
    END_INSN(trace_throw);
}

/* insn trace_jump(...)(...)(...) */
INSN_ENTRY(trace_jump)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(jump);
    END_INSN(trace_jump);
}

/* insn trace_branchif(...)(...)(...) */
INSN_ENTRY(trace_branchif)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(branchif);
    END_INSN(trace_branchif);
}

/* insn trace_branchunless(...)(...)(...) */
INSN_ENTRY(trace_branchunless)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(branchunless);
    END_INSN(trace_branchunless);
}

/* insn trace_branchnil(...)(...)(...) */
INSN_ENTRY(trace_branchnil)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(branchnil);
    END_INSN(trace_branchnil);
}

/* insn trace_opt_getinlinecache(...)(...)(...) */
INSN_ENTRY(trace_opt_getinlinecache)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_getinlinecache);
    END_INSN(trace_opt_getinlinecache);
}

/* insn trace_opt_setinlinecache(...)(...)(...) */
INSN_ENTRY(trace_opt_setinlinecache)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_setinlinecache);
    END_INSN(trace_opt_setinlinecache);
}

/* insn trace_once(...)(...)(...) */
INSN_ENTRY(trace_once)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(once);
    END_INSN(trace_once);
}

/* insn trace_opt_case_dispatch(...)(...)(...) */
INSN_ENTRY(trace_opt_case_dispatch)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_case_dispatch);
    END_INSN(trace_opt_case_dispatch);
}

/* insn trace_opt_plus(...)(...)(...) */
INSN_ENTRY(trace_opt_plus)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_plus);
    END_INSN(trace_opt_plus);
}

/* insn trace_opt_minus(...)(...)(...) */
INSN_ENTRY(trace_opt_minus)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_minus);
    END_INSN(trace_opt_minus);
}

/* insn trace_opt_mult(...)(...)(...) */
INSN_ENTRY(trace_opt_mult)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_mult);
    END_INSN(trace_opt_mult);
}

/* insn trace_opt_div(...)(...)(...) */
INSN_ENTRY(trace_opt_div)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_div);
    END_INSN(trace_opt_div);
}

/* insn trace_opt_mod(...)(...)(...) */
INSN_ENTRY(trace_opt_mod)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_mod);
    END_INSN(trace_opt_mod);
}

/* insn trace_opt_eq(...)(...)(...) */
INSN_ENTRY(trace_opt_eq)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_eq);
    END_INSN(trace_opt_eq);
}

/* insn trace_opt_neq(...)(...)(...) */
INSN_ENTRY(trace_opt_neq)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_neq);
    END_INSN(trace_opt_neq);
}

/* insn trace_opt_lt(...)(...)(...) */
INSN_ENTRY(trace_opt_lt)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_lt);
    END_INSN(trace_opt_lt);
}

/* insn trace_opt_le(...)(...)(...) */
INSN_ENTRY(trace_opt_le)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_le);
    END_INSN(trace_opt_le);
}

/* insn trace_opt_gt(...)(...)(...) */
INSN_ENTRY(trace_opt_gt)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_gt);
    END_INSN(trace_opt_gt);
}

/* insn trace_opt_ge(...)(...)(...) */
INSN_ENTRY(trace_opt_ge)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_ge);
    END_INSN(trace_opt_ge);
}

/* insn trace_opt_ltlt(...)(...)(...) */
INSN_ENTRY(trace_opt_ltlt)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_ltlt);
    END_INSN(trace_opt_ltlt);
}

/* insn trace_opt_and(...)(...)(...) */
INSN_ENTRY(trace_opt_and)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_and);
    END_INSN(trace_opt_and);
}

/* insn trace_opt_or(...)(...)(...) */
INSN_ENTRY(trace_opt_or)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_or);
    END_INSN(trace_opt_or);
}

/* insn trace_opt_aref(...)(...)(...) */
INSN_ENTRY(trace_opt_aref)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_aref);
    END_INSN(trace_opt_aref);
}

/* insn trace_opt_aset(...)(...)(...) */
INSN_ENTRY(trace_opt_aset)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_aset);
    END_INSN(trace_opt_aset);
}

/* insn trace_opt_aset_with(...)(...)(...) */
INSN_ENTRY(trace_opt_aset_with)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_aset_with);
    END_INSN(trace_opt_aset_with);
}

/* insn trace_opt_aref_with(...)(...)(...) */
INSN_ENTRY(trace_opt_aref_with)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_aref_with);
    END_INSN(trace_opt_aref_with);
}

/* insn trace_opt_length(...)(...)(...) */
INSN_ENTRY(trace_opt_length)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_length);
    END_INSN(trace_opt_length);
}

/* insn trace_opt_size(...)(...)(...) */
INSN_ENTRY(trace_opt_size)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_size);
    END_INSN(trace_opt_size);
}

/* insn trace_opt_empty_p(...)(...)(...) */
INSN_ENTRY(trace_opt_empty_p)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_empty_p);
    END_INSN(trace_opt_empty_p);
}

/* insn trace_opt_succ(...)(...)(...) */
INSN_ENTRY(trace_opt_succ)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_succ);
    END_INSN(trace_opt_succ);
}

/* insn trace_opt_not(...)(...)(...) */
INSN_ENTRY(trace_opt_not)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_not);
    END_INSN(trace_opt_not);
}

/* insn trace_opt_regexpmatch2(...)(...)(...) */
INSN_ENTRY(trace_opt_regexpmatch2)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_regexpmatch2);
    END_INSN(trace_opt_regexpmatch2);
}

/* insn trace_opt_call_c_function(...)(...)(...) */
INSN_ENTRY(trace_opt_call_c_function)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_call_c_function);
    END_INSN(trace_opt_call_c_function);
}

/* insn trace_invokebuiltin(...)(...)(...) */
INSN_ENTRY(trace_invokebuiltin)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(invokebuiltin);
    END_INSN(trace_invokebuiltin);
}

/* insn trace_opt_invokebuiltin_delegate(...)(...)(...) */
INSN_ENTRY(trace_opt_invokebuiltin_delegate)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_invokebuiltin_delegate);
    END_INSN(trace_opt_invokebuiltin_delegate);
}

/* insn trace_opt_invokebuiltin_delegate_leave(...)(...)(...) */
INSN_ENTRY(trace_opt_invokebuiltin_delegate_leave)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_invokebuiltin_delegate_leave);
    END_INSN(trace_opt_invokebuiltin_delegate_leave);
}

/* insn trace_getlocal_WC_0(...)(...)(...) */
INSN_ENTRY(trace_getlocal_WC_0)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(getlocal_WC_0);
    END_INSN(trace_getlocal_WC_0);
}

/* insn trace_getlocal_WC_1(...)(...)(...) */
INSN_ENTRY(trace_getlocal_WC_1)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(getlocal_WC_1);
    END_INSN(trace_getlocal_WC_1);
}

/* insn trace_setlocal_WC_0(...)(...)(...) */
INSN_ENTRY(trace_setlocal_WC_0)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(setlocal_WC_0);
    END_INSN(trace_setlocal_WC_0);
}

/* insn trace_setlocal_WC_1(...)(...)(...) */
INSN_ENTRY(trace_setlocal_WC_1)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(setlocal_WC_1);
    END_INSN(trace_setlocal_WC_1);
}

/* insn trace_putobject_INT2FIX_0_(...)(...)(...) */
INSN_ENTRY(trace_putobject_INT2FIX_0_)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(putobject_INT2FIX_0_);
    END_INSN(trace_putobject_INT2FIX_0_);
}

/* insn trace_putobject_INT2FIX_1_(...)(...)(...) */
INSN_ENTRY(trace_putobject_INT2FIX_1_)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(putobject_INT2FIX_1_);
    END_INSN(trace_putobject_INT2FIX_1_);
}
