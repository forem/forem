/* -*- mode:c; style:ruby; coding: utf-8; indent-tabs-mode: nil -*- */

/* This is  an auto-generated file  and is a  part of the  programming language
 * Ruby.  The  person who  created  a  program  to  generate this  file  (``I''
 * hereafter) would like  to refrain from defining licensing  of this generated
 * source code.
 *
 * This file consist of many small  parts of codes copyrighted by each authors,
 * not  only  the  ``I''  person.   Those  original  authors  agree  with  some
 * open-source license.  I  believe that the license we agree  is the condition
 * mentioned in  the file COPYING.  It  states "4.  You may  modify and include
 * the part of the software into any  other software ...".  But the problem is,
 * the license never makes it clear if  such modified parts still remain in the
 * same  license, or  not.   The fact  that  we agree  with  the source  code's
 * licensing terms do not automatically define that of generated ones.  This is
 * the reason  why this file  is under unclear situation.   All that I  know is
 * that above provision guarantees this file to exist.
 *
 * Please let me  hesitate to declare something about this  nuanced contract. I
 * am not in the position to take  over other authors' license to merge into my
 * one.  Changing them to (say) GPLv3  is not doable by myself. Perhaps someday
 * it might turn out to be okay to say this file is under a license. I wish the
 * situation would become more clear in the future. */

/*******************************************************************/
/*******************************************************************/
/*******************************************************************/
/**
  This file is VM main loop.

  ----
  This file is auto generated by insns2vm.rb
  DO NOT TOUCH!

  If you want to fix something, you must edit "tool/ruby_vm/views/vm.inc.erb"
  or tool/insns2vm.rb
 */

#include "vm_insnhelper.h"

/* insn nop()()() */
INSN_ENTRY(nop)
{
#   define NAME_OF_CURRENT_INSN nop
#   define INSN_ATTR(x) attr_ ## x ## _nop()
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    START_OF_ORIGINAL_INSN(nop);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(nop);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn getlocal(idx, level)()(val) */
INSN_ENTRY(getlocal)
{
#   define NAME_OF_CURRENT_INSN getlocal
#   define INSN_ATTR(x) attr_ ## x ## _getlocal(idx, level)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;
    MAYBE_UNUSED(lindex_t) idx;
    MAYBE_UNUSED(rb_num_t) level;

    START_OF_ORIGINAL_INSN(getlocal);
    idx = (lindex_t)GET_OPERAND(1);
    level = (rb_num_t)GET_OPERAND(2);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, level);
#line 81 "insns.def"
{
    val = *(vm_get_ep(GET_EP(), level) - idx);
    RB_DEBUG_COUNTER_INC(lvar_get);
    (void)RB_DEBUG_COUNTER_INC_IF(lvar_get_dynamic, level > 0);
}
#line 87 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(getlocal);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn setlocal(idx, level)(val)() */
INSN_ENTRY(setlocal)
{
#   define NAME_OF_CURRENT_INSN setlocal
#   define INSN_ATTR(x) attr_ ## x ## _setlocal(idx, level)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;
    MAYBE_UNUSED(lindex_t) idx;
    MAYBE_UNUSED(rb_num_t) level;

    START_OF_ORIGINAL_INSN(setlocal);
    idx = (lindex_t)GET_OPERAND(1);
    level = (rb_num_t)GET_OPERAND(2);
    val = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, level);
#line 95 "insns.def"
{
    vm_env_write(vm_get_ep(GET_EP(), level), -(int)idx, val);
    RB_DEBUG_COUNTER_INC(lvar_set);
    (void)RB_DEBUG_COUNTER_INC_IF(lvar_set_dynamic, level > 0);
}
#line 125 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(setlocal);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn getblockparam(idx, level)()(val) */
INSN_ENTRY(getblockparam)
{
#   define NAME_OF_CURRENT_INSN getblockparam
#   define INSN_ATTR(x) attr_ ## x ## _getblockparam(idx, level)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;
    MAYBE_UNUSED(lindex_t) idx;
    MAYBE_UNUSED(rb_num_t) level;

    START_OF_ORIGINAL_INSN(getblockparam);
    idx = (lindex_t)GET_OPERAND(1);
    level = (rb_num_t)GET_OPERAND(2);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, level);
#line 107 "insns.def"
{
    const VALUE *ep = vm_get_ep(GET_EP(), level);
    VM_ASSERT(VM_ENV_LOCAL_P(ep));

    if (!VM_ENV_FLAGS(ep, VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM)) {
	val = rb_vm_bh_to_procval(ec, VM_ENV_BLOCK_HANDLER(ep));
	vm_env_write(ep, -(int)idx, val);
	VM_ENV_FLAGS_SET(ep, VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM);
    }
    else {
	val = *(ep - idx);
	RB_DEBUG_COUNTER_INC(lvar_get);
	(void)RB_DEBUG_COUNTER_INC_IF(lvar_get_dynamic, level > 0);
    }
}
#line 171 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(getblockparam);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn setblockparam(idx, level)(val)() */
INSN_ENTRY(setblockparam)
{
#   define NAME_OF_CURRENT_INSN setblockparam
#   define INSN_ATTR(x) attr_ ## x ## _setblockparam(idx, level)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;
    MAYBE_UNUSED(lindex_t) idx;
    MAYBE_UNUSED(rb_num_t) level;

    START_OF_ORIGINAL_INSN(setblockparam);
    idx = (lindex_t)GET_OPERAND(1);
    level = (rb_num_t)GET_OPERAND(2);
    val = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, level);
#line 129 "insns.def"
{
    const VALUE *ep = vm_get_ep(GET_EP(), level);
    VM_ASSERT(VM_ENV_LOCAL_P(ep));

    vm_env_write(ep, -(int)idx, val);
    RB_DEBUG_COUNTER_INC(lvar_set);
    (void)RB_DEBUG_COUNTER_INC_IF(lvar_set_dynamic, level > 0);

    VM_ENV_FLAGS_SET(ep, VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM);
}
#line 214 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(setblockparam);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn getblockparamproxy(idx, level)()(val) */
INSN_ENTRY(getblockparamproxy)
{
#   define NAME_OF_CURRENT_INSN getblockparamproxy
#   define INSN_ATTR(x) attr_ ## x ## _getblockparamproxy(idx, level)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;
    MAYBE_UNUSED(lindex_t) idx;
    MAYBE_UNUSED(rb_num_t) level;

    START_OF_ORIGINAL_INSN(getblockparamproxy);
    idx = (lindex_t)GET_OPERAND(1);
    level = (rb_num_t)GET_OPERAND(2);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, level);
#line 148 "insns.def"
{
    const VALUE *ep = vm_get_ep(GET_EP(), level);
    VM_ASSERT(VM_ENV_LOCAL_P(ep));

    if (!VM_ENV_FLAGS(ep, VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM)) {
	VALUE block_handler = VM_ENV_BLOCK_HANDLER(ep);

	if (block_handler) {
	    switch (vm_block_handler_type(block_handler)) {
	      case block_handler_type_iseq:
	      case block_handler_type_ifunc:
		val = rb_block_param_proxy;
		break;
	      case block_handler_type_symbol:
		val = rb_sym_to_proc(VM_BH_TO_SYMBOL(block_handler));
		goto INSN_LABEL(set);
	      case block_handler_type_proc:
		val = VM_BH_TO_PROC(block_handler);
		goto INSN_LABEL(set);
	      default:
		VM_UNREACHABLE(getblockparamproxy);
	    }
	}
	else {
	    val = Qnil;
	  INSN_LABEL(set):
	    vm_env_write(ep, -(int)idx, val);
	    VM_ENV_FLAGS_SET(ep, VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM);
	}
    }
    else {
	val = *(ep - idx);
	RB_DEBUG_COUNTER_INC(lvar_get);
	(void)RB_DEBUG_COUNTER_INC_IF(lvar_get_dynamic, level > 0);
    }
}
#line 281 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(getblockparamproxy);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn getspecial(key, type)()(val) */
INSN_ENTRY(getspecial)
{
#   define NAME_OF_CURRENT_INSN getspecial
#   define INSN_ATTR(x) attr_ ## x ## _getspecial(key, type)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;
    MAYBE_UNUSED(rb_num_t) key, type;

    START_OF_ORIGINAL_INSN(getspecial);
    key = (rb_num_t)GET_OPERAND(1);
    type = (rb_num_t)GET_OPERAND(2);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, key);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, type);
#line 191 "insns.def"
{
    val = vm_getspecial(ec, GET_LEP(), key, type);
}
#line 315 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(getspecial);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn setspecial(key)(obj)() */
INSN_ENTRY(setspecial)
{
#   define NAME_OF_CURRENT_INSN setspecial
#   define INSN_ATTR(x) attr_ ## x ## _setspecial(key)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) obj;
    MAYBE_UNUSED(rb_num_t) key;

    START_OF_ORIGINAL_INSN(setspecial);
    key = (rb_num_t)GET_OPERAND(1);
    obj = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, key);
#line 201 "insns.def"
{
    lep_svar_set(ec, GET_LEP(), key, obj);
}
#line 348 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(setspecial);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn getinstancevariable(id, ic)()(val) */
INSN_ENTRY(getinstancevariable)
{
#   define NAME_OF_CURRENT_INSN getinstancevariable
#   define INSN_ATTR(x) attr_ ## x ## _getinstancevariable(id, ic)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(IC) ic;
    MAYBE_UNUSED(ID) id;
    MAYBE_UNUSED(VALUE) val;

    START_OF_ORIGINAL_INSN(getinstancevariable);
    id = (ID)GET_OPERAND(1);
    ic = (IC)GET_OPERAND(2);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, ic);
#line 213 "insns.def"
{
    val = vm_getinstancevariable(GET_SELF(), id, ic);
}
#line 382 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(getinstancevariable);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn setinstancevariable(id, ic)(val)() */
INSN_ENTRY(setinstancevariable)
{
#   define NAME_OF_CURRENT_INSN setinstancevariable
#   define INSN_ATTR(x) attr_ ## x ## _setinstancevariable(id, ic)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(IC) ic;
    MAYBE_UNUSED(ID) id;
    MAYBE_UNUSED(VALUE) val;

    START_OF_ORIGINAL_INSN(setinstancevariable);
    id = (ID)GET_OPERAND(1);
    ic = (IC)GET_OPERAND(2);
    val = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, ic);
#line 223 "insns.def"
{
    vm_setinstancevariable(GET_SELF(), id, val, ic);
}
#line 418 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(setinstancevariable);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn getclassvariable(id)()(val) */
INSN_ENTRY(getclassvariable)
{
#   define NAME_OF_CURRENT_INSN getclassvariable
#   define INSN_ATTR(x) attr_ ## x ## _getclassvariable(id)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(ID) id;
    MAYBE_UNUSED(VALUE) val;

    START_OF_ORIGINAL_INSN(getclassvariable);
    id = (ID)GET_OPERAND(1);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);
#line 235 "insns.def"
{
    val = rb_cvar_get(vm_get_cvar_base(rb_vm_get_cref(GET_EP()), GET_CFP()), id);
}
#line 449 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(getclassvariable);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn setclassvariable(id)(val)() */
INSN_ENTRY(setclassvariable)
{
#   define NAME_OF_CURRENT_INSN setclassvariable
#   define INSN_ATTR(x) attr_ ## x ## _setclassvariable(id)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(ID) id;
    MAYBE_UNUSED(VALUE) val;

    START_OF_ORIGINAL_INSN(setclassvariable);
    id = (ID)GET_OPERAND(1);
    val = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);
#line 247 "insns.def"
{
    vm_ensure_not_refinement_module(GET_SELF());
    rb_cvar_set(vm_get_cvar_base(rb_vm_get_cref(GET_EP()), GET_CFP()), id, val);
}
#line 483 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(setclassvariable);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn getconstant(id)(klass)(val) */
INSN_ENTRY(getconstant)
{
#   define NAME_OF_CURRENT_INSN getconstant
#   define INSN_ATTR(x) attr_ ## x ## _getconstant(id)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(ID) id;
    MAYBE_UNUSED(VALUE) klass, val;

    START_OF_ORIGINAL_INSN(getconstant);
    id = (ID)GET_OPERAND(1);
    klass = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);
#line 263 "insns.def"
{
    val = vm_get_ev_const(ec, klass, id, 0);
}
#line 515 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(getconstant);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn setconstant(id)(val, cbase)() */
INSN_ENTRY(setconstant)
{
#   define NAME_OF_CURRENT_INSN setconstant
#   define INSN_ATTR(x) attr_ ## x ## _setconstant(id)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(ID) id;
    MAYBE_UNUSED(VALUE) cbase, val;

    START_OF_ORIGINAL_INSN(setconstant);
    id = (ID)GET_OPERAND(1);
    val = TOPN(1);
    cbase = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);
#line 279 "insns.def"
{
    vm_check_if_namespace(cbase);
    vm_ensure_not_refinement_module(GET_SELF());
    rb_const_set(cbase, id, val);
}
#line 551 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(setconstant);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn getglobal(entry)()(val) */
INSN_ENTRY(getglobal)
{
#   define NAME_OF_CURRENT_INSN getglobal
#   define INSN_ATTR(x) attr_ ## x ## _getglobal(entry)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(GENTRY) entry;
    MAYBE_UNUSED(VALUE) val;

    START_OF_ORIGINAL_INSN(getglobal);
    entry = (GENTRY)GET_OPERAND(1);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, entry);
#line 292 "insns.def"
{
    val = GET_GLOBAL((VALUE)entry);
}
#line 582 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(getglobal);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn setglobal(entry)(val)() */
INSN_ENTRY(setglobal)
{
#   define NAME_OF_CURRENT_INSN setglobal
#   define INSN_ATTR(x) attr_ ## x ## _setglobal(entry)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(GENTRY) entry;
    MAYBE_UNUSED(VALUE) val;

    START_OF_ORIGINAL_INSN(setglobal);
    entry = (GENTRY)GET_OPERAND(1);
    val = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, entry);
#line 303 "insns.def"
{
    SET_GLOBAL((VALUE)entry, val);
}
#line 615 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(setglobal);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn putnil()()(val) */
INSN_ENTRY(putnil)
{
#   define NAME_OF_CURRENT_INSN putnil
#   define INSN_ATTR(x) attr_ ## x ## _putnil()
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;

    START_OF_ORIGINAL_INSN(putnil);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
#line 317 "insns.def"
{
    val = Qnil;
}
#line 643 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(putnil);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn putself()()(val) */
INSN_ENTRY(putself)
{
#   define NAME_OF_CURRENT_INSN putself
#   define INSN_ATTR(x) attr_ ## x ## _putself()
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;

    START_OF_ORIGINAL_INSN(putself);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
#line 327 "insns.def"
{
    val = GET_SELF();
}
#line 672 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(putself);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn putobject(val)()(val) */
INSN_ENTRY(putobject)
{
#   define NAME_OF_CURRENT_INSN putobject
#   define INSN_ATTR(x) attr_ ## x ## _putobject(val)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;

    START_OF_ORIGINAL_INSN(putobject);
    val = (VALUE)GET_OPERAND(1);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, val);
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(putobject);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn putspecialobject(value_type)()(val) */
INSN_ENTRY(putspecialobject)
{
#   define NAME_OF_CURRENT_INSN putspecialobject
#   define INSN_ATTR(x) attr_ ## x ## _putspecialobject(value_type)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;
    MAYBE_UNUSED(rb_num_t) value_type;

    START_OF_ORIGINAL_INSN(putspecialobject);
    value_type = (rb_num_t)GET_OPERAND(1);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, value_type);
#line 349 "insns.def"
{
    enum vm_special_object_type type;

    type = (enum vm_special_object_type)value_type;
    val = vm_get_special_object(GET_EP(), type);
}
#line 731 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(putspecialobject);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn putiseq(iseq)()(ret) */
INSN_ENTRY(putiseq)
{
#   define NAME_OF_CURRENT_INSN putiseq
#   define INSN_ATTR(x) attr_ ## x ## _putiseq(iseq)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(ISEQ) iseq;
    MAYBE_UNUSED(VALUE) ret;

    START_OF_ORIGINAL_INSN(putiseq);
    iseq = (ISEQ)GET_OPERAND(1);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, iseq);
#line 363 "insns.def"
{
    ret = (VALUE)iseq;
}
#line 763 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = ret;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(putiseq);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn putstring(str)()(val) */
INSN_ENTRY(putstring)
{
#   define NAME_OF_CURRENT_INSN putstring
#   define INSN_ATTR(x) attr_ ## x ## _putstring(str)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) str, val;

    START_OF_ORIGINAL_INSN(putstring);
    str = (VALUE)GET_OPERAND(1);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, str);
#line 373 "insns.def"
{
    val = rb_str_resurrect(str);
}
#line 794 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(putstring);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn concatstrings(num)(...)(val) */
INSN_ENTRY(concatstrings)
{
#   define NAME_OF_CURRENT_INSN concatstrings
#   define INSN_ATTR(x) attr_ ## x ## _concatstrings(num)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;
    MAYBE_UNUSED(rb_num_t) num;

    START_OF_ORIGINAL_INSN(concatstrings);
    num = (rb_num_t)GET_OPERAND(1);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, num);
#line 384 "insns.def"
{
    val = rb_str_concat_literals(num, STACK_ADDR_FROM_TOP(num));
}
#line 826 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(concatstrings);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn tostring()(val, str)(val) */
INSN_ENTRY(tostring)
{
#   define NAME_OF_CURRENT_INSN tostring
#   define INSN_ATTR(x) attr_ ## x ## _tostring()
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) str, val;

    START_OF_ORIGINAL_INSN(tostring);
    val = TOPN(1);
    str = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
#line 394 "insns.def"
{
    val = rb_obj_as_string_result(str, val);
}
#line 857 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(tostring);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn freezestring(debug_info)(str)(str) */
INSN_ENTRY(freezestring)
{
#   define NAME_OF_CURRENT_INSN freezestring
#   define INSN_ATTR(x) attr_ ## x ## _freezestring(debug_info)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) debug_info, str;

    START_OF_ORIGINAL_INSN(freezestring);
    debug_info = (VALUE)GET_OPERAND(1);
    str = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, debug_info);
#line 404 "insns.def"
{
    vm_freezestring(str, debug_info);
}
#line 889 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = str;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(freezestring);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn toregexp(opt, cnt)(...)(val) */
INSN_ENTRY(toregexp)
{
#   define NAME_OF_CURRENT_INSN toregexp
#   define INSN_ATTR(x) attr_ ## x ## _toregexp(opt, cnt)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;
    MAYBE_UNUSED(rb_num_t) cnt, opt;

    START_OF_ORIGINAL_INSN(toregexp);
    opt = (rb_num_t)GET_OPERAND(1);
    cnt = (rb_num_t)GET_OPERAND(2);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, opt);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cnt);
#line 420 "insns.def"
{
    const VALUE ary = rb_ary_tmp_new_from_values(0, cnt, STACK_ADDR_FROM_TOP(cnt));
    val = rb_reg_new_ary(ary, (int)opt);
    rb_ary_clear(ary);
}
#line 925 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(toregexp);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn intern()(str)(sym) */
INSN_ENTRY(intern)
{
#   define NAME_OF_CURRENT_INSN intern
#   define INSN_ATTR(x) attr_ ## x ## _intern()
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) str, sym;

    START_OF_ORIGINAL_INSN(intern);
    str = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
#line 432 "insns.def"
{
    sym = rb_str_intern(str);
}
#line 955 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = sym;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(intern);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn newarray(num)(...)(val) */
INSN_ENTRY(newarray)
{
#   define NAME_OF_CURRENT_INSN newarray
#   define INSN_ATTR(x) attr_ ## x ## _newarray(num)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;
    MAYBE_UNUSED(rb_num_t) num;

    START_OF_ORIGINAL_INSN(newarray);
    num = (rb_num_t)GET_OPERAND(1);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, num);
#line 443 "insns.def"
{
    val = rb_ary_new4(num, STACK_ADDR_FROM_TOP(num));
}
#line 987 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(newarray);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn duparray(ary)()(val) */
INSN_ENTRY(duparray)
{
#   define NAME_OF_CURRENT_INSN duparray
#   define INSN_ATTR(x) attr_ ## x ## _duparray(ary)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) ary, val;

    START_OF_ORIGINAL_INSN(duparray);
    ary = (VALUE)GET_OPERAND(1);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ary);
#line 453 "insns.def"
{
    val = rb_ary_resurrect(ary);
}
#line 1018 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(duparray);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn duphash(hash)()(val) */
INSN_ENTRY(duphash)
{
#   define NAME_OF_CURRENT_INSN duphash
#   define INSN_ATTR(x) attr_ ## x ## _duphash(hash)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) hash, val;

    START_OF_ORIGINAL_INSN(duphash);
    hash = (VALUE)GET_OPERAND(1);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, hash);
#line 463 "insns.def"
{
    val = rb_hash_resurrect(hash);
}
#line 1049 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(duphash);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn expandarray(num, flag)(..., ary)(...) */
INSN_ENTRY(expandarray)
{
#   define NAME_OF_CURRENT_INSN expandarray
#   define INSN_ATTR(x) attr_ ## x ## _expandarray(num, flag)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) ary;
    MAYBE_UNUSED(rb_num_t) flag, num;

    START_OF_ORIGINAL_INSN(expandarray);
    num = (rb_num_t)GET_OPERAND(1);
    flag = (rb_num_t)GET_OPERAND(2);
    ary = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, num);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, flag);
#line 483 "insns.def"
{
    vm_expandarray(GET_SP(), ary, num, (int)flag);
}
#line 1083 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(expandarray);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn concatarray()(ary1, ary2)(ary) */
INSN_ENTRY(concatarray)
{
#   define NAME_OF_CURRENT_INSN concatarray
#   define INSN_ATTR(x) attr_ ## x ## _concatarray()
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) ary, ary1, ary2;

    START_OF_ORIGINAL_INSN(concatarray);
    ary1 = TOPN(1);
    ary2 = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
#line 494 "insns.def"
{
    ary = vm_concat_array(ary1, ary2);
}
#line 1112 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = ary;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(concatarray);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn splatarray(flag)(ary)(obj) */
INSN_ENTRY(splatarray)
{
#   define NAME_OF_CURRENT_INSN splatarray
#   define INSN_ATTR(x) attr_ ## x ## _splatarray(flag)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) ary, flag, obj;

    START_OF_ORIGINAL_INSN(splatarray);
    flag = (VALUE)GET_OPERAND(1);
    ary = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, flag);
#line 505 "insns.def"
{
    obj = vm_splat_array(flag, ary);
}
#line 1144 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = obj;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(splatarray);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn newhash(num)(...)(val) */
INSN_ENTRY(newhash)
{
#   define NAME_OF_CURRENT_INSN newhash
#   define INSN_ATTR(x) attr_ ## x ## _newhash(num)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;
    MAYBE_UNUSED(rb_num_t) num;

    START_OF_ORIGINAL_INSN(newhash);
    num = (rb_num_t)GET_OPERAND(1);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, num);
#line 517 "insns.def"
{
    RUBY_DTRACE_CREATE_HOOK(HASH, num);

    val = rb_hash_new_with_size(num / 2);

    if (num) {
        rb_hash_bulk_insert(num, STACK_ADDR_FROM_TOP(num), val);
    }
}
#line 1182 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(newhash);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn newrange(flag)(low, high)(val) */
INSN_ENTRY(newrange)
{
#   define NAME_OF_CURRENT_INSN newrange
#   define INSN_ATTR(x) attr_ ## x ## _newrange(flag)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) high, low, val;
    MAYBE_UNUSED(rb_num_t) flag;

    START_OF_ORIGINAL_INSN(newrange);
    flag = (rb_num_t)GET_OPERAND(1);
    low = TOPN(1);
    high = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, flag);
#line 535 "insns.def"
{
    val = rb_range_new(low, high, (int)flag);
}
#line 1216 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(newrange);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn pop()(val)() */
INSN_ENTRY(pop)
{
#   define NAME_OF_CURRENT_INSN pop
#   define INSN_ATTR(x) attr_ ## x ## _pop()
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;

    START_OF_ORIGINAL_INSN(pop);
    val = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
#line 549 "insns.def"
{
    (void)val;
    /* none */
}
#line 1247 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(pop);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn dup()(val)(val1, val2) */
INSN_ENTRY(dup)
{
#   define NAME_OF_CURRENT_INSN dup
#   define INSN_ATTR(x) attr_ ## x ## _dup()
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val, val1, val2;

    START_OF_ORIGINAL_INSN(dup);
    val = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
#line 560 "insns.def"
{
    val1 = val2 = val;
}
#line 1276 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val2;
    TOPN(1) = val1;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(dup);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn dupn(n)(...)(...) */
INSN_ENTRY(dupn)
{
#   define NAME_OF_CURRENT_INSN dupn
#   define INSN_ATTR(x) attr_ ## x ## _dupn(n)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(rb_num_t) n;

    START_OF_ORIGINAL_INSN(dupn);
    n = (rb_num_t)GET_OPERAND(1);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, n);
#line 571 "insns.def"
{
    void *dst = GET_SP();
    void *src = STACK_ADDR_FROM_TOP(n);

    MEMCPY(dst, src, VALUE, n);
}
#line 1310 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(dupn);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn swap()(val, obj)(obj, val) */
INSN_ENTRY(swap)
{
#   define NAME_OF_CURRENT_INSN swap
#   define INSN_ATTR(x) attr_ ## x ## _swap()
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) obj, val;

    START_OF_ORIGINAL_INSN(swap);
    val = TOPN(1);
    obj = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    TOPN(1) = obj;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(swap);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn reverse(n)(...)(...) */
INSN_ENTRY(reverse)
{
#   define NAME_OF_CURRENT_INSN reverse
#   define INSN_ATTR(x) attr_ ## x ## _reverse(n)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(rb_num_t) n;

    START_OF_ORIGINAL_INSN(reverse);
    n = (rb_num_t)GET_OPERAND(1);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, n);
#line 595 "insns.def"
{
    rb_num_t i;
    VALUE *sp = STACK_ADDR_FROM_TOP(n);

    for (i=0; i<n/2; i++) {
	VALUE v0 = sp[i];
	VALUE v1 = TOPN(i);
	sp[i] = v1;
	TOPN(i) = v0;
    }
}
#line 1371 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(reverse);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn reput()(..., val)(val) */
INSN_ENTRY(reput)
{
#   define NAME_OF_CURRENT_INSN reput
#   define INSN_ATTR(x) attr_ ## x ## _reput()
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;

    START_OF_ORIGINAL_INSN(reput);
    val = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(reput);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn topn(n)(...)(val) */
INSN_ENTRY(topn)
{
#   define NAME_OF_CURRENT_INSN topn
#   define INSN_ATTR(x) attr_ ## x ## _topn(n)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;
    MAYBE_UNUSED(rb_num_t) n;

    START_OF_ORIGINAL_INSN(topn);
    n = (rb_num_t)GET_OPERAND(1);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, n);
#line 625 "insns.def"
{
    val = TOPN(n);
}
#line 1424 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(topn);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn setn(n)(..., val)(val) */
INSN_ENTRY(setn)
{
#   define NAME_OF_CURRENT_INSN setn
#   define INSN_ATTR(x) attr_ ## x ## _setn(n)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;
    MAYBE_UNUSED(rb_num_t) n;

    START_OF_ORIGINAL_INSN(setn);
    n = (rb_num_t)GET_OPERAND(1);
    val = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, n);
#line 636 "insns.def"
{
    TOPN(n) = val;
}
#line 1457 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(setn);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn adjuststack(n)(...)(...) */
INSN_ENTRY(adjuststack)
{
#   define NAME_OF_CURRENT_INSN adjuststack
#   define INSN_ATTR(x) attr_ ## x ## _adjuststack(n)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(rb_num_t) n;

    START_OF_ORIGINAL_INSN(adjuststack);
    n = (rb_num_t)GET_OPERAND(1);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, n);
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(adjuststack);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn defined(op_type, obj, needstr)(v)(val) */
INSN_ENTRY(defined)
{
#   define NAME_OF_CURRENT_INSN defined
#   define INSN_ATTR(x) attr_ ## x ## _defined(op_type, obj, needstr)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) needstr, obj, v, val;
    MAYBE_UNUSED(rb_num_t) op_type;

    START_OF_ORIGINAL_INSN(defined);
    op_type = (rb_num_t)GET_OPERAND(1);
    obj = (VALUE)GET_OPERAND(2);
    needstr = (VALUE)GET_OPERAND(3);
    v = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, op_type);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, obj);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 2, needstr);
#line 662 "insns.def"
{
    val = vm_defined(ec, GET_CFP(), op_type, obj, needstr, v);
}
#line 1517 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(defined);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn checkmatch(flag)(target, pattern)(result) */
INSN_ENTRY(checkmatch)
{
#   define NAME_OF_CURRENT_INSN checkmatch
#   define INSN_ATTR(x) attr_ ## x ## _checkmatch(flag)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) pattern, result, target;
    MAYBE_UNUSED(rb_num_t) flag;

    START_OF_ORIGINAL_INSN(checkmatch);
    flag = (rb_num_t)GET_OPERAND(1);
    target = TOPN(1);
    pattern = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, flag);
#line 679 "insns.def"
{
    result = vm_check_match(ec, target, pattern, flag);
}
#line 1551 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = result;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(checkmatch);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn checkkeyword(kw_bits_index, keyword_index)()(ret) */
INSN_ENTRY(checkkeyword)
{
#   define NAME_OF_CURRENT_INSN checkkeyword
#   define INSN_ATTR(x) attr_ ## x ## _checkkeyword(kw_bits_index, keyword_index)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) ret;
    MAYBE_UNUSED(lindex_t) keyword_index, kw_bits_index;

    START_OF_ORIGINAL_INSN(checkkeyword);
    kw_bits_index = (lindex_t)GET_OPERAND(1);
    keyword_index = (lindex_t)GET_OPERAND(2);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, kw_bits_index);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, keyword_index);
#line 689 "insns.def"
{
    ret = vm_check_keyword(kw_bits_index, keyword_index, GET_EP());
}
#line 1585 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = ret;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(checkkeyword);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn checktype(type)(val)(ret) */
INSN_ENTRY(checktype)
{
#   define NAME_OF_CURRENT_INSN checktype
#   define INSN_ATTR(x) attr_ ## x ## _checktype(type)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) ret, val;
    MAYBE_UNUSED(rb_num_t) type;

    START_OF_ORIGINAL_INSN(checktype);
    type = (rb_num_t)GET_OPERAND(1);
    val = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, type);
#line 699 "insns.def"
{
    ret = (TYPE(val) == (int)type) ? Qtrue : Qfalse;
}
#line 1618 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = ret;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(checktype);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn defineclass(id, class_iseq, flags)(cbase, super)(val) */
INSN_ENTRY(defineclass)
{
#   define NAME_OF_CURRENT_INSN defineclass
#   define INSN_ATTR(x) attr_ ## x ## _defineclass(id, class_iseq, flags)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(ID) id;
    MAYBE_UNUSED(ISEQ) class_iseq;
    MAYBE_UNUSED(VALUE) cbase, super, val;
    MAYBE_UNUSED(rb_num_t) flags;

    START_OF_ORIGINAL_INSN(defineclass);
    id = (ID)GET_OPERAND(1);
    class_iseq = (ISEQ)GET_OPERAND(2);
    flags = (rb_num_t)GET_OPERAND(3);
    cbase = TOPN(1);
    super = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, class_iseq);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 2, flags);
#line 715 "insns.def"
{
    VALUE klass = vm_find_or_create_class_by_id(id, flags, cbase, super);

    rb_iseq_check(class_iseq);

    /* enter scope */
    vm_push_frame(ec, class_iseq, VM_FRAME_MAGIC_CLASS | VM_ENV_FLAG_LOCAL, klass,
		  GET_BLOCK_HANDLER(),
		  (VALUE)vm_cref_push(ec, klass, NULL, FALSE),
		  class_iseq->body->iseq_encoded, GET_SP(),
		  class_iseq->body->local_table_size,
		  class_iseq->body->stack_max);
    RESTORE_REGS();
    NEXT_INSN();
}
#line 1671 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    PUSH(val);
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(defineclass);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn send(ci, cc, blockiseq)(...)(val) */
INSN_ENTRY(send)
{
#   define NAME_OF_CURRENT_INSN send
#   define INSN_ATTR(x) attr_ ## x ## _send(ci, cc, blockiseq)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(ISEQ) blockiseq;
    MAYBE_UNUSED(VALUE) val;

    START_OF_ORIGINAL_INSN(send);
    ci = (CALL_INFO)GET_OPERAND(1);
    cc = (CALL_CACHE)GET_OPERAND(2);
    blockiseq = (ISEQ)GET_OPERAND(3);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 2, blockiseq);
#line 742 "insns.def"
{
    struct rb_calling_info calling;

    calling.block_handler = vm_caller_setup_arg_block(ec, reg_cfp, ci, blockiseq, FALSE);
    calling.recv = TOPN(calling.argc = ci->orig_argc);
    vm_search_method(ci, cc, calling.recv);
    CALL_METHOD(&calling, ci, cc);
}
#line 1714 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    PUSH(val);
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(send);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_send_without_block(ci, cc)(...)(val) */
INSN_ENTRY(opt_send_without_block)
{
#   define NAME_OF_CURRENT_INSN opt_send_without_block
#   define INSN_ATTR(x) attr_ ## x ## _opt_send_without_block(ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) val;

    START_OF_ORIGINAL_INSN(opt_send_without_block);
    ci = (CALL_INFO)GET_OPERAND(1);
    cc = (CALL_CACHE)GET_OPERAND(2);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc);
#line 759 "insns.def"
{
    struct rb_calling_info calling;
    calling.block_handler = VM_BLOCK_HANDLER_NONE;
    vm_search_method(ci, cc, calling.recv = TOPN(calling.argc = ci->orig_argc));
    CALL_METHOD(&calling, ci, cc);
}
#line 1752 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    PUSH(val);
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_send_without_block);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_str_freeze(str, ci, cc)()(val) */
INSN_ENTRY(opt_str_freeze)
{
#   define NAME_OF_CURRENT_INSN opt_str_freeze
#   define INSN_ATTR(x) attr_ ## x ## _opt_str_freeze(str, ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) str, val;

    START_OF_ORIGINAL_INSN(opt_str_freeze);
    str = (VALUE)GET_OPERAND(1);
    ci = (CALL_INFO)GET_OPERAND(2);
    cc = (CALL_CACHE)GET_OPERAND(3);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, str);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 2, cc);
#line 771 "insns.def"
{
    val = vm_opt_str_freeze(str, BOP_FREEZE, idFreeze);

    if (val == Qundef) {
        PUSH(rb_str_resurrect(str));
        CALL_SIMPLE_METHOD();
    }
}
#line 1793 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_str_freeze);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_str_uminus(str, ci, cc)()(val) */
INSN_ENTRY(opt_str_uminus)
{
#   define NAME_OF_CURRENT_INSN opt_str_uminus
#   define INSN_ATTR(x) attr_ ## x ## _opt_str_uminus(str, ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) str, val;

    START_OF_ORIGINAL_INSN(opt_str_uminus);
    str = (VALUE)GET_OPERAND(1);
    ci = (CALL_INFO)GET_OPERAND(2);
    cc = (CALL_CACHE)GET_OPERAND(3);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, str);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 2, cc);
#line 785 "insns.def"
{
    val = vm_opt_str_freeze(str, BOP_UMINUS, idUMinus);

    if (val == Qundef) {
        PUSH(rb_str_resurrect(str));
        CALL_SIMPLE_METHOD();
    }
}
#line 1835 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_str_uminus);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_newarray_max(num)(...)(val) */
INSN_ENTRY(opt_newarray_max)
{
#   define NAME_OF_CURRENT_INSN opt_newarray_max
#   define INSN_ATTR(x) attr_ ## x ## _opt_newarray_max(num)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;
    MAYBE_UNUSED(rb_num_t) num;

    START_OF_ORIGINAL_INSN(opt_newarray_max);
    num = (rb_num_t)GET_OPERAND(1);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, num);
#line 805 "insns.def"
{
    val = vm_opt_newarray_max(num, STACK_ADDR_FROM_TOP(num));
}
#line 1867 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_newarray_max);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_newarray_min(num)(...)(val) */
INSN_ENTRY(opt_newarray_min)
{
#   define NAME_OF_CURRENT_INSN opt_newarray_min
#   define INSN_ATTR(x) attr_ ## x ## _opt_newarray_min(num)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;
    MAYBE_UNUSED(rb_num_t) num;

    START_OF_ORIGINAL_INSN(opt_newarray_min);
    num = (rb_num_t)GET_OPERAND(1);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, num);
#line 817 "insns.def"
{
    val = vm_opt_newarray_min(num, STACK_ADDR_FROM_TOP(num));
}
#line 1899 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_newarray_min);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn invokesuper(ci, cc, blockiseq)(...)(val) */
INSN_ENTRY(invokesuper)
{
#   define NAME_OF_CURRENT_INSN invokesuper
#   define INSN_ATTR(x) attr_ ## x ## _invokesuper(ci, cc, blockiseq)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(ISEQ) blockiseq;
    MAYBE_UNUSED(VALUE) val;

    START_OF_ORIGINAL_INSN(invokesuper);
    ci = (CALL_INFO)GET_OPERAND(1);
    cc = (CALL_CACHE)GET_OPERAND(2);
    blockiseq = (ISEQ)GET_OPERAND(3);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 2, blockiseq);
#line 828 "insns.def"
{
    struct rb_calling_info calling;

    calling.block_handler = vm_caller_setup_arg_block(ec, reg_cfp, ci, blockiseq, TRUE);
    calling.recv = TOPN(calling.argc = ci->orig_argc);
    vm_search_super_method(ec, GET_CFP(), &calling, ci, cc);
    CALL_METHOD(&calling, ci, cc);
}
#line 1943 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    PUSH(val);
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(invokesuper);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn invokeblock(ci)(...)(val) */
INSN_ENTRY(invokeblock)
{
#   define NAME_OF_CURRENT_INSN invokeblock
#   define INSN_ATTR(x) attr_ ## x ## _invokeblock(ci)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) val;

    START_OF_ORIGINAL_INSN(invokeblock);
    ci = (CALL_INFO)GET_OPERAND(1);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
#line 845 "insns.def"
{
    struct rb_calling_info calling;
    VALUE block_handler;

    calling.argc = ci->orig_argc;
    calling.block_handler = VM_BLOCK_HANDLER_NONE;
    calling.recv = Qundef; /* should not be used */

    block_handler = VM_CF_BLOCK_HANDLER(GET_CFP());
    if (block_handler == VM_BLOCK_HANDLER_NONE) {
	rb_vm_localjump_error("no block given (yield)", Qnil, 0);
    }

    val = vm_invoke_block(ec, GET_CFP(), &calling, ci, block_handler);
    if (val == Qundef) {
        EXEC_EC_CFP(val);
    }
}
#line 1990 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    PUSH(val);
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(invokeblock);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn leave()(val)(val) */
INSN_ENTRY(leave)
{
#   define NAME_OF_CURRENT_INSN leave
#   define INSN_ATTR(x) attr_ ## x ## _leave()
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;

    START_OF_ORIGINAL_INSN(leave);
    val = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
#line 875 "insns.def"
{
    if (OPT_CHECKED_RUN) {
	const VALUE *const bp = vm_base_ptr(reg_cfp);
	if (reg_cfp->sp != bp) {
	    vm_stack_consistency_error(ec, reg_cfp, bp);
	}
    }

    RUBY_VM_CHECK_INTS(ec);

    if (vm_pop_frame(ec, GET_CFP(), GET_EP())) {
#if OPT_CALL_THREADED_CODE
	rb_ec_thread_ptr(ec)->retval = val;
	return 0;
#else
	return val;
#endif
    }
    else {
	RESTORE_REGS();
    }
}
#line 2039 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    PUSH(val);
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(leave);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn throw(throw_state)(throwobj)(val) */
INSN_ENTRY(throw)
{
#   define NAME_OF_CURRENT_INSN throw
#   define INSN_ATTR(x) attr_ ## x ## _throw(throw_state)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) throwobj, val;
    MAYBE_UNUSED(rb_num_t) throw_state;

    START_OF_ORIGINAL_INSN(throw);
    throw_state = (rb_num_t)GET_OPERAND(1);
    throwobj = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, throw_state);
#line 910 "insns.def"
{
    RUBY_VM_CHECK_INTS(ec);
    val = vm_throw(ec, GET_CFP(), throw_state, throwobj);
    THROW_EXCEPTION(val);
    /* unreachable */
}
#line 2074 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(throw);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn jump(dst)()() */
INSN_ENTRY(jump)
{
#   define NAME_OF_CURRENT_INSN jump
#   define INSN_ATTR(x) attr_ ## x ## _jump(dst)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(OFFSET) dst;

    START_OF_ORIGINAL_INSN(jump);
    dst = (OFFSET)GET_OPERAND(1);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, dst);
#line 929 "insns.def"
{
    RUBY_VM_CHECK_INTS(ec);
    JUMP(dst);
}
#line 2106 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(jump);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn branchif(dst)(val)() */
INSN_ENTRY(branchif)
{
#   define NAME_OF_CURRENT_INSN branchif
#   define INSN_ATTR(x) attr_ ## x ## _branchif(dst)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(OFFSET) dst;
    MAYBE_UNUSED(VALUE) val;

    START_OF_ORIGINAL_INSN(branchif);
    dst = (OFFSET)GET_OPERAND(1);
    val = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, dst);
#line 942 "insns.def"
{
    if (RTEST(val)) {
	RUBY_VM_CHECK_INTS(ec);
	JUMP(dst);
    }
}
#line 2141 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(branchif);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn branchunless(dst)(val)() */
INSN_ENTRY(branchunless)
{
#   define NAME_OF_CURRENT_INSN branchunless
#   define INSN_ATTR(x) attr_ ## x ## _branchunless(dst)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(OFFSET) dst;
    MAYBE_UNUSED(VALUE) val;

    START_OF_ORIGINAL_INSN(branchunless);
    dst = (OFFSET)GET_OPERAND(1);
    val = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, dst);
#line 957 "insns.def"
{
    if (!RTEST(val)) {
	RUBY_VM_CHECK_INTS(ec);
	JUMP(dst);
    }
}
#line 2176 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(branchunless);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn branchnil(dst)(val)() */
INSN_ENTRY(branchnil)
{
#   define NAME_OF_CURRENT_INSN branchnil
#   define INSN_ATTR(x) attr_ ## x ## _branchnil(dst)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(OFFSET) dst;
    MAYBE_UNUSED(VALUE) val;

    START_OF_ORIGINAL_INSN(branchnil);
    dst = (OFFSET)GET_OPERAND(1);
    val = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, dst);
#line 972 "insns.def"
{
    if (NIL_P(val)) {
	RUBY_VM_CHECK_INTS(ec);
	JUMP(dst);
    }
}
#line 2211 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(branchnil);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_getinlinecache(dst, ic)()(val) */
INSN_ENTRY(opt_getinlinecache)
{
#   define NAME_OF_CURRENT_INSN opt_getinlinecache
#   define INSN_ATTR(x) attr_ ## x ## _opt_getinlinecache(dst, ic)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(IC) ic;
    MAYBE_UNUSED(OFFSET) dst;
    MAYBE_UNUSED(VALUE) val;

    START_OF_ORIGINAL_INSN(opt_getinlinecache);
    dst = (OFFSET)GET_OPERAND(1);
    ic = (IC)GET_OPERAND(2);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, dst);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, ic);
#line 989 "insns.def"
{
    if (vm_ic_hit_p(ic, GET_EP())) {
	val = ic->ic_value.value;
	JUMP(dst);
    }
    else {
	val = Qnil;
    }
}
#line 2251 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_getinlinecache);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_setinlinecache(ic)(val)(val) */
INSN_ENTRY(opt_setinlinecache)
{
#   define NAME_OF_CURRENT_INSN opt_setinlinecache
#   define INSN_ATTR(x) attr_ ## x ## _opt_setinlinecache(ic)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(IC) ic;
    MAYBE_UNUSED(VALUE) val;

    START_OF_ORIGINAL_INSN(opt_setinlinecache);
    ic = (IC)GET_OPERAND(1);
    val = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ic);
#line 1005 "insns.def"
{
    vm_ic_update(ic, val, GET_EP());
}
#line 2284 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_setinlinecache);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn once(iseq, ise)()(val) */
INSN_ENTRY(once)
{
#   define NAME_OF_CURRENT_INSN once
#   define INSN_ATTR(x) attr_ ## x ## _once(iseq, ise)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(ISE) ise;
    MAYBE_UNUSED(ISEQ) iseq;
    MAYBE_UNUSED(VALUE) val;

    START_OF_ORIGINAL_INSN(once);
    iseq = (ISEQ)GET_OPERAND(1);
    ise = (ISE)GET_OPERAND(2);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, iseq);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, ise);
#line 1015 "insns.def"
{
    val = vm_once_dispatch(ec, iseq, ise);
}
#line 2320 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    PUSH(val);
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(once);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_case_dispatch(hash, else_offset)(..., key)() */
INSN_ENTRY(opt_case_dispatch)
{
#   define NAME_OF_CURRENT_INSN opt_case_dispatch
#   define INSN_ATTR(x) attr_ ## x ## _opt_case_dispatch(hash, else_offset)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CDHASH) hash;
    MAYBE_UNUSED(OFFSET) else_offset;
    MAYBE_UNUSED(VALUE) key;

    START_OF_ORIGINAL_INSN(opt_case_dispatch);
    hash = (CDHASH)GET_OPERAND(1);
    else_offset = (OFFSET)GET_OPERAND(2);
    key = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, hash);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, else_offset);
#line 1026 "insns.def"
{
    OFFSET dst = vm_case_dispatch(hash, else_offset, key);

    if (dst) {
	JUMP(dst);
    }
}
#line 2359 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_case_dispatch);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_plus(ci, cc)(recv, obj)(val) */
INSN_ENTRY(opt_plus)
{
#   define NAME_OF_CURRENT_INSN opt_plus
#   define INSN_ATTR(x) attr_ ## x ## _opt_plus(ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) obj, recv, val;

    START_OF_ORIGINAL_INSN(opt_plus);
    ci = (CALL_INFO)GET_OPERAND(1);
    cc = (CALL_CACHE)GET_OPERAND(2);
    recv = TOPN(1);
    obj = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc);
#line 1045 "insns.def"
{
    val = vm_opt_plus(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#line 2399 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_plus);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_minus(ci, cc)(recv, obj)(val) */
INSN_ENTRY(opt_minus)
{
#   define NAME_OF_CURRENT_INSN opt_minus
#   define INSN_ATTR(x) attr_ ## x ## _opt_minus(ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) obj, recv, val;

    START_OF_ORIGINAL_INSN(opt_minus);
    ci = (CALL_INFO)GET_OPERAND(1);
    cc = (CALL_CACHE)GET_OPERAND(2);
    recv = TOPN(1);
    obj = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc);
#line 1059 "insns.def"
{
    val = vm_opt_minus(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#line 2440 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_minus);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_mult(ci, cc)(recv, obj)(val) */
INSN_ENTRY(opt_mult)
{
#   define NAME_OF_CURRENT_INSN opt_mult
#   define INSN_ATTR(x) attr_ ## x ## _opt_mult(ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) obj, recv, val;

    START_OF_ORIGINAL_INSN(opt_mult);
    ci = (CALL_INFO)GET_OPERAND(1);
    cc = (CALL_CACHE)GET_OPERAND(2);
    recv = TOPN(1);
    obj = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc);
#line 1073 "insns.def"
{
    val = vm_opt_mult(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#line 2481 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_mult);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_div(ci, cc)(recv, obj)(val) */
INSN_ENTRY(opt_div)
{
#   define NAME_OF_CURRENT_INSN opt_div
#   define INSN_ATTR(x) attr_ ## x ## _opt_div(ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) obj, recv, val;

    START_OF_ORIGINAL_INSN(opt_div);
    ci = (CALL_INFO)GET_OPERAND(1);
    cc = (CALL_CACHE)GET_OPERAND(2);
    recv = TOPN(1);
    obj = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc);
#line 1087 "insns.def"
{
    val = vm_opt_div(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#line 2522 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_div);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_mod(ci, cc)(recv, obj)(val) */
INSN_ENTRY(opt_mod)
{
#   define NAME_OF_CURRENT_INSN opt_mod
#   define INSN_ATTR(x) attr_ ## x ## _opt_mod(ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) obj, recv, val;

    START_OF_ORIGINAL_INSN(opt_mod);
    ci = (CALL_INFO)GET_OPERAND(1);
    cc = (CALL_CACHE)GET_OPERAND(2);
    recv = TOPN(1);
    obj = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc);
#line 1101 "insns.def"
{
    val = vm_opt_mod(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#line 2563 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_mod);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_eq(ci, cc)(recv, obj)(val) */
INSN_ENTRY(opt_eq)
{
#   define NAME_OF_CURRENT_INSN opt_eq
#   define INSN_ATTR(x) attr_ ## x ## _opt_eq(ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) obj, recv, val;

    START_OF_ORIGINAL_INSN(opt_eq);
    ci = (CALL_INFO)GET_OPERAND(1);
    cc = (CALL_CACHE)GET_OPERAND(2);
    recv = TOPN(1);
    obj = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc);
#line 1119 "insns.def"
{
    val = opt_eq_func(recv, obj, ci, cc);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#line 2604 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_eq);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_neq(ci_eq, cc_eq, ci, cc)(recv, obj)(val) */
INSN_ENTRY(opt_neq)
{
#   define NAME_OF_CURRENT_INSN opt_neq
#   define INSN_ATTR(x) attr_ ## x ## _opt_neq(ci_eq, cc_eq, ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc, cc_eq;
    MAYBE_UNUSED(CALL_INFO) ci, ci_eq;
    MAYBE_UNUSED(VALUE) obj, recv, val;

    START_OF_ORIGINAL_INSN(opt_neq);
    ci_eq = (CALL_INFO)GET_OPERAND(1);
    cc_eq = (CALL_CACHE)GET_OPERAND(2);
    ci = (CALL_INFO)GET_OPERAND(3);
    cc = (CALL_CACHE)GET_OPERAND(4);
    recv = TOPN(1);
    obj = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci_eq);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc_eq);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 2, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 3, cc);
#line 1135 "insns.def"
{
    val = vm_opt_neq(ci, cc, ci_eq, cc_eq, recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#line 2649 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_neq);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_lt(ci, cc)(recv, obj)(val) */
INSN_ENTRY(opt_lt)
{
#   define NAME_OF_CURRENT_INSN opt_lt
#   define INSN_ATTR(x) attr_ ## x ## _opt_lt(ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) obj, recv, val;

    START_OF_ORIGINAL_INSN(opt_lt);
    ci = (CALL_INFO)GET_OPERAND(1);
    cc = (CALL_CACHE)GET_OPERAND(2);
    recv = TOPN(1);
    obj = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc);
#line 1149 "insns.def"
{
    val = vm_opt_lt(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#line 2690 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_lt);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_le(ci, cc)(recv, obj)(val) */
INSN_ENTRY(opt_le)
{
#   define NAME_OF_CURRENT_INSN opt_le
#   define INSN_ATTR(x) attr_ ## x ## _opt_le(ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) obj, recv, val;

    START_OF_ORIGINAL_INSN(opt_le);
    ci = (CALL_INFO)GET_OPERAND(1);
    cc = (CALL_CACHE)GET_OPERAND(2);
    recv = TOPN(1);
    obj = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc);
#line 1163 "insns.def"
{
    val = vm_opt_le(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#line 2731 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_le);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_gt(ci, cc)(recv, obj)(val) */
INSN_ENTRY(opt_gt)
{
#   define NAME_OF_CURRENT_INSN opt_gt
#   define INSN_ATTR(x) attr_ ## x ## _opt_gt(ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) obj, recv, val;

    START_OF_ORIGINAL_INSN(opt_gt);
    ci = (CALL_INFO)GET_OPERAND(1);
    cc = (CALL_CACHE)GET_OPERAND(2);
    recv = TOPN(1);
    obj = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc);
#line 1177 "insns.def"
{
    val = vm_opt_gt(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#line 2772 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_gt);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_ge(ci, cc)(recv, obj)(val) */
INSN_ENTRY(opt_ge)
{
#   define NAME_OF_CURRENT_INSN opt_ge
#   define INSN_ATTR(x) attr_ ## x ## _opt_ge(ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) obj, recv, val;

    START_OF_ORIGINAL_INSN(opt_ge);
    ci = (CALL_INFO)GET_OPERAND(1);
    cc = (CALL_CACHE)GET_OPERAND(2);
    recv = TOPN(1);
    obj = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc);
#line 1191 "insns.def"
{
    val = vm_opt_ge(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#line 2813 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_ge);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_ltlt(ci, cc)(recv, obj)(val) */
INSN_ENTRY(opt_ltlt)
{
#   define NAME_OF_CURRENT_INSN opt_ltlt
#   define INSN_ATTR(x) attr_ ## x ## _opt_ltlt(ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) obj, recv, val;

    START_OF_ORIGINAL_INSN(opt_ltlt);
    ci = (CALL_INFO)GET_OPERAND(1);
    cc = (CALL_CACHE)GET_OPERAND(2);
    recv = TOPN(1);
    obj = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc);
#line 1205 "insns.def"
{
    val = vm_opt_ltlt(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#line 2854 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_ltlt);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_and(ci, cc)(recv, obj)(val) */
INSN_ENTRY(opt_and)
{
#   define NAME_OF_CURRENT_INSN opt_and
#   define INSN_ATTR(x) attr_ ## x ## _opt_and(ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) obj, recv, val;

    START_OF_ORIGINAL_INSN(opt_and);
    ci = (CALL_INFO)GET_OPERAND(1);
    cc = (CALL_CACHE)GET_OPERAND(2);
    recv = TOPN(1);
    obj = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc);
#line 1219 "insns.def"
{
    val = vm_opt_and(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#line 2895 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_and);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_or(ci, cc)(recv, obj)(val) */
INSN_ENTRY(opt_or)
{
#   define NAME_OF_CURRENT_INSN opt_or
#   define INSN_ATTR(x) attr_ ## x ## _opt_or(ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) obj, recv, val;

    START_OF_ORIGINAL_INSN(opt_or);
    ci = (CALL_INFO)GET_OPERAND(1);
    cc = (CALL_CACHE)GET_OPERAND(2);
    recv = TOPN(1);
    obj = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc);
#line 1233 "insns.def"
{
    val = vm_opt_or(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#line 2936 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_or);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_aref(ci, cc)(recv, obj)(val) */
INSN_ENTRY(opt_aref)
{
#   define NAME_OF_CURRENT_INSN opt_aref
#   define INSN_ATTR(x) attr_ ## x ## _opt_aref(ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) obj, recv, val;

    START_OF_ORIGINAL_INSN(opt_aref);
    ci = (CALL_INFO)GET_OPERAND(1);
    cc = (CALL_CACHE)GET_OPERAND(2);
    recv = TOPN(1);
    obj = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc);
#line 1252 "insns.def"
{
    val = vm_opt_aref(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#line 2977 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_aref);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_aset(ci, cc)(recv, obj, set)(val) */
INSN_ENTRY(opt_aset)
{
#   define NAME_OF_CURRENT_INSN opt_aset
#   define INSN_ATTR(x) attr_ ## x ## _opt_aset(ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) obj, recv, set, val;

    START_OF_ORIGINAL_INSN(opt_aset);
    ci = (CALL_INFO)GET_OPERAND(1);
    cc = (CALL_CACHE)GET_OPERAND(2);
    recv = TOPN(2);
    obj = TOPN(1);
    set = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc);
#line 1269 "insns.def"
{
    val = vm_opt_aset(recv, obj, set);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#line 3019 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_aset);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_aset_with(key, ci, cc)(recv, val)(val) */
INSN_ENTRY(opt_aset_with)
{
#   define NAME_OF_CURRENT_INSN opt_aset_with
#   define INSN_ATTR(x) attr_ ## x ## _opt_aset_with(key, ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) key, recv, val;

    START_OF_ORIGINAL_INSN(opt_aset_with);
    key = (VALUE)GET_OPERAND(1);
    ci = (CALL_INFO)GET_OPERAND(2);
    cc = (CALL_CACHE)GET_OPERAND(3);
    recv = TOPN(1);
    val = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, key);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 2, cc);
#line 1285 "insns.def"
{
    VALUE tmp = vm_opt_aset_with(recv, key, val);

    if (tmp != Qundef) {
	val = tmp;
    }
    else {
#ifndef MJIT_HEADER
	TOPN(0) = rb_str_resurrect(key);
	PUSH(val);
#endif
        CALL_SIMPLE_METHOD();
    }
}
#line 3069 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_aset_with);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_aref_with(key, ci, cc)(recv)(val) */
INSN_ENTRY(opt_aref_with)
{
#   define NAME_OF_CURRENT_INSN opt_aref_with
#   define INSN_ATTR(x) attr_ ## x ## _opt_aref_with(key, ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) key, recv, val;

    START_OF_ORIGINAL_INSN(opt_aref_with);
    key = (VALUE)GET_OPERAND(1);
    ci = (CALL_INFO)GET_OPERAND(2);
    cc = (CALL_CACHE)GET_OPERAND(3);
    recv = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, key);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 2, cc);
#line 1308 "insns.def"
{
    val = vm_opt_aref_with(recv, key);

    if (val == Qundef) {
#ifndef MJIT_HEADER
	PUSH(rb_str_resurrect(key));
#endif
        CALL_SIMPLE_METHOD();
    }
}
#line 3114 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_aref_with);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_length(ci, cc)(recv)(val) */
INSN_ENTRY(opt_length)
{
#   define NAME_OF_CURRENT_INSN opt_length
#   define INSN_ATTR(x) attr_ ## x ## _opt_length(ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) recv, val;

    START_OF_ORIGINAL_INSN(opt_length);
    ci = (CALL_INFO)GET_OPERAND(1);
    cc = (CALL_CACHE)GET_OPERAND(2);
    recv = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc);
#line 1325 "insns.def"
{
    val = vm_opt_length(recv, BOP_LENGTH);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#line 3154 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_length);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_size(ci, cc)(recv)(val) */
INSN_ENTRY(opt_size)
{
#   define NAME_OF_CURRENT_INSN opt_size
#   define INSN_ATTR(x) attr_ ## x ## _opt_size(ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) recv, val;

    START_OF_ORIGINAL_INSN(opt_size);
    ci = (CALL_INFO)GET_OPERAND(1);
    cc = (CALL_CACHE)GET_OPERAND(2);
    recv = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc);
#line 1339 "insns.def"
{
    val = vm_opt_length(recv, BOP_SIZE);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#line 3194 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_size);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_empty_p(ci, cc)(recv)(val) */
INSN_ENTRY(opt_empty_p)
{
#   define NAME_OF_CURRENT_INSN opt_empty_p
#   define INSN_ATTR(x) attr_ ## x ## _opt_empty_p(ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) recv, val;

    START_OF_ORIGINAL_INSN(opt_empty_p);
    ci = (CALL_INFO)GET_OPERAND(1);
    cc = (CALL_CACHE)GET_OPERAND(2);
    recv = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc);
#line 1353 "insns.def"
{
    val = vm_opt_empty_p(recv);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#line 3234 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_empty_p);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_succ(ci, cc)(recv)(val) */
INSN_ENTRY(opt_succ)
{
#   define NAME_OF_CURRENT_INSN opt_succ
#   define INSN_ATTR(x) attr_ ## x ## _opt_succ(ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) recv, val;

    START_OF_ORIGINAL_INSN(opt_succ);
    ci = (CALL_INFO)GET_OPERAND(1);
    cc = (CALL_CACHE)GET_OPERAND(2);
    recv = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc);
#line 1367 "insns.def"
{
    val = vm_opt_succ(recv);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#line 3274 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_succ);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_not(ci, cc)(recv)(val) */
INSN_ENTRY(opt_not)
{
#   define NAME_OF_CURRENT_INSN opt_not
#   define INSN_ATTR(x) attr_ ## x ## _opt_not(ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) recv, val;

    START_OF_ORIGINAL_INSN(opt_not);
    ci = (CALL_INFO)GET_OPERAND(1);
    cc = (CALL_CACHE)GET_OPERAND(2);
    recv = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc);
#line 1381 "insns.def"
{
    val = vm_opt_not(ci, cc, recv);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#line 3314 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_not);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_regexpmatch1(recv)(obj)(val) */
INSN_ENTRY(opt_regexpmatch1)
{
#   define NAME_OF_CURRENT_INSN opt_regexpmatch1
#   define INSN_ATTR(x) attr_ ## x ## _opt_regexpmatch1(recv)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) obj, recv, val;

    START_OF_ORIGINAL_INSN(opt_regexpmatch1);
    recv = (VALUE)GET_OPERAND(1);
    obj = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, recv);
#line 1396 "insns.def"
{
    val = vm_opt_regexpmatch1(recv, obj);
}
#line 3346 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_regexpmatch1);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_regexpmatch2(ci, cc)(obj2, obj1)(val) */
INSN_ENTRY(opt_regexpmatch2)
{
#   define NAME_OF_CURRENT_INSN opt_regexpmatch2
#   define INSN_ATTR(x) attr_ ## x ## _opt_regexpmatch2(ci, cc)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(CALL_CACHE) cc;
    MAYBE_UNUSED(CALL_INFO) ci;
    MAYBE_UNUSED(VALUE) obj1, obj2, val;

    START_OF_ORIGINAL_INSN(opt_regexpmatch2);
    ci = (CALL_INFO)GET_OPERAND(1);
    cc = (CALL_CACHE)GET_OPERAND(2);
    obj2 = TOPN(1);
    obj1 = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ci);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cc);
#line 1406 "insns.def"
{
    val = vm_opt_regexpmatch2(obj2, obj1);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#line 3387 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_regexpmatch2);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn opt_call_c_function(funcptr)()() */
INSN_ENTRY(opt_call_c_function)
{
#   define NAME_OF_CURRENT_INSN opt_call_c_function
#   define INSN_ATTR(x) attr_ ## x ## _opt_call_c_function(funcptr)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(rb_insn_func_t) funcptr;

    START_OF_ORIGINAL_INSN(opt_call_c_function);
    funcptr = (rb_insn_func_t)GET_OPERAND(1);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, funcptr);
#line 1422 "insns.def"
{
    reg_cfp = (funcptr)(ec, reg_cfp);

    if (reg_cfp == 0) {
	VALUE err = ec->errinfo;
	ec->errinfo = Qnil;
	THROW_EXCEPTION(err);
    }

    RESTORE_REGS();
    NEXT_INSN();
}
#line 3428 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(opt_call_c_function);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn bitblt()()(ret) */
INSN_ENTRY(bitblt)
{
#   define NAME_OF_CURRENT_INSN bitblt
#   define INSN_ATTR(x) attr_ ## x ## _bitblt()
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) ret;

    START_OF_ORIGINAL_INSN(bitblt);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
#line 1441 "insns.def"
{
    ret = rb_str_new2("a bit of bacon, lettuce and tomato");
}
#line 3455 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = ret;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(bitblt);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn answer()()(ret) */
INSN_ENTRY(answer)
{
#   define NAME_OF_CURRENT_INSN answer
#   define INSN_ATTR(x) attr_ ## x ## _answer()
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) ret;

    START_OF_ORIGINAL_INSN(answer);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
#line 1451 "insns.def"
{
    ret = INT2FIX(42);
}
#line 3484 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = ret;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(answer);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn getlocal_WC_0(idx)()(val) */
INSN_ENTRY(getlocal_WC_0)
{
#   define NAME_OF_CURRENT_INSN getlocal_WC_0
#   define INSN_ATTR(x) attr_ ## x ## _getlocal_WC_0(idx)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;
    MAYBE_UNUSED(lindex_t) idx;
    MAYBE_UNUSED(rb_num_t) level;

    START_OF_ORIGINAL_INSN(getlocal_WC_0);
#line 10 "defs/opt_operand.def"
    level = 0;
#line 3509 "vm.inc"
    idx = (lindex_t)GET_OPERAND(1);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);
#line 81 "insns.def"
{
    val = *(vm_get_ep(GET_EP(), level) - idx);
    RB_DEBUG_COUNTER_INC(lvar_get);
    (void)RB_DEBUG_COUNTER_INC_IF(lvar_get_dynamic, level > 0);
}
#line 3522 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(getlocal_WC_0);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn getlocal_WC_1(idx)()(val) */
INSN_ENTRY(getlocal_WC_1)
{
#   define NAME_OF_CURRENT_INSN getlocal_WC_1
#   define INSN_ATTR(x) attr_ ## x ## _getlocal_WC_1(idx)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;
    MAYBE_UNUSED(lindex_t) idx;
    MAYBE_UNUSED(rb_num_t) level;

    START_OF_ORIGINAL_INSN(getlocal_WC_1);
#line 11 "defs/opt_operand.def"
    level = 1;
#line 3547 "vm.inc"
    idx = (lindex_t)GET_OPERAND(1);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);
#line 81 "insns.def"
{
    val = *(vm_get_ep(GET_EP(), level) - idx);
    RB_DEBUG_COUNTER_INC(lvar_get);
    (void)RB_DEBUG_COUNTER_INC_IF(lvar_get_dynamic, level > 0);
}
#line 3560 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(getlocal_WC_1);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn setlocal_WC_0(idx)(val)() */
INSN_ENTRY(setlocal_WC_0)
{
#   define NAME_OF_CURRENT_INSN setlocal_WC_0
#   define INSN_ATTR(x) attr_ ## x ## _setlocal_WC_0(idx)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;
    MAYBE_UNUSED(lindex_t) idx;
    MAYBE_UNUSED(rb_num_t) level;

    START_OF_ORIGINAL_INSN(setlocal_WC_0);
#line 12 "defs/opt_operand.def"
    level = 0;
#line 3585 "vm.inc"
    idx = (lindex_t)GET_OPERAND(1);
    val = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);
#line 95 "insns.def"
{
    vm_env_write(vm_get_ep(GET_EP(), level), -(int)idx, val);
    RB_DEBUG_COUNTER_INC(lvar_set);
    (void)RB_DEBUG_COUNTER_INC_IF(lvar_set_dynamic, level > 0);
}
#line 3599 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(setlocal_WC_0);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn setlocal_WC_1(idx)(val)() */
INSN_ENTRY(setlocal_WC_1)
{
#   define NAME_OF_CURRENT_INSN setlocal_WC_1
#   define INSN_ATTR(x) attr_ ## x ## _setlocal_WC_1(idx)
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;
    MAYBE_UNUSED(lindex_t) idx;
    MAYBE_UNUSED(rb_num_t) level;

    START_OF_ORIGINAL_INSN(setlocal_WC_1);
#line 13 "defs/opt_operand.def"
    level = 1;
#line 3623 "vm.inc"
    idx = (lindex_t)GET_OPERAND(1);
    val = TOPN(0);
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY();
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);
#line 95 "insns.def"
{
    vm_env_write(vm_get_ep(GET_EP(), level), -(int)idx, val);
    RB_DEBUG_COUNTER_INC(lvar_set);
    (void)RB_DEBUG_COUNTER_INC_IF(lvar_set_dynamic, level > 0);
}
#line 3637 "vm.inc"
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY();
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(setlocal_WC_1);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn putobject_INT2FIX_0_()()(val) */
INSN_ENTRY(putobject_INT2FIX_0_)
{
#   define NAME_OF_CURRENT_INSN putobject_INT2FIX_0_
#   define INSN_ATTR(x) attr_ ## x ## _putobject_INT2FIX_0_()
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;

    START_OF_ORIGINAL_INSN(putobject_INT2FIX_0_);
#line 15 "defs/opt_operand.def"
    val = INT2FIX(0);
#line 3659 "vm.inc"
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(putobject_INT2FIX_0_);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn putobject_INT2FIX_1_()()(val) */
INSN_ENTRY(putobject_INT2FIX_1_)
{
#   define NAME_OF_CURRENT_INSN putobject_INT2FIX_1_
#   define INSN_ATTR(x) attr_ ## x ## _putobject_INT2FIX_1_()
    bool leaf;
    MAYBE_UNUSED(VALUE *) canary;
    MAYBE_UNUSED(VALUE) val;

    START_OF_ORIGINAL_INSN(putobject_INT2FIX_1_);
#line 16 "defs/opt_operand.def"
    val = INT2FIX(1);
#line 3684 "vm.inc"
    DEBUG_ENTER_INSN(INSN_ATTR(name));
    if (! (leaf = INSN_ATTR(leaf))) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    if (leaf) ADD_PC(INSN_ATTR(width));
    END_INSN(putobject_INT2FIX_1_);
#   undef INSN_ATTR
#   undef NAME_OF_CURRENT_INSN
}

/* insn trace_nop(...)(...)(...) */
INSN_ENTRY(trace_nop)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(nop);
    END_INSN(trace_nop);
}

/* insn trace_getlocal(...)(...)(...) */
INSN_ENTRY(trace_getlocal)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(getlocal);
    END_INSN(trace_getlocal);
}

/* insn trace_setlocal(...)(...)(...) */
INSN_ENTRY(trace_setlocal)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(setlocal);
    END_INSN(trace_setlocal);
}

/* insn trace_getblockparam(...)(...)(...) */
INSN_ENTRY(trace_getblockparam)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(getblockparam);
    END_INSN(trace_getblockparam);
}

/* insn trace_setblockparam(...)(...)(...) */
INSN_ENTRY(trace_setblockparam)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(setblockparam);
    END_INSN(trace_setblockparam);
}

/* insn trace_getblockparamproxy(...)(...)(...) */
INSN_ENTRY(trace_getblockparamproxy)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(getblockparamproxy);
    END_INSN(trace_getblockparamproxy);
}

/* insn trace_getspecial(...)(...)(...) */
INSN_ENTRY(trace_getspecial)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(getspecial);
    END_INSN(trace_getspecial);
}

/* insn trace_setspecial(...)(...)(...) */
INSN_ENTRY(trace_setspecial)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(setspecial);
    END_INSN(trace_setspecial);
}

/* insn trace_getinstancevariable(...)(...)(...) */
INSN_ENTRY(trace_getinstancevariable)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(getinstancevariable);
    END_INSN(trace_getinstancevariable);
}

/* insn trace_setinstancevariable(...)(...)(...) */
INSN_ENTRY(trace_setinstancevariable)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(setinstancevariable);
    END_INSN(trace_setinstancevariable);
}

/* insn trace_getclassvariable(...)(...)(...) */
INSN_ENTRY(trace_getclassvariable)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(getclassvariable);
    END_INSN(trace_getclassvariable);
}

/* insn trace_setclassvariable(...)(...)(...) */
INSN_ENTRY(trace_setclassvariable)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(setclassvariable);
    END_INSN(trace_setclassvariable);
}

/* insn trace_getconstant(...)(...)(...) */
INSN_ENTRY(trace_getconstant)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(getconstant);
    END_INSN(trace_getconstant);
}

/* insn trace_setconstant(...)(...)(...) */
INSN_ENTRY(trace_setconstant)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(setconstant);
    END_INSN(trace_setconstant);
}

/* insn trace_getglobal(...)(...)(...) */
INSN_ENTRY(trace_getglobal)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(getglobal);
    END_INSN(trace_getglobal);
}

/* insn trace_setglobal(...)(...)(...) */
INSN_ENTRY(trace_setglobal)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(setglobal);
    END_INSN(trace_setglobal);
}

/* insn trace_putnil(...)(...)(...) */
INSN_ENTRY(trace_putnil)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(putnil);
    END_INSN(trace_putnil);
}

/* insn trace_putself(...)(...)(...) */
INSN_ENTRY(trace_putself)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(putself);
    END_INSN(trace_putself);
}

/* insn trace_putobject(...)(...)(...) */
INSN_ENTRY(trace_putobject)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(putobject);
    END_INSN(trace_putobject);
}

/* insn trace_putspecialobject(...)(...)(...) */
INSN_ENTRY(trace_putspecialobject)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(putspecialobject);
    END_INSN(trace_putspecialobject);
}

/* insn trace_putiseq(...)(...)(...) */
INSN_ENTRY(trace_putiseq)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(putiseq);
    END_INSN(trace_putiseq);
}

/* insn trace_putstring(...)(...)(...) */
INSN_ENTRY(trace_putstring)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(putstring);
    END_INSN(trace_putstring);
}

/* insn trace_concatstrings(...)(...)(...) */
INSN_ENTRY(trace_concatstrings)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(concatstrings);
    END_INSN(trace_concatstrings);
}

/* insn trace_tostring(...)(...)(...) */
INSN_ENTRY(trace_tostring)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(tostring);
    END_INSN(trace_tostring);
}

/* insn trace_freezestring(...)(...)(...) */
INSN_ENTRY(trace_freezestring)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(freezestring);
    END_INSN(trace_freezestring);
}

/* insn trace_toregexp(...)(...)(...) */
INSN_ENTRY(trace_toregexp)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(toregexp);
    END_INSN(trace_toregexp);
}

/* insn trace_intern(...)(...)(...) */
INSN_ENTRY(trace_intern)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(intern);
    END_INSN(trace_intern);
}

/* insn trace_newarray(...)(...)(...) */
INSN_ENTRY(trace_newarray)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(newarray);
    END_INSN(trace_newarray);
}

/* insn trace_duparray(...)(...)(...) */
INSN_ENTRY(trace_duparray)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(duparray);
    END_INSN(trace_duparray);
}

/* insn trace_duphash(...)(...)(...) */
INSN_ENTRY(trace_duphash)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(duphash);
    END_INSN(trace_duphash);
}

/* insn trace_expandarray(...)(...)(...) */
INSN_ENTRY(trace_expandarray)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(expandarray);
    END_INSN(trace_expandarray);
}

/* insn trace_concatarray(...)(...)(...) */
INSN_ENTRY(trace_concatarray)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(concatarray);
    END_INSN(trace_concatarray);
}

/* insn trace_splatarray(...)(...)(...) */
INSN_ENTRY(trace_splatarray)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(splatarray);
    END_INSN(trace_splatarray);
}

/* insn trace_newhash(...)(...)(...) */
INSN_ENTRY(trace_newhash)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(newhash);
    END_INSN(trace_newhash);
}

/* insn trace_newrange(...)(...)(...) */
INSN_ENTRY(trace_newrange)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(newrange);
    END_INSN(trace_newrange);
}

/* insn trace_pop(...)(...)(...) */
INSN_ENTRY(trace_pop)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(pop);
    END_INSN(trace_pop);
}

/* insn trace_dup(...)(...)(...) */
INSN_ENTRY(trace_dup)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(dup);
    END_INSN(trace_dup);
}

/* insn trace_dupn(...)(...)(...) */
INSN_ENTRY(trace_dupn)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(dupn);
    END_INSN(trace_dupn);
}

/* insn trace_swap(...)(...)(...) */
INSN_ENTRY(trace_swap)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(swap);
    END_INSN(trace_swap);
}

/* insn trace_reverse(...)(...)(...) */
INSN_ENTRY(trace_reverse)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(reverse);
    END_INSN(trace_reverse);
}

/* insn trace_reput(...)(...)(...) */
INSN_ENTRY(trace_reput)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(reput);
    END_INSN(trace_reput);
}

/* insn trace_topn(...)(...)(...) */
INSN_ENTRY(trace_topn)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(topn);
    END_INSN(trace_topn);
}

/* insn trace_setn(...)(...)(...) */
INSN_ENTRY(trace_setn)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(setn);
    END_INSN(trace_setn);
}

/* insn trace_adjuststack(...)(...)(...) */
INSN_ENTRY(trace_adjuststack)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(adjuststack);
    END_INSN(trace_adjuststack);
}

/* insn trace_defined(...)(...)(...) */
INSN_ENTRY(trace_defined)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(defined);
    END_INSN(trace_defined);
}

/* insn trace_checkmatch(...)(...)(...) */
INSN_ENTRY(trace_checkmatch)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(checkmatch);
    END_INSN(trace_checkmatch);
}

/* insn trace_checkkeyword(...)(...)(...) */
INSN_ENTRY(trace_checkkeyword)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(checkkeyword);
    END_INSN(trace_checkkeyword);
}

/* insn trace_checktype(...)(...)(...) */
INSN_ENTRY(trace_checktype)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(checktype);
    END_INSN(trace_checktype);
}

/* insn trace_defineclass(...)(...)(...) */
INSN_ENTRY(trace_defineclass)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(defineclass);
    END_INSN(trace_defineclass);
}

/* insn trace_send(...)(...)(...) */
INSN_ENTRY(trace_send)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(send);
    END_INSN(trace_send);
}

/* insn trace_opt_send_without_block(...)(...)(...) */
INSN_ENTRY(trace_opt_send_without_block)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_send_without_block);
}

/* insn trace_opt_str_freeze(...)(...)(...) */
INSN_ENTRY(trace_opt_str_freeze)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_str_freeze);
    END_INSN(trace_opt_str_freeze);
}

/* insn trace_opt_str_uminus(...)(...)(...) */
INSN_ENTRY(trace_opt_str_uminus)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_str_uminus);
    END_INSN(trace_opt_str_uminus);
}

/* insn trace_opt_newarray_max(...)(...)(...) */
INSN_ENTRY(trace_opt_newarray_max)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_newarray_max);
    END_INSN(trace_opt_newarray_max);
}

/* insn trace_opt_newarray_min(...)(...)(...) */
INSN_ENTRY(trace_opt_newarray_min)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_newarray_min);
    END_INSN(trace_opt_newarray_min);
}

/* insn trace_invokesuper(...)(...)(...) */
INSN_ENTRY(trace_invokesuper)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(invokesuper);
    END_INSN(trace_invokesuper);
}

/* insn trace_invokeblock(...)(...)(...) */
INSN_ENTRY(trace_invokeblock)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(invokeblock);
    END_INSN(trace_invokeblock);
}

/* insn trace_leave(...)(...)(...) */
INSN_ENTRY(trace_leave)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(leave);
    END_INSN(trace_leave);
}

/* insn trace_throw(...)(...)(...) */
INSN_ENTRY(trace_throw)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(throw);
    END_INSN(trace_throw);
}

/* insn trace_jump(...)(...)(...) */
INSN_ENTRY(trace_jump)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(jump);
    END_INSN(trace_jump);
}

/* insn trace_branchif(...)(...)(...) */
INSN_ENTRY(trace_branchif)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(branchif);
    END_INSN(trace_branchif);
}

/* insn trace_branchunless(...)(...)(...) */
INSN_ENTRY(trace_branchunless)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(branchunless);
    END_INSN(trace_branchunless);
}

/* insn trace_branchnil(...)(...)(...) */
INSN_ENTRY(trace_branchnil)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(branchnil);
    END_INSN(trace_branchnil);
}

/* insn trace_opt_getinlinecache(...)(...)(...) */
INSN_ENTRY(trace_opt_getinlinecache)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_getinlinecache);
    END_INSN(trace_opt_getinlinecache);
}

/* insn trace_opt_setinlinecache(...)(...)(...) */
INSN_ENTRY(trace_opt_setinlinecache)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_setinlinecache);
    END_INSN(trace_opt_setinlinecache);
}

/* insn trace_once(...)(...)(...) */
INSN_ENTRY(trace_once)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(once);
    END_INSN(trace_once);
}

/* insn trace_opt_case_dispatch(...)(...)(...) */
INSN_ENTRY(trace_opt_case_dispatch)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_case_dispatch);
    END_INSN(trace_opt_case_dispatch);
}

/* insn trace_opt_plus(...)(...)(...) */
INSN_ENTRY(trace_opt_plus)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_plus);
    END_INSN(trace_opt_plus);
}

/* insn trace_opt_minus(...)(...)(...) */
INSN_ENTRY(trace_opt_minus)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_minus);
    END_INSN(trace_opt_minus);
}

/* insn trace_opt_mult(...)(...)(...) */
INSN_ENTRY(trace_opt_mult)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_mult);
    END_INSN(trace_opt_mult);
}

/* insn trace_opt_div(...)(...)(...) */
INSN_ENTRY(trace_opt_div)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_div);
    END_INSN(trace_opt_div);
}

/* insn trace_opt_mod(...)(...)(...) */
INSN_ENTRY(trace_opt_mod)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_mod);
    END_INSN(trace_opt_mod);
}

/* insn trace_opt_eq(...)(...)(...) */
INSN_ENTRY(trace_opt_eq)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_eq);
    END_INSN(trace_opt_eq);
}

/* insn trace_opt_neq(...)(...)(...) */
INSN_ENTRY(trace_opt_neq)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_neq);
    END_INSN(trace_opt_neq);
}

/* insn trace_opt_lt(...)(...)(...) */
INSN_ENTRY(trace_opt_lt)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_lt);
    END_INSN(trace_opt_lt);
}

/* insn trace_opt_le(...)(...)(...) */
INSN_ENTRY(trace_opt_le)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_le);
    END_INSN(trace_opt_le);
}

/* insn trace_opt_gt(...)(...)(...) */
INSN_ENTRY(trace_opt_gt)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_gt);
    END_INSN(trace_opt_gt);
}

/* insn trace_opt_ge(...)(...)(...) */
INSN_ENTRY(trace_opt_ge)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_ge);
    END_INSN(trace_opt_ge);
}

/* insn trace_opt_ltlt(...)(...)(...) */
INSN_ENTRY(trace_opt_ltlt)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_ltlt);
    END_INSN(trace_opt_ltlt);
}

/* insn trace_opt_and(...)(...)(...) */
INSN_ENTRY(trace_opt_and)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_and);
    END_INSN(trace_opt_and);
}

/* insn trace_opt_or(...)(...)(...) */
INSN_ENTRY(trace_opt_or)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_or);
    END_INSN(trace_opt_or);
}

/* insn trace_opt_aref(...)(...)(...) */
INSN_ENTRY(trace_opt_aref)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_aref);
    END_INSN(trace_opt_aref);
}

/* insn trace_opt_aset(...)(...)(...) */
INSN_ENTRY(trace_opt_aset)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_aset);
    END_INSN(trace_opt_aset);
}

/* insn trace_opt_aset_with(...)(...)(...) */
INSN_ENTRY(trace_opt_aset_with)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_aset_with);
    END_INSN(trace_opt_aset_with);
}

/* insn trace_opt_aref_with(...)(...)(...) */
INSN_ENTRY(trace_opt_aref_with)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_aref_with);
    END_INSN(trace_opt_aref_with);
}

/* insn trace_opt_length(...)(...)(...) */
INSN_ENTRY(trace_opt_length)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_length);
    END_INSN(trace_opt_length);
}

/* insn trace_opt_size(...)(...)(...) */
INSN_ENTRY(trace_opt_size)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_size);
    END_INSN(trace_opt_size);
}

/* insn trace_opt_empty_p(...)(...)(...) */
INSN_ENTRY(trace_opt_empty_p)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_empty_p);
    END_INSN(trace_opt_empty_p);
}

/* insn trace_opt_succ(...)(...)(...) */
INSN_ENTRY(trace_opt_succ)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_succ);
    END_INSN(trace_opt_succ);
}

/* insn trace_opt_not(...)(...)(...) */
INSN_ENTRY(trace_opt_not)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_not);
    END_INSN(trace_opt_not);
}

/* insn trace_opt_regexpmatch1(...)(...)(...) */
INSN_ENTRY(trace_opt_regexpmatch1)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_regexpmatch1);
    END_INSN(trace_opt_regexpmatch1);
}

/* insn trace_opt_regexpmatch2(...)(...)(...) */
INSN_ENTRY(trace_opt_regexpmatch2)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_regexpmatch2);
    END_INSN(trace_opt_regexpmatch2);
}

/* insn trace_opt_call_c_function(...)(...)(...) */
INSN_ENTRY(trace_opt_call_c_function)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(opt_call_c_function);
    END_INSN(trace_opt_call_c_function);
}

/* insn trace_bitblt(...)(...)(...) */
INSN_ENTRY(trace_bitblt)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(bitblt);
    END_INSN(trace_bitblt);
}

/* insn trace_answer(...)(...)(...) */
INSN_ENTRY(trace_answer)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(answer);
    END_INSN(trace_answer);
}

/* insn trace_getlocal_WC_0(...)(...)(...) */
INSN_ENTRY(trace_getlocal_WC_0)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(getlocal_WC_0);
    END_INSN(trace_getlocal_WC_0);
}

/* insn trace_getlocal_WC_1(...)(...)(...) */
INSN_ENTRY(trace_getlocal_WC_1)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(getlocal_WC_1);
    END_INSN(trace_getlocal_WC_1);
}

/* insn trace_setlocal_WC_0(...)(...)(...) */
INSN_ENTRY(trace_setlocal_WC_0)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(setlocal_WC_0);
    END_INSN(trace_setlocal_WC_0);
}

/* insn trace_setlocal_WC_1(...)(...)(...) */
INSN_ENTRY(trace_setlocal_WC_1)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(setlocal_WC_1);
    END_INSN(trace_setlocal_WC_1);
}

/* insn trace_putobject_INT2FIX_0_(...)(...)(...) */
INSN_ENTRY(trace_putobject_INT2FIX_0_)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(putobject_INT2FIX_0_);
    END_INSN(trace_putobject_INT2FIX_0_);
}

/* insn trace_putobject_INT2FIX_1_(...)(...)(...) */
INSN_ENTRY(trace_putobject_INT2FIX_1_)
{
    vm_trace(ec, GET_CFP(), GET_PC());
    DISPATCH_ORIGINAL_INSN(putobject_INT2FIX_1_);
    END_INSN(trace_putobject_INT2FIX_1_);
}
