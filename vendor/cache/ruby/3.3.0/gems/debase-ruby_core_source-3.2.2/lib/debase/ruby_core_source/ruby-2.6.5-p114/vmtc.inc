/* -*- mode:c; style:ruby; coding: utf-8; indent-tabs-mode: nil -*- */

/* This is  an auto-generated file  and is a  part of the  programming language
 * Ruby.  The  person who  created  a  program  to  generate this  file  (``I''
 * hereafter) would like  to refrain from defining licensing  of this generated
 * source code.
 *
 * This file consist of many small  parts of codes copyrighted by each authors,
 * not  only  the  ``I''  person.   Those  original  authors  agree  with  some
 * open-source license.  I  believe that the license we agree  is the condition
 * mentioned in  the file COPYING.  It  states "4.  You may  modify and include
 * the part of the software into any  other software ...".  But the problem is,
 * the license never makes it clear if  such modified parts still remain in the
 * same  license, or  not.   The fact  that  we agree  with  the source  code's
 * licensing terms do not automatically define that of generated ones.  This is
 * the reason  why this file  is under unclear situation.   All that I  know is
 * that above provision guarantees this file to exist.
 *
 * Please let me  hesitate to declare something about this  nuanced contract. I
 * am not in the position to take  over other authors' license to merge into my
 * one.  Changing them to (say) GPLv3  is not doable by myself. Perhaps someday
 * it might turn out to be okay to say this file is under a license. I wish the
 * situation would become more clear in the future. */
/*******************************************************************/
/*******************************************************************/
/*******************************************************************/
/**
  This file is for threaded code.

  ----
  This file is auto generated by insns2vm.rb
  DO NOT TOUCH!

  If you want to fix something, you must edit "tool/ruby_vm/views/vmtc.inc.erb"
  or tool/insns2vm.rb
 */

static const void *const insns_address_table[] = {
    LABEL_PTR(nop),
    LABEL_PTR(getlocal),
    LABEL_PTR(setlocal),
    LABEL_PTR(getblockparam),
    LABEL_PTR(setblockparam),
    LABEL_PTR(getblockparamproxy),
    LABEL_PTR(getspecial),
    LABEL_PTR(setspecial),
    LABEL_PTR(getinstancevariable),
    LABEL_PTR(setinstancevariable),
    LABEL_PTR(getclassvariable),
    LABEL_PTR(setclassvariable),
    LABEL_PTR(getconstant),
    LABEL_PTR(setconstant),
    LABEL_PTR(getglobal),
    LABEL_PTR(setglobal),
    LABEL_PTR(putnil),
    LABEL_PTR(putself),
    LABEL_PTR(putobject),
    LABEL_PTR(putspecialobject),
    LABEL_PTR(putiseq),
    LABEL_PTR(putstring),
    LABEL_PTR(concatstrings),
    LABEL_PTR(tostring),
    LABEL_PTR(freezestring),
    LABEL_PTR(toregexp),
    LABEL_PTR(intern),
    LABEL_PTR(newarray),
    LABEL_PTR(duparray),
    LABEL_PTR(duphash),
    LABEL_PTR(expandarray),
    LABEL_PTR(concatarray),
    LABEL_PTR(splatarray),
    LABEL_PTR(newhash),
    LABEL_PTR(newrange),
    LABEL_PTR(pop),
    LABEL_PTR(dup),
    LABEL_PTR(dupn),
    LABEL_PTR(swap),
    LABEL_PTR(reverse),
    LABEL_PTR(reput),
    LABEL_PTR(topn),
    LABEL_PTR(setn),
    LABEL_PTR(adjuststack),
    LABEL_PTR(defined),
    LABEL_PTR(checkmatch),
    LABEL_PTR(checkkeyword),
    LABEL_PTR(checktype),
    LABEL_PTR(defineclass),
    LABEL_PTR(send),
    LABEL_PTR(opt_send_without_block),
    LABEL_PTR(opt_str_freeze),
    LABEL_PTR(opt_str_uminus),
    LABEL_PTR(opt_newarray_max),
    LABEL_PTR(opt_newarray_min),
    LABEL_PTR(invokesuper),
    LABEL_PTR(invokeblock),
    LABEL_PTR(leave),
    LABEL_PTR(throw),
    LABEL_PTR(jump),
    LABEL_PTR(branchif),
    LABEL_PTR(branchunless),
    LABEL_PTR(branchnil),
    LABEL_PTR(opt_getinlinecache),
    LABEL_PTR(opt_setinlinecache),
    LABEL_PTR(once),
    LABEL_PTR(opt_case_dispatch),
    LABEL_PTR(opt_plus),
    LABEL_PTR(opt_minus),
    LABEL_PTR(opt_mult),
    LABEL_PTR(opt_div),
    LABEL_PTR(opt_mod),
    LABEL_PTR(opt_eq),
    LABEL_PTR(opt_neq),
    LABEL_PTR(opt_lt),
    LABEL_PTR(opt_le),
    LABEL_PTR(opt_gt),
    LABEL_PTR(opt_ge),
    LABEL_PTR(opt_ltlt),
    LABEL_PTR(opt_and),
    LABEL_PTR(opt_or),
    LABEL_PTR(opt_aref),
    LABEL_PTR(opt_aset),
    LABEL_PTR(opt_aset_with),
    LABEL_PTR(opt_aref_with),
    LABEL_PTR(opt_length),
    LABEL_PTR(opt_size),
    LABEL_PTR(opt_empty_p),
    LABEL_PTR(opt_succ),
    LABEL_PTR(opt_not),
    LABEL_PTR(opt_regexpmatch1),
    LABEL_PTR(opt_regexpmatch2),
    LABEL_PTR(opt_call_c_function),
    LABEL_PTR(bitblt),
    LABEL_PTR(answer),
    LABEL_PTR(getlocal_WC_0),
    LABEL_PTR(getlocal_WC_1),
    LABEL_PTR(setlocal_WC_0),
    LABEL_PTR(setlocal_WC_1),
    LABEL_PTR(putobject_INT2FIX_0_),
    LABEL_PTR(putobject_INT2FIX_1_),
    LABEL_PTR(trace_nop),
    LABEL_PTR(trace_getlocal),
    LABEL_PTR(trace_setlocal),
    LABEL_PTR(trace_getblockparam),
    LABEL_PTR(trace_setblockparam),
    LABEL_PTR(trace_getblockparamproxy),
    LABEL_PTR(trace_getspecial),
    LABEL_PTR(trace_setspecial),
    LABEL_PTR(trace_getinstancevariable),
    LABEL_PTR(trace_setinstancevariable),
    LABEL_PTR(trace_getclassvariable),
    LABEL_PTR(trace_setclassvariable),
    LABEL_PTR(trace_getconstant),
    LABEL_PTR(trace_setconstant),
    LABEL_PTR(trace_getglobal),
    LABEL_PTR(trace_setglobal),
    LABEL_PTR(trace_putnil),
    LABEL_PTR(trace_putself),
    LABEL_PTR(trace_putobject),
    LABEL_PTR(trace_putspecialobject),
    LABEL_PTR(trace_putiseq),
    LABEL_PTR(trace_putstring),
    LABEL_PTR(trace_concatstrings),
    LABEL_PTR(trace_tostring),
    LABEL_PTR(trace_freezestring),
    LABEL_PTR(trace_toregexp),
    LABEL_PTR(trace_intern),
    LABEL_PTR(trace_newarray),
    LABEL_PTR(trace_duparray),
    LABEL_PTR(trace_duphash),
    LABEL_PTR(trace_expandarray),
    LABEL_PTR(trace_concatarray),
    LABEL_PTR(trace_splatarray),
    LABEL_PTR(trace_newhash),
    LABEL_PTR(trace_newrange),
    LABEL_PTR(trace_pop),
    LABEL_PTR(trace_dup),
    LABEL_PTR(trace_dupn),
    LABEL_PTR(trace_swap),
    LABEL_PTR(trace_reverse),
    LABEL_PTR(trace_reput),
    LABEL_PTR(trace_topn),
    LABEL_PTR(trace_setn),
    LABEL_PTR(trace_adjuststack),
    LABEL_PTR(trace_defined),
    LABEL_PTR(trace_checkmatch),
    LABEL_PTR(trace_checkkeyword),
    LABEL_PTR(trace_checktype),
    LABEL_PTR(trace_defineclass),
    LABEL_PTR(trace_send),
    LABEL_PTR(trace_opt_send_without_block),
    LABEL_PTR(trace_opt_str_freeze),
    LABEL_PTR(trace_opt_str_uminus),
    LABEL_PTR(trace_opt_newarray_max),
    LABEL_PTR(trace_opt_newarray_min),
    LABEL_PTR(trace_invokesuper),
    LABEL_PTR(trace_invokeblock),
    LABEL_PTR(trace_leave),
    LABEL_PTR(trace_throw),
    LABEL_PTR(trace_jump),
    LABEL_PTR(trace_branchif),
    LABEL_PTR(trace_branchunless),
    LABEL_PTR(trace_branchnil),
    LABEL_PTR(trace_opt_getinlinecache),
    LABEL_PTR(trace_opt_setinlinecache),
    LABEL_PTR(trace_once),
    LABEL_PTR(trace_opt_case_dispatch),
    LABEL_PTR(trace_opt_plus),
    LABEL_PTR(trace_opt_minus),
    LABEL_PTR(trace_opt_mult),
    LABEL_PTR(trace_opt_div),
    LABEL_PTR(trace_opt_mod),
    LABEL_PTR(trace_opt_eq),
    LABEL_PTR(trace_opt_neq),
    LABEL_PTR(trace_opt_lt),
    LABEL_PTR(trace_opt_le),
    LABEL_PTR(trace_opt_gt),
    LABEL_PTR(trace_opt_ge),
    LABEL_PTR(trace_opt_ltlt),
    LABEL_PTR(trace_opt_and),
    LABEL_PTR(trace_opt_or),
    LABEL_PTR(trace_opt_aref),
    LABEL_PTR(trace_opt_aset),
    LABEL_PTR(trace_opt_aset_with),
    LABEL_PTR(trace_opt_aref_with),
    LABEL_PTR(trace_opt_length),
    LABEL_PTR(trace_opt_size),
    LABEL_PTR(trace_opt_empty_p),
    LABEL_PTR(trace_opt_succ),
    LABEL_PTR(trace_opt_not),
    LABEL_PTR(trace_opt_regexpmatch1),
    LABEL_PTR(trace_opt_regexpmatch2),
    LABEL_PTR(trace_opt_call_c_function),
    LABEL_PTR(trace_bitblt),
    LABEL_PTR(trace_answer),
    LABEL_PTR(trace_getlocal_WC_0),
    LABEL_PTR(trace_getlocal_WC_1),
    LABEL_PTR(trace_setlocal_WC_0),
    LABEL_PTR(trace_setlocal_WC_1),
    LABEL_PTR(trace_putobject_INT2FIX_0_),
    LABEL_PTR(trace_putobject_INT2FIX_1_),
};

ASSERT_VM_INSTRUCTION_SIZE(insns_address_table);
