/* -*- C -*- */

/* This is  an auto-generated file  and is a  part of the  programming language
 * Ruby.   The person  who  created  a program  to  generate  this file  (``I''
 * hereafter) would like  to refrain from defining licensing  of this generated
 * source code.
 *
 * This file consists of many small  parts of codes copyrighted by each author,
 * not  only  the  ``I''  person.   Those  original  authors  agree  with  some
 * open-source license.  I  believe that the license we agree  is the condition
 * mentioned in  the file COPYING.  It  states "4.  You may  modify and include
 * the part of the software into any  other software ...".  But the problem is,
 * the license never makes it clear if  such modified parts still remain in the
 * same  license, or  not.   The fact  that  we agree  with  the source  code's
 * licensing terms does not automatically  define that of generated ones.  This
 * is the reason why this file is  under an unclear situation.  All what I know
 * is that above provision guarantees this file to exist.
 *
 * Please let me hesitate to declare  something about this nuanced contract.  I
 * am not in the position to take  over other authors' license to merge into my
 * one.  Changing them to (say) GPLv3 is not doable by myself.  Perhaps someday
 * it might turn  out to be okay to  say this file is under a  license.  I wish
 * the situation would become more clear in the future. */

/*******************************************************************/
/*******************************************************************/
/*******************************************************************/
/**
  This file is VM main loop.

  ----
  This file is auto generated by insns2vm.rb
  DO NOT TOUCH!

  If you want to fix something, you must edit "tool/ruby_vm/views/vm.inc.erb"
  or tool/insns2vm.rb
 */

#include "vm_insnhelper.h"

/* insn nop()()() */
INSN_ENTRY(nop)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(nop);
    DEBUG_ENTER_INSN("nop");

    /* ###  Declare and assign variables. ### */
#   define INSN_ATTR(x) attr_ ## x ## _nop()
    const bool leaf = INSN_ATTR(leaf);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(nop);
}

/* insn getlocal(idx, level)()(val) */
INSN_ENTRY(getlocal)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(getlocal);
    DEBUG_ENTER_INSN("getlocal");

    /* ###  Declare and assign variables. ### */
    lindex_t idx = (lindex_t)GET_OPERAND(1);
    rb_num_t level = (rb_num_t)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _getlocal(idx, level)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, level);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN getlocal
#   line 81 "insns.def"
{
    val = *(vm_get_ep(GET_EP(), level) - idx);
    RB_DEBUG_COUNTER_INC(lvar_get);
    (void)RB_DEBUG_COUNTER_INC_IF(lvar_get_dynamic, level > 0);
}
#   line 96 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(getlocal);
}

/* insn setlocal(idx, level)(val)() */
INSN_ENTRY(setlocal)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(setlocal);
    DEBUG_ENTER_INSN("setlocal");

    /* ###  Declare and assign variables. ### */
    lindex_t idx = (lindex_t)GET_OPERAND(1);
    rb_num_t level = (rb_num_t)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _setlocal(idx, level)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, level);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN setlocal
#   line 95 "insns.def"
{
    vm_env_write(vm_get_ep(GET_EP(), level), -(int)idx, val);
    RB_DEBUG_COUNTER_INC(lvar_set);
    (void)RB_DEBUG_COUNTER_INC_IF(lvar_set_dynamic, level > 0);
}
#   line 142 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(setlocal);
}

/* insn getblockparam(idx, level)()(val) */
INSN_ENTRY(getblockparam)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(getblockparam);
    DEBUG_ENTER_INSN("getblockparam");

    /* ###  Declare and assign variables. ### */
    lindex_t idx = (lindex_t)GET_OPERAND(1);
    rb_num_t level = (rb_num_t)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _getblockparam(idx, level)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, level);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN getblockparam
#   line 107 "insns.def"
{
    const VALUE *ep = vm_get_ep(GET_EP(), level);
    VM_ASSERT(VM_ENV_LOCAL_P(ep));

    if (!VM_ENV_FLAGS(ep, VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM)) {
        val = rb_vm_bh_to_procval(ec, VM_ENV_BLOCK_HANDLER(ep));
        vm_env_write(ep, -(int)idx, val);
        VM_ENV_FLAGS_SET(ep, VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM);
    }
    else {
        val = *(ep - idx);
        RB_DEBUG_COUNTER_INC(lvar_get);
        (void)RB_DEBUG_COUNTER_INC_IF(lvar_get_dynamic, level > 0);
    }
}
#   line 195 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(getblockparam);
}

/* insn setblockparam(idx, level)(val)() */
INSN_ENTRY(setblockparam)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(setblockparam);
    DEBUG_ENTER_INSN("setblockparam");

    /* ###  Declare and assign variables. ### */
    lindex_t idx = (lindex_t)GET_OPERAND(1);
    rb_num_t level = (rb_num_t)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _setblockparam(idx, level)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, level);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN setblockparam
#   line 129 "insns.def"
{
    const VALUE *ep = vm_get_ep(GET_EP(), level);
    VM_ASSERT(VM_ENV_LOCAL_P(ep));

    vm_env_write(ep, -(int)idx, val);
    RB_DEBUG_COUNTER_INC(lvar_set);
    (void)RB_DEBUG_COUNTER_INC_IF(lvar_set_dynamic, level > 0);

    VM_ENV_FLAGS_SET(ep, VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM);
}
#   line 246 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(setblockparam);
}

/* insn getblockparamproxy(idx, level)()(val) */
INSN_ENTRY(getblockparamproxy)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(getblockparamproxy);
    DEBUG_ENTER_INSN("getblockparamproxy");

    /* ###  Declare and assign variables. ### */
    lindex_t idx = (lindex_t)GET_OPERAND(1);
    rb_num_t level = (rb_num_t)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _getblockparamproxy(idx, level)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, level);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN getblockparamproxy
#   line 148 "insns.def"
{
    const VALUE *ep = vm_get_ep(GET_EP(), level);
    VM_ASSERT(VM_ENV_LOCAL_P(ep));

    if (!VM_ENV_FLAGS(ep, VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM)) {
        VALUE block_handler = VM_ENV_BLOCK_HANDLER(ep);

        if (block_handler) {
            switch (vm_block_handler_type(block_handler)) {
              case block_handler_type_iseq:
              case block_handler_type_ifunc:
                val = rb_block_param_proxy;
                break;
              case block_handler_type_symbol:
                val = rb_sym_to_proc(VM_BH_TO_SYMBOL(block_handler));
                goto INSN_LABEL(set);
              case block_handler_type_proc:
                val = VM_BH_TO_PROC(block_handler);
                goto INSN_LABEL(set);
              default:
                VM_UNREACHABLE(getblockparamproxy);
            }
        }
        else {
            val = Qnil;
          INSN_LABEL(set):
            vm_env_write(ep, -(int)idx, val);
            VM_ENV_FLAGS_SET(ep, VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM);
        }
    }
    else {
        val = *(ep - idx);
        RB_DEBUG_COUNTER_INC(lvar_get);
        (void)RB_DEBUG_COUNTER_INC_IF(lvar_get_dynamic, level > 0);
    }
}
#   line 320 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(getblockparamproxy);
}

/* insn getspecial(key, type)()(val) */
INSN_ENTRY(getspecial)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(getspecial);
    DEBUG_ENTER_INSN("getspecial");

    /* ###  Declare and assign variables. ### */
    rb_num_t key = (rb_num_t)GET_OPERAND(1);
    rb_num_t type = (rb_num_t)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _getspecial(key, type)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, key);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, type);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN getspecial
#   line 193 "insns.def"
{
    val = vm_getspecial(ec, GET_LEP(), key, type);
}
#   line 364 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(getspecial);
}

/* insn setspecial(key)(obj)() */
INSN_ENTRY(setspecial)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(setspecial);
    DEBUG_ENTER_INSN("setspecial");

    /* ###  Declare and assign variables. ### */
    rb_num_t key = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _setspecial(key)
    const bool leaf = INSN_ATTR(leaf);
    VALUE obj = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, key);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN setspecial
#   line 203 "insns.def"
{
    lep_svar_set(ec, GET_LEP(), key, obj);
}
#   line 406 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(setspecial);
}

/* insn getinstancevariable(id, ic)()(val) */
INSN_ENTRY(getinstancevariable)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(getinstancevariable);
    DEBUG_ENTER_INSN("getinstancevariable");

    /* ###  Declare and assign variables. ### */
    ID id = (ID)GET_OPERAND(1);
    IVC ic = (IVC)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _getinstancevariable(id, ic)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, ic);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN getinstancevariable
#   line 215 "insns.def"
{
    val = vm_getinstancevariable(GET_ISEQ(), GET_SELF(), id, ic);
}
#   line 447 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(getinstancevariable);
}

/* insn setinstancevariable(id, ic)(val)() */
INSN_ENTRY(setinstancevariable)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(setinstancevariable);
    DEBUG_ENTER_INSN("setinstancevariable");

    /* ###  Declare and assign variables. ### */
    ID id = (ID)GET_OPERAND(1);
    IVC ic = (IVC)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _setinstancevariable(id, ic)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, ic);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN setinstancevariable
#   line 226 "insns.def"
{
    vm_setinstancevariable(GET_ISEQ(), GET_SELF(), id, val, ic);
}
#   line 491 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(setinstancevariable);
}

/* insn getclassvariable(id, ic)()(val) */
INSN_ENTRY(getclassvariable)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(getclassvariable);
    DEBUG_ENTER_INSN("getclassvariable");

    /* ###  Declare and assign variables. ### */
    ID id = (ID)GET_OPERAND(1);
    ICVARC ic = (ICVARC)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _getclassvariable(id, ic)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, ic);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN getclassvariable
#   line 238 "insns.def"
{
    rb_control_frame_t *cfp = GET_CFP();
    val = vm_getclassvariable(GET_ISEQ(), cfp, id, ic);
}
#   line 533 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(getclassvariable);
}

/* insn setclassvariable(id, ic)(val)() */
INSN_ENTRY(setclassvariable)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(setclassvariable);
    DEBUG_ENTER_INSN("setclassvariable");

    /* ###  Declare and assign variables. ### */
    ID id = (ID)GET_OPERAND(1);
    ICVARC ic = (ICVARC)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _setclassvariable(id, ic)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, ic);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN setclassvariable
#   line 251 "insns.def"
{
    vm_ensure_not_refinement_module(GET_SELF());
    vm_setclassvariable(GET_ISEQ(), GET_CFP(), id,  val, ic);
}
#   line 578 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(setclassvariable);
}

/* insn opt_getconstant_path(ic)()(val) */
INSN_ENTRY(opt_getconstant_path)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_getconstant_path);
    DEBUG_ENTER_INSN("opt_getconstant_path");

    /* ###  Declare and assign variables. ### */
    IC ic = (IC)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_getconstant_path(ic)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ic);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_getconstant_path
#   line 262 "insns.def"
{
    const ID *segments = ic->segments;
    struct iseq_inline_constant_cache_entry *ice = ic->entry;
    if (ice && vm_ic_hit_p(ice, GET_EP())) {
        val = ice->value;

        VM_ASSERT(val == vm_get_ev_const_chain(ec, segments));
    } else {
        ruby_vm_constant_cache_misses++;
        val = vm_get_ev_const_chain(ec, segments);
        vm_ic_track_const_chain(GET_CFP(), ic, segments);
        // Because leaf=false, we need to undo the PC increment to get the address to this instruction
        // INSN_ATTR(width) == 2
        vm_ic_update(GET_ISEQ(), ic, val, GET_EP(), GET_PC() - 2);
    }
}
#   line 630 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_getconstant_path);
}

/* insn getconstant(id)(klass, allow_nil)(val) */
INSN_ENTRY(getconstant)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(getconstant);
    DEBUG_ENTER_INSN("getconstant");

    /* ###  Declare and assign variables. ### */
    ID id = (ID)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _getconstant(id)
    const bool leaf = INSN_ATTR(leaf);
    VALUE klass = TOPN(1);
    VALUE allow_nil = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN getconstant
#   line 290 "insns.def"
{
    val = vm_get_ev_const(ec, klass, id, allow_nil == Qtrue, 0);
}
#   line 674 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(getconstant);
}

/* insn setconstant(id)(val, cbase)() */
INSN_ENTRY(setconstant)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(setconstant);
    DEBUG_ENTER_INSN("setconstant");

    /* ###  Declare and assign variables. ### */
    ID id = (ID)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _setconstant(id)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(1);
    VALUE cbase = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN setconstant
#   line 306 "insns.def"
{
    vm_check_if_namespace(cbase);
    vm_ensure_not_refinement_module(GET_SELF());
    rb_const_set(cbase, id, val);
}
#   line 719 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(setconstant);
}

/* insn getglobal(gid)()(val) */
INSN_ENTRY(getglobal)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(getglobal);
    DEBUG_ENTER_INSN("getglobal");

    /* ###  Declare and assign variables. ### */
    ID gid = (ID)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _getglobal(gid)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, gid);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN getglobal
#   line 319 "insns.def"
{
    val = rb_gvar_get(gid);
}
#   line 758 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(getglobal);
}

/* insn setglobal(gid)(val)() */
INSN_ENTRY(setglobal)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(setglobal);
    DEBUG_ENTER_INSN("setglobal");

    /* ###  Declare and assign variables. ### */
    ID gid = (ID)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _setglobal(gid)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, gid);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN setglobal
#   line 330 "insns.def"
{
    rb_gvar_set(gid, val);
}
#   line 800 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(setglobal);
}

/* insn putnil()()(val) */
INSN_ENTRY(putnil)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(putnil);
    DEBUG_ENTER_INSN("putnil");

    /* ###  Declare and assign variables. ### */
#   define INSN_ATTR(x) attr_ ## x ## _putnil()
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN putnil
#   line 344 "insns.def"
{
    val = Qnil;
}
#   line 837 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(putnil);
}

/* insn putself()()(val) */
INSN_ENTRY(putself)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(putself);
    DEBUG_ENTER_INSN("putself");

    /* ###  Declare and assign variables. ### */
#   define INSN_ATTR(x) attr_ ## x ## _putself()
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN putself
#   line 354 "insns.def"
{
    val = GET_SELF();
}
#   line 877 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(putself);
}

/* insn putobject(val)()(val) */
INSN_ENTRY(putobject)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(putobject);
    DEBUG_ENTER_INSN("putobject");

    /* ###  Declare and assign variables. ### */
    VALUE val = (VALUE)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _putobject(val)
    const bool leaf = INSN_ATTR(leaf);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, val);

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(putobject);
}

/* insn putspecialobject(value_type)()(val) */
INSN_ENTRY(putspecialobject)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(putspecialobject);
    DEBUG_ENTER_INSN("putspecialobject");

    /* ###  Declare and assign variables. ### */
    rb_num_t value_type = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _putspecialobject(value_type)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, value_type);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN putspecialobject
#   line 377 "insns.def"
{
    enum vm_special_object_type type;

    type = (enum vm_special_object_type)value_type;
    val = vm_get_special_object(GET_EP(), type);
}
#   line 952 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(putspecialobject);
}

/* insn putstring(str)()(val) */
INSN_ENTRY(putstring)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(putstring);
    DEBUG_ENTER_INSN("putstring");

    /* ###  Declare and assign variables. ### */
    VALUE str = (VALUE)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _putstring(str)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, str);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN putstring
#   line 390 "insns.def"
{
    val = rb_ec_str_resurrect(ec, str);
}
#   line 994 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(putstring);
}

/* insn concatstrings(num)(...)(val) */
INSN_ENTRY(concatstrings)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(concatstrings);
    DEBUG_ENTER_INSN("concatstrings");

    /* ###  Declare and assign variables. ### */
    rb_num_t num = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _concatstrings(num)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, num);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN concatstrings
#   line 404 "insns.def"
{
    val = rb_str_concat_literals(num, STACK_ADDR_FROM_TOP(num));
}
#   line 1036 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(concatstrings);
}

/* insn anytostring()(val, str)(val) */
INSN_ENTRY(anytostring)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(anytostring);
    DEBUG_ENTER_INSN("anytostring");

    /* ###  Declare and assign variables. ### */
#   define INSN_ATTR(x) attr_ ## x ## _anytostring()
    const bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(1);
    VALUE str = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN anytostring
#   line 415 "insns.def"
{
    val = rb_obj_as_string_result(str, val);
}
#   line 1077 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(anytostring);
}

/* insn toregexp(opt, cnt)(...)(val) */
INSN_ENTRY(toregexp)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(toregexp);
    DEBUG_ENTER_INSN("toregexp");

    /* ###  Declare and assign variables. ### */
    rb_num_t opt = (rb_num_t)GET_OPERAND(1);
    rb_num_t cnt = (rb_num_t)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _toregexp(opt, cnt)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, opt);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cnt);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN toregexp
#   line 431 "insns.def"
{
    const VALUE ary = rb_ary_tmp_new_from_values(0, cnt, STACK_ADDR_FROM_TOP(cnt));
    val = rb_reg_new_ary(ary, (int)opt);
    rb_ary_clear(ary);
}
#   line 1123 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(toregexp);
}

/* insn intern()(str)(sym) */
INSN_ENTRY(intern)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(intern);
    DEBUG_ENTER_INSN("intern");

    /* ###  Declare and assign variables. ### */
#   define INSN_ATTR(x) attr_ ## x ## _intern()
    const bool leaf = INSN_ATTR(leaf);
    VALUE str = TOPN(0);
    VALUE sym;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN intern
#   line 443 "insns.def"
{
    sym = rb_str_intern(str);
}
#   line 1164 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = sym;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(intern);
}

/* insn newarray(num)(...)(val) */
INSN_ENTRY(newarray)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(newarray);
    DEBUG_ENTER_INSN("newarray");

    /* ###  Declare and assign variables. ### */
    rb_num_t num = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _newarray(num)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, num);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN newarray
#   line 454 "insns.def"
{
    val = rb_ec_ary_new_from_values(ec, num, STACK_ADDR_FROM_TOP(num));
}
#   line 1206 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(newarray);
}

/* insn newarraykwsplat(num)(...)(val) */
INSN_ENTRY(newarraykwsplat)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(newarraykwsplat);
    DEBUG_ENTER_INSN("newarraykwsplat");

    /* ###  Declare and assign variables. ### */
    rb_num_t num = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _newarraykwsplat(num)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, num);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN newarraykwsplat
#   line 469 "insns.def"
{
    if (RHASH_EMPTY_P(*STACK_ADDR_FROM_TOP(1))) {
        val = rb_ary_new4(num-1, STACK_ADDR_FROM_TOP(num));
    }
    else {
        val = rb_ary_new4(num, STACK_ADDR_FROM_TOP(num));
    }
}
#   line 1253 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(newarraykwsplat);
}

/* insn duparray(ary)()(val) */
INSN_ENTRY(duparray)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(duparray);
    DEBUG_ENTER_INSN("duparray");

    /* ###  Declare and assign variables. ### */
    VALUE ary = (VALUE)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _duparray(ary)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, ary);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN duparray
#   line 484 "insns.def"
{
    RUBY_DTRACE_CREATE_HOOK(ARRAY, RARRAY_LEN(ary));
    val = rb_ary_resurrect(ary);
}
#   line 1296 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(duparray);
}

/* insn duphash(hash)()(val) */
INSN_ENTRY(duphash)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(duphash);
    DEBUG_ENTER_INSN("duphash");

    /* ###  Declare and assign variables. ### */
    VALUE hash = (VALUE)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _duphash(hash)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, hash);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN duphash
#   line 495 "insns.def"
{
    RUBY_DTRACE_CREATE_HOOK(HASH, RHASH_SIZE(hash) << 1);
    val = rb_hash_resurrect(hash);
}
#   line 1339 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(duphash);
}

/* insn expandarray(num, flag)(..., ary)(...) */
INSN_ENTRY(expandarray)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(expandarray);
    DEBUG_ENTER_INSN("expandarray");

    /* ###  Declare and assign variables. ### */
    rb_num_t num = (rb_num_t)GET_OPERAND(1);
    rb_num_t flag = (rb_num_t)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _expandarray(num, flag)
    const bool leaf = INSN_ATTR(leaf);
    VALUE ary = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, num);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, flag);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN expandarray
#   line 516 "insns.def"
{
    vm_expandarray(GET_SP(), ary, num, (int)flag);
}
#   line 1382 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(expandarray);
}

/* insn concatarray()(ary1, ary2)(ary) */
INSN_ENTRY(concatarray)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(concatarray);
    DEBUG_ENTER_INSN("concatarray");

    /* ###  Declare and assign variables. ### */
#   define INSN_ATTR(x) attr_ ## x ## _concatarray()
    const bool leaf = INSN_ATTR(leaf);
    VALUE ary1 = TOPN(1);
    VALUE ary2 = TOPN(0);
    VALUE ary;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN concatarray
#   line 527 "insns.def"
{
    ary = vm_concat_array(ary1, ary2);
}
#   line 1420 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = ary;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(concatarray);
}

/* insn splatarray(flag)(ary)(obj) */
INSN_ENTRY(splatarray)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(splatarray);
    DEBUG_ENTER_INSN("splatarray");

    /* ###  Declare and assign variables. ### */
    VALUE flag = (VALUE)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _splatarray(flag)
    const bool leaf = INSN_ATTR(leaf);
    VALUE ary = TOPN(0);
    VALUE obj;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, flag);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN splatarray
#   line 538 "insns.def"
{
    obj = vm_splat_array(flag, ary);
}
#   line 1463 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = obj;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(splatarray);
}

/* insn newhash(num)(...)(val) */
INSN_ENTRY(newhash)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(newhash);
    DEBUG_ENTER_INSN("newhash");

    /* ###  Declare and assign variables. ### */
    rb_num_t num = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _newhash(num)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, num);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN newhash
#   line 550 "insns.def"
{
    RUBY_DTRACE_CREATE_HOOK(HASH, num);

    if (num) {
        val = rb_hash_new_with_size(num / 2);
        rb_hash_bulk_insert(num, STACK_ADDR_FROM_TOP(num), val);
    }
    else {
        val = rb_hash_new();
    }
}
#   line 1513 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(newhash);
}

/* insn newrange(flag)(low, high)(val) */
INSN_ENTRY(newrange)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(newrange);
    DEBUG_ENTER_INSN("newrange");

    /* ###  Declare and assign variables. ### */
    rb_num_t flag = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _newrange(flag)
    const bool leaf = INSN_ATTR(leaf);
    VALUE low = TOPN(1);
    VALUE high = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, flag);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN newrange
#   line 570 "insns.def"
{
    val = rb_range_new(low, high, (int)flag);
}
#   line 1557 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(newrange);
}

/* insn pop()(val)() */
INSN_ENTRY(pop)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(pop);
    DEBUG_ENTER_INSN("pop");

    /* ###  Declare and assign variables. ### */
#   define INSN_ATTR(x) attr_ ## x ## _pop()
    const bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN pop
#   line 584 "insns.def"
{
    (void)val;
    /* none */
}
#   line 1598 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(pop);
}

/* insn dup()(val)(val1, val2) */
INSN_ENTRY(dup)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(dup);
    DEBUG_ENTER_INSN("dup");

    /* ###  Declare and assign variables. ### */
#   define INSN_ATTR(x) attr_ ## x ## _dup()
    const bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);
    VALUE val1;
    VALUE val2;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN dup
#   line 595 "insns.def"
{
    val1 = val2 = val;
}
#   line 1637 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val2;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    TOPN(1) = val1;
    VM_ASSERT(!RB_TYPE_P(TOPN(1), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(1), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(dup);
}

/* insn dupn(n)(...)(...) */
INSN_ENTRY(dupn)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(dupn);
    DEBUG_ENTER_INSN("dupn");

    /* ###  Declare and assign variables. ### */
    rb_num_t n = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _dupn(n)
    const bool leaf = INSN_ATTR(leaf);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, n);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN dupn
#   line 606 "insns.def"
{
    void *dst = GET_SP();
    void *src = STACK_ADDR_FROM_TOP(n);

    MEMCPY(dst, src, VALUE, n);
}
#   line 1683 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(dupn);
}

/* insn swap()(val, obj)(obj, val) */
INSN_ENTRY(swap)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(swap);
    DEBUG_ENTER_INSN("swap");

    /* ###  Declare and assign variables. ### */
#   define INSN_ATTR(x) attr_ ## x ## _swap()
    const bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(1);
    VALUE obj = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    TOPN(1) = obj;
    VM_ASSERT(!RB_TYPE_P(TOPN(1), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(1), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(swap);
}

/* insn opt_reverse(n)(...)(...) */
INSN_ENTRY(opt_reverse)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_reverse);
    DEBUG_ENTER_INSN("opt_reverse");

    /* ###  Declare and assign variables. ### */
    rb_num_t n = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_reverse(n)
    const bool leaf = INSN_ATTR(leaf);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, n);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_reverse
#   line 630 "insns.def"
{
    rb_num_t i;
    VALUE *sp = STACK_ADDR_FROM_TOP(n);

    for (i=0; i<n/2; i++) {
	VALUE v0 = sp[i];
	VALUE v1 = TOPN(i);
	sp[i] = v1;
	TOPN(i) = v0;
    }
}
#   line 1760 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_reverse);
}

/* insn topn(n)(...)(val) */
INSN_ENTRY(topn)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(topn);
    DEBUG_ENTER_INSN("topn");

    /* ###  Declare and assign variables. ### */
    rb_num_t n = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _topn(n)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, n);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN topn
#   line 660 "insns.def"
{
    val = TOPN(n);
}
#   line 1798 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(topn);
}

/* insn setn(n)(..., val)(val) */
INSN_ENTRY(setn)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(setn);
    DEBUG_ENTER_INSN("setn");

    /* ###  Declare and assign variables. ### */
    rb_num_t n = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _setn(n)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, n);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN setn
#   line 671 "insns.def"
{
    TOPN(n) = val;
}
#   line 1840 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(setn);
}

/* insn adjuststack(n)(...)(...) */
INSN_ENTRY(adjuststack)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(adjuststack);
    DEBUG_ENTER_INSN("adjuststack");

    /* ###  Declare and assign variables. ### */
    rb_num_t n = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _adjuststack(n)
    const bool leaf = INSN_ATTR(leaf);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, n);

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(adjuststack);
}

/* insn defined(op_type, obj, pushval)(v)(val) */
INSN_ENTRY(defined)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(defined);
    DEBUG_ENTER_INSN("defined");

    /* ###  Declare and assign variables. ### */
    rb_num_t op_type = (rb_num_t)GET_OPERAND(1);
    VALUE obj = (VALUE)GET_OPERAND(2);
    VALUE pushval = (VALUE)GET_OPERAND(3);
#   define INSN_ATTR(x) attr_ ## x ## _defined(op_type, obj, pushval)
    const bool leaf = INSN_ATTR(leaf);
    VALUE v = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, op_type);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, obj);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 2, pushval);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN defined
#   line 697 "insns.def"
{
    val = Qnil;
    if (vm_defined(ec, GET_CFP(), op_type, obj, v)) {
        val = pushval;
    }
}
#   line 1917 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(defined);
}

/* insn checkmatch(flag)(target, pattern)(result) */
INSN_ENTRY(checkmatch)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(checkmatch);
    DEBUG_ENTER_INSN("checkmatch");

    /* ###  Declare and assign variables. ### */
    rb_num_t flag = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _checkmatch(flag)
    const bool leaf = INSN_ATTR(leaf);
    VALUE target = TOPN(1);
    VALUE pattern = TOPN(0);
    VALUE result;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, flag);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN checkmatch
#   line 717 "insns.def"
{
    result = vm_check_match(ec, target, pattern, flag);
}
#   line 1961 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = result;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(checkmatch);
}

/* insn checkkeyword(kw_bits_index, keyword_index)()(ret) */
INSN_ENTRY(checkkeyword)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(checkkeyword);
    DEBUG_ENTER_INSN("checkkeyword");

    /* ###  Declare and assign variables. ### */
    lindex_t kw_bits_index = (lindex_t)GET_OPERAND(1);
    lindex_t keyword_index = (lindex_t)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _checkkeyword(kw_bits_index, keyword_index)
    const bool leaf = INSN_ATTR(leaf);
    VALUE ret;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, kw_bits_index);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, keyword_index);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN checkkeyword
#   line 727 "insns.def"
{
    ret = vm_check_keyword(kw_bits_index, keyword_index, GET_EP());
}
#   line 2005 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = ret;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(checkkeyword);
}

/* insn checktype(type)(val)(ret) */
INSN_ENTRY(checktype)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(checktype);
    DEBUG_ENTER_INSN("checktype");

    /* ###  Declare and assign variables. ### */
    rb_num_t type = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _checktype(type)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);
    VALUE ret;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, type);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN checktype
#   line 737 "insns.def"
{
    ret = RBOOL(TYPE(val) == (int)type);
}
#   line 2048 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = ret;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(checktype);
}

/* insn defineclass(id, class_iseq, flags)(cbase, super)(val) */
INSN_ENTRY(defineclass)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(defineclass);
    DEBUG_ENTER_INSN("defineclass");

    /* ###  Declare and assign variables. ### */
    ID id = (ID)GET_OPERAND(1);
    ISEQ class_iseq = (ISEQ)GET_OPERAND(2);
    rb_num_t flags = (rb_num_t)GET_OPERAND(3);
#   define INSN_ATTR(x) attr_ ## x ## _defineclass(id, class_iseq, flags)
    const bool leaf = INSN_ATTR(leaf);
    VALUE cbase = TOPN(1);
    VALUE super = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, class_iseq);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 2, flags);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN defineclass
#   line 753 "insns.def"
{
    VALUE klass = vm_find_or_create_class_by_id(id, flags, cbase, super);

    rb_iseq_check(class_iseq);

    /* enter scope */
    vm_push_frame(ec, class_iseq, VM_FRAME_MAGIC_CLASS | VM_ENV_FLAG_LOCAL, klass,
                  GET_BLOCK_HANDLER(),
                  (VALUE)vm_cref_push(ec, klass, NULL, FALSE, FALSE),
                  ISEQ_BODY(class_iseq)->iseq_encoded, GET_SP(),
                  ISEQ_BODY(class_iseq)->local_table_size,
                  ISEQ_BODY(class_iseq)->stack_max);
    RESTORE_REGS();
    NEXT_INSN();
}
#   line 2109 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    PUSH(val);
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(defineclass);
}

/* insn definemethod(id, iseq)()() */
INSN_ENTRY(definemethod)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(definemethod);
    DEBUG_ENTER_INSN("definemethod");

    /* ###  Declare and assign variables. ### */
    ID id = (ID)GET_OPERAND(1);
    ISEQ iseq = (ISEQ)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _definemethod(id, iseq)
    const bool leaf = INSN_ATTR(leaf);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, iseq);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN definemethod
#   line 774 "insns.def"
{
    vm_define_method(ec, Qnil, id, (VALUE)iseq, FALSE);
}
#   line 2150 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(definemethod);
}

/* insn definesmethod(id, iseq)(obj)() */
INSN_ENTRY(definesmethod)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(definesmethod);
    DEBUG_ENTER_INSN("definesmethod");

    /* ###  Declare and assign variables. ### */
    ID id = (ID)GET_OPERAND(1);
    ISEQ iseq = (ISEQ)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _definesmethod(id, iseq)
    const bool leaf = INSN_ATTR(leaf);
    VALUE obj = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, id);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, iseq);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN definesmethod
#   line 783 "insns.def"
{
    vm_define_method(ec, obj, id, (VALUE)iseq, TRUE);
}
#   line 2191 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(definesmethod);
}

/* insn send(cd, blockiseq)(...)(val) */
INSN_ENTRY(send)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(send);
    DEBUG_ENTER_INSN("send");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
    ISEQ blockiseq = (ISEQ)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _send(cd, blockiseq)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, blockiseq);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN send
#   line 799 "insns.def"
{
    VALUE bh = vm_caller_setup_arg_block(ec, GET_CFP(), cd->ci, blockiseq, false);
    val = vm_sendish(ec, GET_CFP(), cd, bh, mexp_search_method);

    if (val == Qundef) {
        RESTORE_REGS();
        NEXT_INSN();
    }
}
#   line 2238 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    PUSH(val);
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(send);
}

/* insn opt_send_without_block(cd)(...)(val) */
INSN_ENTRY(opt_send_without_block)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_send_without_block);
    DEBUG_ENTER_INSN("opt_send_without_block");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_send_without_block(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_send_without_block
#   line 818 "insns.def"
{
    VALUE bh = VM_BLOCK_HANDLER_NONE;
    val = vm_sendish(ec, GET_CFP(), cd, bh, mexp_search_method);

    if (val == Qundef) {
        RESTORE_REGS();
        NEXT_INSN();
    }
}
#   line 2284 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    PUSH(val);
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_send_without_block);
}

/* insn objtostring(cd)(recv)(val) */
INSN_ENTRY(objtostring)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(objtostring);
    DEBUG_ENTER_INSN("objtostring");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _objtostring(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN objtostring
#   line 835 "insns.def"
{
    val = vm_objtostring(GET_ISEQ(), recv, cd);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 2328 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(objtostring);
}

/* insn opt_str_freeze(str, cd)()(val) */
INSN_ENTRY(opt_str_freeze)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_str_freeze);
    DEBUG_ENTER_INSN("opt_str_freeze");

    /* ###  Declare and assign variables. ### */
    VALUE str = (VALUE)GET_OPERAND(1);
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _opt_str_freeze(str, cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, str);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_str_freeze
#   line 848 "insns.def"
{
    val = vm_opt_str_freeze(str, BOP_FREEZE, idFreeze);

    if (val == Qundef) {
        PUSH(rb_str_resurrect(str));
        CALL_SIMPLE_METHOD();
    }
}
#   line 2377 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_str_freeze);
}

/* insn opt_nil_p(cd)(recv)(val) */
INSN_ENTRY(opt_nil_p)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_nil_p);
    DEBUG_ENTER_INSN("opt_nil_p");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_nil_p(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_nil_p
#   line 863 "insns.def"
{
    val = vm_opt_nil_p(GET_ISEQ(), cd, recv);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 2424 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_nil_p);
}

/* insn opt_str_uminus(str, cd)()(val) */
INSN_ENTRY(opt_str_uminus)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_str_uminus);
    DEBUG_ENTER_INSN("opt_str_uminus");

    /* ###  Declare and assign variables. ### */
    VALUE str = (VALUE)GET_OPERAND(1);
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _opt_str_uminus(str, cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, str);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_str_uminus
#   line 876 "insns.def"
{
    val = vm_opt_str_freeze(str, BOP_UMINUS, idUMinus);

    if (val == Qundef) {
        PUSH(rb_str_resurrect(str));
        CALL_SIMPLE_METHOD();
    }
}
#   line 2473 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_str_uminus);
}

/* insn opt_newarray_max(num)(...)(val) */
INSN_ENTRY(opt_newarray_max)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_newarray_max);
    DEBUG_ENTER_INSN("opt_newarray_max");

    /* ###  Declare and assign variables. ### */
    rb_num_t num = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_newarray_max(num)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, num);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_newarray_max
#   line 896 "insns.def"
{
    val = vm_opt_newarray_max(ec, num, STACK_ADDR_FROM_TOP(num));
}
#   line 2515 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_newarray_max);
}

/* insn opt_newarray_min(num)(...)(val) */
INSN_ENTRY(opt_newarray_min)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_newarray_min);
    DEBUG_ENTER_INSN("opt_newarray_min");

    /* ###  Declare and assign variables. ### */
    rb_num_t num = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_newarray_min(num)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, num);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_newarray_min
#   line 908 "insns.def"
{
    val = vm_opt_newarray_min(ec, num, STACK_ADDR_FROM_TOP(num));
}
#   line 2557 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_newarray_min);
}

/* insn invokesuper(cd, blockiseq)(...)(val) */
INSN_ENTRY(invokesuper)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(invokesuper);
    DEBUG_ENTER_INSN("invokesuper");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
    ISEQ blockiseq = (ISEQ)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _invokesuper(cd, blockiseq)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, blockiseq);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN invokesuper
#   line 920 "insns.def"
{
    VALUE bh = vm_caller_setup_arg_block(ec, GET_CFP(), cd->ci, blockiseq, true);
    val = vm_sendish(ec, GET_CFP(), cd, bh, mexp_search_super);

    if (val == Qundef) {
        RESTORE_REGS();
        NEXT_INSN();
    }
}
#   line 2608 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    PUSH(val);
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(invokesuper);
}

/* insn invokeblock(cd)(...)(val) */
INSN_ENTRY(invokeblock)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(invokeblock);
    DEBUG_ENTER_INSN("invokeblock");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _invokeblock(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN invokeblock
#   line 939 "insns.def"
{
    VALUE bh = VM_BLOCK_HANDLER_NONE;
    val = vm_sendish(ec, GET_CFP(), cd, bh, mexp_search_invokeblock);

    if (val == Qundef) {
        RESTORE_REGS();
        NEXT_INSN();
    }
}
#   line 2654 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    PUSH(val);
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(invokeblock);
}

/* insn leave()(val)(val) */
INSN_ENTRY(leave)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(leave);
    DEBUG_ENTER_INSN("leave");

    /* ###  Declare and assign variables. ### */
#   define INSN_ATTR(x) attr_ ## x ## _leave()
    const bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN leave
#   line 960 "insns.def"
{
    if (OPT_CHECKED_RUN) {
        const VALUE *const bp = vm_base_ptr(GET_CFP());
        if (GET_SP() != bp) {
            vm_stack_consistency_error(ec, GET_CFP(), bp);
        }
    }

    if (vm_pop_frame(ec, GET_CFP(), GET_EP())) {
#   if OPT_CALL_THREADED_CODE
        rb_ec_thread_ptr(ec)->retval = val;
        return 0;
#   else
        return val;
#   endif
    }
    else {
        RESTORE_REGS();
    }
}
#   line 2709 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    PUSH(val);
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(leave);
}

/* insn throw(throw_state)(throwobj)(val) */
INSN_ENTRY(throw)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(throw);
    DEBUG_ENTER_INSN("throw");

    /* ###  Declare and assign variables. ### */
    rb_num_t throw_state = (rb_num_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _throw(throw_state)
    const bool leaf = INSN_ATTR(leaf);
    VALUE throwobj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, throw_state);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN throw
#   line 993 "insns.def"
{
    val = vm_throw(ec, GET_CFP(), throw_state, throwobj);
    THROW_EXCEPTION(val);
    /* unreachable */
}
#   line 2751 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(throw);
}

/* insn jump(dst)()() */
INSN_ENTRY(jump)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(jump);
    DEBUG_ENTER_INSN("jump");

    /* ###  Declare and assign variables. ### */
    OFFSET dst = (OFFSET)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _jump(dst)
    const bool leaf = INSN_ATTR(leaf);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, dst);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN jump
#   line 1011 "insns.def"
{
    RUBY_VM_CHECK_INTS(ec);
    JUMP(dst);
}
#   line 2793 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(jump);
}

/* insn branchif(dst)(val)() */
INSN_ENTRY(branchif)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(branchif);
    DEBUG_ENTER_INSN("branchif");

    /* ###  Declare and assign variables. ### */
    OFFSET dst = (OFFSET)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _branchif(dst)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, dst);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN branchif
#   line 1024 "insns.def"
{
    if (RTEST(val)) {
        RUBY_VM_CHECK_INTS(ec);
        JUMP(dst);
    }
}
#   line 2835 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(branchif);
}

/* insn branchunless(dst)(val)() */
INSN_ENTRY(branchunless)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(branchunless);
    DEBUG_ENTER_INSN("branchunless");

    /* ###  Declare and assign variables. ### */
    OFFSET dst = (OFFSET)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _branchunless(dst)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, dst);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN branchunless
#   line 1039 "insns.def"
{
    if (!RTEST(val)) {
        RUBY_VM_CHECK_INTS(ec);
        JUMP(dst);
    }
}
#   line 2877 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(branchunless);
}

/* insn branchnil(dst)(val)() */
INSN_ENTRY(branchnil)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(branchnil);
    DEBUG_ENTER_INSN("branchnil");

    /* ###  Declare and assign variables. ### */
    OFFSET dst = (OFFSET)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _branchnil(dst)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, dst);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN branchnil
#   line 1054 "insns.def"
{
    if (NIL_P(val)) {
        RUBY_VM_CHECK_INTS(ec);
        JUMP(dst);
    }
}
#   line 2919 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(branchnil);
}

/* insn once(iseq, ise)()(val) */
INSN_ENTRY(once)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(once);
    DEBUG_ENTER_INSN("once");

    /* ###  Declare and assign variables. ### */
    ISEQ iseq = (ISEQ)GET_OPERAND(1);
    ISE ise = (ISE)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _once(iseq, ise)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    POPN(INSN_ATTR(popn));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, iseq);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, ise);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN once
#   line 1071 "insns.def"
{
    val = vm_once_dispatch(ec, iseq, ise);
}
#   line 2961 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    PUSH(val);
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(once);
}

/* insn opt_case_dispatch(hash, else_offset)(..., key)() */
INSN_ENTRY(opt_case_dispatch)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_case_dispatch);
    DEBUG_ENTER_INSN("opt_case_dispatch");

    /* ###  Declare and assign variables. ### */
    CDHASH hash = (CDHASH)GET_OPERAND(1);
    OFFSET else_offset = (OFFSET)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _opt_case_dispatch(hash, else_offset)
    const bool leaf = INSN_ATTR(leaf);
    VALUE key = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, hash);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, else_offset);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_case_dispatch
#   line 1082 "insns.def"
{
    OFFSET dst = vm_case_dispatch(hash, else_offset, key);

    if (dst) {
        JUMP(dst);
    }
}
#   line 3006 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_case_dispatch);
}

/* insn opt_plus(cd)(recv, obj)(val) */
INSN_ENTRY(opt_plus)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_plus);
    DEBUG_ENTER_INSN("opt_plus");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_plus(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_plus
#   line 1098 "insns.def"
{
    val = vm_opt_plus(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3051 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_plus);
}

/* insn opt_minus(cd)(recv, obj)(val) */
INSN_ENTRY(opt_minus)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_minus);
    DEBUG_ENTER_INSN("opt_minus");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_minus(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_minus
#   line 1112 "insns.def"
{
    val = vm_opt_minus(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3099 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_minus);
}

/* insn opt_mult(cd)(recv, obj)(val) */
INSN_ENTRY(opt_mult)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_mult);
    DEBUG_ENTER_INSN("opt_mult");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_mult(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_mult
#   line 1126 "insns.def"
{
    val = vm_opt_mult(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3147 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_mult);
}

/* insn opt_div(cd)(recv, obj)(val) */
INSN_ENTRY(opt_div)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_div);
    DEBUG_ENTER_INSN("opt_div");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_div(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_div
#   line 1143 "insns.def"
{
    val = vm_opt_div(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3195 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_div);
}

/* insn opt_mod(cd)(recv, obj)(val) */
INSN_ENTRY(opt_mod)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_mod);
    DEBUG_ENTER_INSN("opt_mod");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_mod(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_mod
#   line 1159 "insns.def"
{
    val = vm_opt_mod(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3243 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_mod);
}

/* insn opt_eq(cd)(recv, obj)(val) */
INSN_ENTRY(opt_eq)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_eq);
    DEBUG_ENTER_INSN("opt_eq");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_eq(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_eq
#   line 1173 "insns.def"
{
    val = opt_equality(GET_ISEQ(), recv, obj, cd);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3291 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_eq);
}

/* insn opt_neq(cd_eq, cd)(recv, obj)(val) */
INSN_ENTRY(opt_neq)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_neq);
    DEBUG_ENTER_INSN("opt_neq");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd_eq = (CALL_DATA)GET_OPERAND(1);
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _opt_neq(cd_eq, cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd_eq);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_neq
#   line 1187 "insns.def"
{
    val = vm_opt_neq(GET_ISEQ(), cd, cd_eq, recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3341 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_neq);
}

/* insn opt_lt(cd)(recv, obj)(val) */
INSN_ENTRY(opt_lt)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_lt);
    DEBUG_ENTER_INSN("opt_lt");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_lt(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_lt
#   line 1201 "insns.def"
{
    val = vm_opt_lt(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3389 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_lt);
}

/* insn opt_le(cd)(recv, obj)(val) */
INSN_ENTRY(opt_le)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_le);
    DEBUG_ENTER_INSN("opt_le");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_le(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_le
#   line 1215 "insns.def"
{
    val = vm_opt_le(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3437 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_le);
}

/* insn opt_gt(cd)(recv, obj)(val) */
INSN_ENTRY(opt_gt)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_gt);
    DEBUG_ENTER_INSN("opt_gt");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_gt(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_gt
#   line 1229 "insns.def"
{
    val = vm_opt_gt(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3485 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_gt);
}

/* insn opt_ge(cd)(recv, obj)(val) */
INSN_ENTRY(opt_ge)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_ge);
    DEBUG_ENTER_INSN("opt_ge");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_ge(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_ge
#   line 1243 "insns.def"
{
    val = vm_opt_ge(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3533 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_ge);
}

/* insn opt_ltlt(cd)(recv, obj)(val) */
INSN_ENTRY(opt_ltlt)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_ltlt);
    DEBUG_ENTER_INSN("opt_ltlt");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_ltlt(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_ltlt
#   line 1261 "insns.def"
{
    val = vm_opt_ltlt(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3581 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_ltlt);
}

/* insn opt_and(cd)(recv, obj)(val) */
INSN_ENTRY(opt_and)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_and);
    DEBUG_ENTER_INSN("opt_and");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_and(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_and
#   line 1275 "insns.def"
{
    val = vm_opt_and(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3629 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_and);
}

/* insn opt_or(cd)(recv, obj)(val) */
INSN_ENTRY(opt_or)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_or);
    DEBUG_ENTER_INSN("opt_or");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_or(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_or
#   line 1289 "insns.def"
{
    val = vm_opt_or(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3677 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_or);
}

/* insn opt_aref(cd)(recv, obj)(val) */
INSN_ENTRY(opt_aref)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_aref);
    DEBUG_ENTER_INSN("opt_aref");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_aref(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE obj = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_aref
#   line 1308 "insns.def"
{
    val = vm_opt_aref(recv, obj);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3725 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_aref);
}

/* insn opt_aset(cd)(recv, obj, set)(val) */
INSN_ENTRY(opt_aset)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_aset);
    DEBUG_ENTER_INSN("opt_aset");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_aset(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(2);
    VALUE obj = TOPN(1);
    VALUE set = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_aset
#   line 1325 "insns.def"
{
    val = vm_opt_aset(recv, obj, set);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3774 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_aset);
}

/* insn opt_aset_with(key, cd)(recv, val)(val) */
INSN_ENTRY(opt_aset_with)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_aset_with);
    DEBUG_ENTER_INSN("opt_aset_with");

    /* ###  Declare and assign variables. ### */
    VALUE key = (VALUE)GET_OPERAND(1);
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _opt_aset_with(key, cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(1);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, key);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_aset_with
#   line 1341 "insns.def"
{
    VALUE tmp = vm_opt_aset_with(recv, key, val);

    if (tmp != Qundef) {
        val = tmp;
    }
    else {
#   ifndef MJIT_HEADER
        TOPN(0) = rb_str_resurrect(key);
        PUSH(val);
#   endif
        CALL_SIMPLE_METHOD();
    }
}
#   line 3830 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_aset_with);
}

/* insn opt_aref_with(key, cd)(recv)(val) */
INSN_ENTRY(opt_aref_with)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_aref_with);
    DEBUG_ENTER_INSN("opt_aref_with");

    /* ###  Declare and assign variables. ### */
    VALUE key = (VALUE)GET_OPERAND(1);
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _opt_aref_with(key, cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, key);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_aref_with
#   line 1364 "insns.def"
{
    val = vm_opt_aref_with(recv, key);

    if (val == Qundef) {
#   ifndef MJIT_HEADER
        PUSH(rb_str_resurrect(key));
#   endif
        CALL_SIMPLE_METHOD();
    }
}
#   line 3882 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_aref_with);
}

/* insn opt_length(cd)(recv)(val) */
INSN_ENTRY(opt_length)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_length);
    DEBUG_ENTER_INSN("opt_length");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_length(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_length
#   line 1381 "insns.def"
{
    val = vm_opt_length(recv, BOP_LENGTH);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3929 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_length);
}

/* insn opt_size(cd)(recv)(val) */
INSN_ENTRY(opt_size)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_size);
    DEBUG_ENTER_INSN("opt_size");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_size(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_size
#   line 1395 "insns.def"
{
    val = vm_opt_length(recv, BOP_SIZE);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 3976 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_size);
}

/* insn opt_empty_p(cd)(recv)(val) */
INSN_ENTRY(opt_empty_p)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_empty_p);
    DEBUG_ENTER_INSN("opt_empty_p");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_empty_p(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_empty_p
#   line 1409 "insns.def"
{
    val = vm_opt_empty_p(recv);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 4023 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_empty_p);
}

/* insn opt_succ(cd)(recv)(val) */
INSN_ENTRY(opt_succ)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_succ);
    DEBUG_ENTER_INSN("opt_succ");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_succ(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_succ
#   line 1423 "insns.def"
{
    val = vm_opt_succ(recv);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 4070 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_succ);
}

/* insn opt_not(cd)(recv)(val) */
INSN_ENTRY(opt_not)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_not);
    DEBUG_ENTER_INSN("opt_not");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_not(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE recv = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_not
#   line 1437 "insns.def"
{
    val = vm_opt_not(GET_ISEQ(), cd, recv);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 4117 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_not);
}

/* insn opt_regexpmatch2(cd)(obj2, obj1)(val) */
INSN_ENTRY(opt_regexpmatch2)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_regexpmatch2);
    DEBUG_ENTER_INSN("opt_regexpmatch2");

    /* ###  Declare and assign variables. ### */
    CALL_DATA cd = (CALL_DATA)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _opt_regexpmatch2(cd)
    const bool leaf = INSN_ATTR(leaf);
    VALUE obj2 = TOPN(1);
    VALUE obj1 = TOPN(0);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, cd);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_regexpmatch2
#   line 1452 "insns.def"
{
    val = vm_opt_regexpmatch2(obj2, obj1);

    if (val == Qundef) {
        CALL_SIMPLE_METHOD();
    }
}
#   line 4165 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_regexpmatch2);
}

/* insn invokebuiltin(bf)(...)(val) */
INSN_ENTRY(invokebuiltin)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(invokebuiltin);
    DEBUG_ENTER_INSN("invokebuiltin");

    /* ###  Declare and assign variables. ### */
    RB_BUILTIN bf = (RB_BUILTIN)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _invokebuiltin(bf)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, bf);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN invokebuiltin
#   line 1489 "insns.def"
{
    val = vm_invoke_builtin(ec, reg_cfp, bf, STACK_ADDR_FROM_TOP(bf->argc));
}
#   line 4207 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(invokebuiltin);
}

/* insn opt_invokebuiltin_delegate(bf, index)()(val) */
INSN_ENTRY(opt_invokebuiltin_delegate)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_invokebuiltin_delegate);
    DEBUG_ENTER_INSN("opt_invokebuiltin_delegate");

    /* ###  Declare and assign variables. ### */
    RB_BUILTIN bf = (RB_BUILTIN)GET_OPERAND(1);
    rb_num_t index = (rb_num_t)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _opt_invokebuiltin_delegate(bf, index)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, bf);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, index);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_invokebuiltin_delegate
#   line 1500 "insns.def"
{
    val = vm_invoke_builtin_delegate(ec, reg_cfp, bf, (unsigned int)index);
}
#   line 4251 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_invokebuiltin_delegate);
}

/* insn opt_invokebuiltin_delegate_leave(bf, index)()(val) */
INSN_ENTRY(opt_invokebuiltin_delegate_leave)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(opt_invokebuiltin_delegate_leave);
    DEBUG_ENTER_INSN("opt_invokebuiltin_delegate_leave");

    /* ###  Declare and assign variables. ### */
    RB_BUILTIN bf = (RB_BUILTIN)GET_OPERAND(1);
    rb_num_t index = (rb_num_t)GET_OPERAND(2);
#   define INSN_ATTR(x) attr_ ## x ## _opt_invokebuiltin_delegate_leave(bf, index)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, bf);
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 1, index);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN opt_invokebuiltin_delegate_leave
#   line 1511 "insns.def"
{
    val = vm_invoke_builtin_delegate(ec, reg_cfp, bf, (unsigned int)index);

    /* leave fastpath */
    /* TracePoint/return fallbacks this insn to opt_invokebuiltin_delegate */
    if (vm_pop_frame(ec, GET_CFP(), GET_EP())) {
#   if OPT_CALL_THREADED_CODE
        rb_ec_thread_ptr(ec)->retval = val;
        return 0;
#   else
        return val;
#   endif
    }
    else {
        RESTORE_REGS();
    }
}
#   line 4309 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(opt_invokebuiltin_delegate_leave);
}

/* insn getlocal_WC_0(idx)()(val) */
INSN_ENTRY(getlocal_WC_0)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(getlocal_WC_0);
    DEBUG_ENTER_INSN("getlocal_WC_0");

    /* ###  Declare and assign variables. ### */
#line 10 "defs/opt_operand.def"
    const rb_num_t level = 0;
#line 4336 "vm.inc"
    lindex_t idx = (lindex_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _getlocal_WC_0(idx)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN getlocal_WC_0
#   line 81 "insns.def"
{
    val = *(vm_get_ep(GET_EP(), level) - idx);
    RB_DEBUG_COUNTER_INC(lvar_get);
    (void)RB_DEBUG_COUNTER_INC_IF(lvar_get_dynamic, level > 0);
}
#   line 4356 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(getlocal_WC_0);
}

/* insn getlocal_WC_1(idx)()(val) */
INSN_ENTRY(getlocal_WC_1)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(getlocal_WC_1);
    DEBUG_ENTER_INSN("getlocal_WC_1");

    /* ###  Declare and assign variables. ### */
#line 11 "defs/opt_operand.def"
    const rb_num_t level = 1;
#line 4383 "vm.inc"
    lindex_t idx = (lindex_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _getlocal_WC_1(idx)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val;

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN getlocal_WC_1
#   line 81 "insns.def"
{
    val = *(vm_get_ep(GET_EP(), level) - idx);
    RB_DEBUG_COUNTER_INC(lvar_get);
    (void)RB_DEBUG_COUNTER_INC_IF(lvar_get_dynamic, level > 0);
}
#   line 4403 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(getlocal_WC_1);
}

/* insn setlocal_WC_0(idx)(val)() */
INSN_ENTRY(setlocal_WC_0)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(setlocal_WC_0);
    DEBUG_ENTER_INSN("setlocal_WC_0");

    /* ###  Declare and assign variables. ### */
#line 12 "defs/opt_operand.def"
    const rb_num_t level = 0;
#line 4430 "vm.inc"
    lindex_t idx = (lindex_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _setlocal_WC_0(idx)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN setlocal_WC_0
#   line 95 "insns.def"
{
    vm_env_write(vm_get_ep(GET_EP(), level), -(int)idx, val);
    RB_DEBUG_COUNTER_INC(lvar_set);
    (void)RB_DEBUG_COUNTER_INC_IF(lvar_set_dynamic, level > 0);
}
#   line 4450 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(setlocal_WC_0);
}

/* insn setlocal_WC_1(idx)(val)() */
INSN_ENTRY(setlocal_WC_1)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(setlocal_WC_1);
    DEBUG_ENTER_INSN("setlocal_WC_1");

    /* ###  Declare and assign variables. ### */
#line 13 "defs/opt_operand.def"
    const rb_num_t level = 1;
#line 4474 "vm.inc"
    lindex_t idx = (lindex_t)GET_OPERAND(1);
#   define INSN_ATTR(x) attr_ ## x ## _setlocal_WC_1(idx)
    const bool leaf = INSN_ATTR(leaf);
    VALUE val = TOPN(0);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    SETUP_CANARY(leaf);
    COLLECT_USAGE_INSN(INSN_ATTR(bin));
    COLLECT_USAGE_OPERAND(INSN_ATTR(bin), 0, idx);

    /* ### Here we do the instruction body. ### */
#   define NAME_OF_CURRENT_INSN setlocal_WC_1
#   line 95 "insns.def"
{
    vm_env_write(vm_get_ep(GET_EP(), level), -(int)idx, val);
    RB_DEBUG_COUNTER_INC(lvar_set);
    (void)RB_DEBUG_COUNTER_INC_IF(lvar_set_dynamic, level > 0);
}
#   line 4494 "vm.inc"
#   undef NAME_OF_CURRENT_INSN

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    CHECK_CANARY(leaf, INSN_ATTR(bin));
    INC_SP(INSN_ATTR(sp_inc));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(setlocal_WC_1);
}

/* insn putobject_INT2FIX_0_()()(val) */
INSN_ENTRY(putobject_INT2FIX_0_)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(putobject_INT2FIX_0_);
    DEBUG_ENTER_INSN("putobject_INT2FIX_0_");

    /* ###  Declare and assign variables. ### */
#line 15 "defs/opt_operand.def"
    const VALUE val = INT2FIX(0);
#line 4518 "vm.inc"
#   define INSN_ATTR(x) attr_ ## x ## _putobject_INT2FIX_0_()
    const bool leaf = INSN_ATTR(leaf);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(putobject_INT2FIX_0_);
}

/* insn putobject_INT2FIX_1_()()(val) */
INSN_ENTRY(putobject_INT2FIX_1_)
{
    /* ###  Declare that we have just entered into an instruction. ### */
    START_OF_ORIGINAL_INSN(putobject_INT2FIX_1_);
    DEBUG_ENTER_INSN("putobject_INT2FIX_1_");

    /* ###  Declare and assign variables. ### */
#line 16 "defs/opt_operand.def"
    const VALUE val = INT2FIX(1);
#line 4549 "vm.inc"
#   define INSN_ATTR(x) attr_ ## x ## _putobject_INT2FIX_1_()
    const bool leaf = INSN_ATTR(leaf);

    /* ### Instruction preambles. ### */
    if (! leaf) ADD_PC(INSN_ATTR(width));
    COLLECT_USAGE_INSN(INSN_ATTR(bin));

    /* ### Instruction trailers. ### */
    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
    INC_SP(INSN_ATTR(sp_inc));
    TOPN(0) = val;
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_NONE));
    VM_ASSERT(!RB_TYPE_P(TOPN(0), T_MOVED));
    if (leaf) ADD_PC(INSN_ATTR(width));
#   undef INSN_ATTR

    /* ### Leave the instruction. ### */
    END_INSN(putobject_INT2FIX_1_);
}

/* insn trace_nop(...)(...)(...) */
INSN_ENTRY(trace_nop)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(nop);
    END_INSN(trace_nop);
}

/* insn trace_getlocal(...)(...)(...) */
INSN_ENTRY(trace_getlocal)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(getlocal);
    END_INSN(trace_getlocal);
}

/* insn trace_setlocal(...)(...)(...) */
INSN_ENTRY(trace_setlocal)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(setlocal);
    END_INSN(trace_setlocal);
}

/* insn trace_getblockparam(...)(...)(...) */
INSN_ENTRY(trace_getblockparam)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(getblockparam);
    END_INSN(trace_getblockparam);
}

/* insn trace_setblockparam(...)(...)(...) */
INSN_ENTRY(trace_setblockparam)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(setblockparam);
    END_INSN(trace_setblockparam);
}

/* insn trace_getblockparamproxy(...)(...)(...) */
INSN_ENTRY(trace_getblockparamproxy)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(getblockparamproxy);
    END_INSN(trace_getblockparamproxy);
}

/* insn trace_getspecial(...)(...)(...) */
INSN_ENTRY(trace_getspecial)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(getspecial);
    END_INSN(trace_getspecial);
}

/* insn trace_setspecial(...)(...)(...) */
INSN_ENTRY(trace_setspecial)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(setspecial);
    END_INSN(trace_setspecial);
}

/* insn trace_getinstancevariable(...)(...)(...) */
INSN_ENTRY(trace_getinstancevariable)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(getinstancevariable);
    END_INSN(trace_getinstancevariable);
}

/* insn trace_setinstancevariable(...)(...)(...) */
INSN_ENTRY(trace_setinstancevariable)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(setinstancevariable);
    END_INSN(trace_setinstancevariable);
}

/* insn trace_getclassvariable(...)(...)(...) */
INSN_ENTRY(trace_getclassvariable)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(getclassvariable);
    END_INSN(trace_getclassvariable);
}

/* insn trace_setclassvariable(...)(...)(...) */
INSN_ENTRY(trace_setclassvariable)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(setclassvariable);
    END_INSN(trace_setclassvariable);
}

/* insn trace_opt_getconstant_path(...)(...)(...) */
INSN_ENTRY(trace_opt_getconstant_path)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_getconstant_path);
    END_INSN(trace_opt_getconstant_path);
}

/* insn trace_getconstant(...)(...)(...) */
INSN_ENTRY(trace_getconstant)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(getconstant);
    END_INSN(trace_getconstant);
}

/* insn trace_setconstant(...)(...)(...) */
INSN_ENTRY(trace_setconstant)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(setconstant);
    END_INSN(trace_setconstant);
}

/* insn trace_getglobal(...)(...)(...) */
INSN_ENTRY(trace_getglobal)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(getglobal);
    END_INSN(trace_getglobal);
}

/* insn trace_setglobal(...)(...)(...) */
INSN_ENTRY(trace_setglobal)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(setglobal);
    END_INSN(trace_setglobal);
}

/* insn trace_putnil(...)(...)(...) */
INSN_ENTRY(trace_putnil)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(putnil);
    END_INSN(trace_putnil);
}

/* insn trace_putself(...)(...)(...) */
INSN_ENTRY(trace_putself)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(putself);
    END_INSN(trace_putself);
}

/* insn trace_putobject(...)(...)(...) */
INSN_ENTRY(trace_putobject)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(putobject);
    END_INSN(trace_putobject);
}

/* insn trace_putspecialobject(...)(...)(...) */
INSN_ENTRY(trace_putspecialobject)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(putspecialobject);
    END_INSN(trace_putspecialobject);
}

/* insn trace_putstring(...)(...)(...) */
INSN_ENTRY(trace_putstring)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(putstring);
    END_INSN(trace_putstring);
}

/* insn trace_concatstrings(...)(...)(...) */
INSN_ENTRY(trace_concatstrings)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(concatstrings);
    END_INSN(trace_concatstrings);
}

/* insn trace_anytostring(...)(...)(...) */
INSN_ENTRY(trace_anytostring)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(anytostring);
    END_INSN(trace_anytostring);
}

/* insn trace_toregexp(...)(...)(...) */
INSN_ENTRY(trace_toregexp)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(toregexp);
    END_INSN(trace_toregexp);
}

/* insn trace_intern(...)(...)(...) */
INSN_ENTRY(trace_intern)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(intern);
    END_INSN(trace_intern);
}

/* insn trace_newarray(...)(...)(...) */
INSN_ENTRY(trace_newarray)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(newarray);
    END_INSN(trace_newarray);
}

/* insn trace_newarraykwsplat(...)(...)(...) */
INSN_ENTRY(trace_newarraykwsplat)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(newarraykwsplat);
    END_INSN(trace_newarraykwsplat);
}

/* insn trace_duparray(...)(...)(...) */
INSN_ENTRY(trace_duparray)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(duparray);
    END_INSN(trace_duparray);
}

/* insn trace_duphash(...)(...)(...) */
INSN_ENTRY(trace_duphash)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(duphash);
    END_INSN(trace_duphash);
}

/* insn trace_expandarray(...)(...)(...) */
INSN_ENTRY(trace_expandarray)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(expandarray);
    END_INSN(trace_expandarray);
}

/* insn trace_concatarray(...)(...)(...) */
INSN_ENTRY(trace_concatarray)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(concatarray);
    END_INSN(trace_concatarray);
}

/* insn trace_splatarray(...)(...)(...) */
INSN_ENTRY(trace_splatarray)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(splatarray);
    END_INSN(trace_splatarray);
}

/* insn trace_newhash(...)(...)(...) */
INSN_ENTRY(trace_newhash)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(newhash);
    END_INSN(trace_newhash);
}

/* insn trace_newrange(...)(...)(...) */
INSN_ENTRY(trace_newrange)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(newrange);
    END_INSN(trace_newrange);
}

/* insn trace_pop(...)(...)(...) */
INSN_ENTRY(trace_pop)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(pop);
    END_INSN(trace_pop);
}

/* insn trace_dup(...)(...)(...) */
INSN_ENTRY(trace_dup)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(dup);
    END_INSN(trace_dup);
}

/* insn trace_dupn(...)(...)(...) */
INSN_ENTRY(trace_dupn)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(dupn);
    END_INSN(trace_dupn);
}

/* insn trace_swap(...)(...)(...) */
INSN_ENTRY(trace_swap)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(swap);
    END_INSN(trace_swap);
}

/* insn trace_opt_reverse(...)(...)(...) */
INSN_ENTRY(trace_opt_reverse)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_reverse);
    END_INSN(trace_opt_reverse);
}

/* insn trace_topn(...)(...)(...) */
INSN_ENTRY(trace_topn)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(topn);
    END_INSN(trace_topn);
}

/* insn trace_setn(...)(...)(...) */
INSN_ENTRY(trace_setn)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(setn);
    END_INSN(trace_setn);
}

/* insn trace_adjuststack(...)(...)(...) */
INSN_ENTRY(trace_adjuststack)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(adjuststack);
    END_INSN(trace_adjuststack);
}

/* insn trace_defined(...)(...)(...) */
INSN_ENTRY(trace_defined)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(defined);
    END_INSN(trace_defined);
}

/* insn trace_checkmatch(...)(...)(...) */
INSN_ENTRY(trace_checkmatch)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(checkmatch);
    END_INSN(trace_checkmatch);
}

/* insn trace_checkkeyword(...)(...)(...) */
INSN_ENTRY(trace_checkkeyword)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(checkkeyword);
    END_INSN(trace_checkkeyword);
}

/* insn trace_checktype(...)(...)(...) */
INSN_ENTRY(trace_checktype)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(checktype);
    END_INSN(trace_checktype);
}

/* insn trace_defineclass(...)(...)(...) */
INSN_ENTRY(trace_defineclass)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(defineclass);
    END_INSN(trace_defineclass);
}

/* insn trace_definemethod(...)(...)(...) */
INSN_ENTRY(trace_definemethod)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(definemethod);
    END_INSN(trace_definemethod);
}

/* insn trace_definesmethod(...)(...)(...) */
INSN_ENTRY(trace_definesmethod)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(definesmethod);
    END_INSN(trace_definesmethod);
}

/* insn trace_send(...)(...)(...) */
INSN_ENTRY(trace_send)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(send);
    END_INSN(trace_send);
}

/* insn trace_opt_send_without_block(...)(...)(...) */
INSN_ENTRY(trace_opt_send_without_block)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_send_without_block);
}

/* insn trace_objtostring(...)(...)(...) */
INSN_ENTRY(trace_objtostring)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(objtostring);
    END_INSN(trace_objtostring);
}

/* insn trace_opt_str_freeze(...)(...)(...) */
INSN_ENTRY(trace_opt_str_freeze)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_str_freeze);
    END_INSN(trace_opt_str_freeze);
}

/* insn trace_opt_nil_p(...)(...)(...) */
INSN_ENTRY(trace_opt_nil_p)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_nil_p);
}

/* insn trace_opt_str_uminus(...)(...)(...) */
INSN_ENTRY(trace_opt_str_uminus)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_str_uminus);
    END_INSN(trace_opt_str_uminus);
}

/* insn trace_opt_newarray_max(...)(...)(...) */
INSN_ENTRY(trace_opt_newarray_max)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_newarray_max);
    END_INSN(trace_opt_newarray_max);
}

/* insn trace_opt_newarray_min(...)(...)(...) */
INSN_ENTRY(trace_opt_newarray_min)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_newarray_min);
    END_INSN(trace_opt_newarray_min);
}

/* insn trace_invokesuper(...)(...)(...) */
INSN_ENTRY(trace_invokesuper)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(invokesuper);
    END_INSN(trace_invokesuper);
}

/* insn trace_invokeblock(...)(...)(...) */
INSN_ENTRY(trace_invokeblock)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(invokeblock);
    END_INSN(trace_invokeblock);
}

/* insn trace_leave(...)(...)(...) */
INSN_ENTRY(trace_leave)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(leave);
    END_INSN(trace_leave);
}

/* insn trace_throw(...)(...)(...) */
INSN_ENTRY(trace_throw)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(throw);
    END_INSN(trace_throw);
}

/* insn trace_jump(...)(...)(...) */
INSN_ENTRY(trace_jump)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(jump);
    END_INSN(trace_jump);
}

/* insn trace_branchif(...)(...)(...) */
INSN_ENTRY(trace_branchif)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(branchif);
    END_INSN(trace_branchif);
}

/* insn trace_branchunless(...)(...)(...) */
INSN_ENTRY(trace_branchunless)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(branchunless);
    END_INSN(trace_branchunless);
}

/* insn trace_branchnil(...)(...)(...) */
INSN_ENTRY(trace_branchnil)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(branchnil);
    END_INSN(trace_branchnil);
}

/* insn trace_once(...)(...)(...) */
INSN_ENTRY(trace_once)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(once);
    END_INSN(trace_once);
}

/* insn trace_opt_case_dispatch(...)(...)(...) */
INSN_ENTRY(trace_opt_case_dispatch)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_case_dispatch);
    END_INSN(trace_opt_case_dispatch);
}

/* insn trace_opt_plus(...)(...)(...) */
INSN_ENTRY(trace_opt_plus)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_plus);
}

/* insn trace_opt_minus(...)(...)(...) */
INSN_ENTRY(trace_opt_minus)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_minus);
}

/* insn trace_opt_mult(...)(...)(...) */
INSN_ENTRY(trace_opt_mult)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_mult);
}

/* insn trace_opt_div(...)(...)(...) */
INSN_ENTRY(trace_opt_div)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_div);
}

/* insn trace_opt_mod(...)(...)(...) */
INSN_ENTRY(trace_opt_mod)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_mod);
}

/* insn trace_opt_eq(...)(...)(...) */
INSN_ENTRY(trace_opt_eq)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_eq);
}

/* insn trace_opt_neq(...)(...)(...) */
INSN_ENTRY(trace_opt_neq)
{
    vm_trace(ec, GET_CFP());
    ADD_PC(1);
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_neq);
}

/* insn trace_opt_lt(...)(...)(...) */
INSN_ENTRY(trace_opt_lt)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_lt);
}

/* insn trace_opt_le(...)(...)(...) */
INSN_ENTRY(trace_opt_le)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_le);
}

/* insn trace_opt_gt(...)(...)(...) */
INSN_ENTRY(trace_opt_gt)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_gt);
}

/* insn trace_opt_ge(...)(...)(...) */
INSN_ENTRY(trace_opt_ge)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_ge);
}

/* insn trace_opt_ltlt(...)(...)(...) */
INSN_ENTRY(trace_opt_ltlt)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_ltlt);
}

/* insn trace_opt_and(...)(...)(...) */
INSN_ENTRY(trace_opt_and)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_and);
}

/* insn trace_opt_or(...)(...)(...) */
INSN_ENTRY(trace_opt_or)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_or);
}

/* insn trace_opt_aref(...)(...)(...) */
INSN_ENTRY(trace_opt_aref)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_aref);
}

/* insn trace_opt_aset(...)(...)(...) */
INSN_ENTRY(trace_opt_aset)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_aset);
}

/* insn trace_opt_aset_with(...)(...)(...) */
INSN_ENTRY(trace_opt_aset_with)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_aset_with);
    END_INSN(trace_opt_aset_with);
}

/* insn trace_opt_aref_with(...)(...)(...) */
INSN_ENTRY(trace_opt_aref_with)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_aref_with);
    END_INSN(trace_opt_aref_with);
}

/* insn trace_opt_length(...)(...)(...) */
INSN_ENTRY(trace_opt_length)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_length);
}

/* insn trace_opt_size(...)(...)(...) */
INSN_ENTRY(trace_opt_size)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_size);
}

/* insn trace_opt_empty_p(...)(...)(...) */
INSN_ENTRY(trace_opt_empty_p)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_empty_p);
}

/* insn trace_opt_succ(...)(...)(...) */
INSN_ENTRY(trace_opt_succ)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_succ);
}

/* insn trace_opt_not(...)(...)(...) */
INSN_ENTRY(trace_opt_not)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_not);
}

/* insn trace_opt_regexpmatch2(...)(...)(...) */
INSN_ENTRY(trace_opt_regexpmatch2)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_send_without_block);
    END_INSN(trace_opt_regexpmatch2);
}

/* insn trace_invokebuiltin(...)(...)(...) */
INSN_ENTRY(trace_invokebuiltin)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(invokebuiltin);
    END_INSN(trace_invokebuiltin);
}

/* insn trace_opt_invokebuiltin_delegate(...)(...)(...) */
INSN_ENTRY(trace_opt_invokebuiltin_delegate)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_invokebuiltin_delegate);
    END_INSN(trace_opt_invokebuiltin_delegate);
}

/* insn trace_opt_invokebuiltin_delegate_leave(...)(...)(...) */
INSN_ENTRY(trace_opt_invokebuiltin_delegate_leave)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(opt_invokebuiltin_delegate_leave);
    END_INSN(trace_opt_invokebuiltin_delegate_leave);
}

/* insn trace_getlocal_WC_0(...)(...)(...) */
INSN_ENTRY(trace_getlocal_WC_0)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(getlocal_WC_0);
    END_INSN(trace_getlocal_WC_0);
}

/* insn trace_getlocal_WC_1(...)(...)(...) */
INSN_ENTRY(trace_getlocal_WC_1)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(getlocal_WC_1);
    END_INSN(trace_getlocal_WC_1);
}

/* insn trace_setlocal_WC_0(...)(...)(...) */
INSN_ENTRY(trace_setlocal_WC_0)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(setlocal_WC_0);
    END_INSN(trace_setlocal_WC_0);
}

/* insn trace_setlocal_WC_1(...)(...)(...) */
INSN_ENTRY(trace_setlocal_WC_1)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(setlocal_WC_1);
    END_INSN(trace_setlocal_WC_1);
}

/* insn trace_putobject_INT2FIX_0_(...)(...)(...) */
INSN_ENTRY(trace_putobject_INT2FIX_0_)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(putobject_INT2FIX_0_);
    END_INSN(trace_putobject_INT2FIX_0_);
}

/* insn trace_putobject_INT2FIX_1_(...)(...)(...) */
INSN_ENTRY(trace_putobject_INT2FIX_1_)
{
    vm_trace(ec, GET_CFP());
    
    DISPATCH_ORIGINAL_INSN(putobject_INT2FIX_1_);
    END_INSN(trace_putobject_INT2FIX_1_);
}
