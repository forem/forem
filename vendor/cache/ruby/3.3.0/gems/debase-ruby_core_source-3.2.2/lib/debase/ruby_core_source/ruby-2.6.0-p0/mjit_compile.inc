/* -*- mode:c; style:ruby; coding: utf-8; indent-tabs-mode: nil -*- */

/* This is  an auto-generated file  and is a  part of the  programming language
 * Ruby.  The  person who  created  a  program  to  generate this  file  (``I''
 * hereafter) would like  to refrain from defining licensing  of this generated
 * source code.
 *
 * This file consist of many small  parts of codes copyrighted by each authors,
 * not  only  the  ``I''  person.   Those  original  authors  agree  with  some
 * open-source license.  I  believe that the license we agree  is the condition
 * mentioned in  the file COPYING.  It  states "4.  You may  modify and include
 * the part of the software into any  other software ...".  But the problem is,
 * the license never makes it clear if  such modified parts still remain in the
 * same  license, or  not.   The fact  that  we agree  with  the source  code's
 * licensing terms do not automatically define that of generated ones.  This is
 * the reason  why this file  is under unclear situation.   All that I  know is
 * that above provision guarantees this file to exist.
 *
 * Please let me  hesitate to declare something about this  nuanced contract. I
 * am not in the position to take  over other authors' license to merge into my
 * one.  Changing them to (say) GPLv3  is not doable by myself. Perhaps someday
 * it might turn out to be okay to say this file is under a license. I wish the
 * situation would become more clear in the future. */

/*******************************************************************/
/*******************************************************************/
/*******************************************************************/
/**
  This file is the main part of compile_insn() in mjit_compile.c.

  ----
  This file is auto generated by insns2vm.rb
  DO NOT TOUCH!

  If you want to fix something, you must edit "tool/ruby_vm/views/mjit_compile.inc.erb"
  or tool/insns2vm.rb
 */

switch (insn) {
  case BIN(nop):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }

        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        /* none */\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_nop();
    }
    fprintf(f, "}\n");
    break;
  case BIN(getlocal):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(lindex_t idx) = (lindex_t)operands[0];
        MAYBE_UNUSED(rb_num_t level) = (rb_num_t)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");
        fprintf(f, "    MAYBE_UNUSED(lindex_t) idx;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) level;\n");

        fprintf(f, "    idx = (lindex_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    level = (rb_num_t)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = *(vm_get_ep(GET_EP(), level) - idx);\n");
        fprintf(f, "        RB_DEBUG_COUNTER_INC(lvar_get);\n");
        fprintf(f, "        (void)RB_DEBUG_COUNTER_INC_IF(lvar_get_dynamic, level > 0);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_getlocal(idx, level) - 1);
        b->stack_size += attr_sp_inc_getlocal(idx, level);
    }
    fprintf(f, "}\n");
    break;
  case BIN(setlocal):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(lindex_t idx) = (lindex_t)operands[0];
        MAYBE_UNUSED(rb_num_t level) = (rb_num_t)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");
        fprintf(f, "    MAYBE_UNUSED(lindex_t) idx;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) level;\n");

        fprintf(f, "    idx = (lindex_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    level = (rb_num_t)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    val = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        vm_env_write(vm_get_ep(GET_EP(), level), -(int)idx, val);\n");
        fprintf(f, "        RB_DEBUG_COUNTER_INC(lvar_set);\n");
        fprintf(f, "        (void)RB_DEBUG_COUNTER_INC_IF(lvar_set_dynamic, level > 0);\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_setlocal(idx, level);
    }
    fprintf(f, "}\n");
    break;
  case BIN(getblockparam):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(lindex_t idx) = (lindex_t)operands[0];
        MAYBE_UNUSED(rb_num_t level) = (rb_num_t)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");
        fprintf(f, "    MAYBE_UNUSED(lindex_t) idx;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) level;\n");

        fprintf(f, "    idx = (lindex_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    level = (rb_num_t)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        const VALUE *ep = vm_get_ep(GET_EP(), level);\n");
        fprintf(f, "        VM_ASSERT(VM_ENV_LOCAL_P(ep));\n");
        fprintf(f, "\n");
        fprintf(f, "        if (!VM_ENV_FLAGS(ep, VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM)) {\n");
        fprintf(f, "            val = rb_vm_bh_to_procval(ec, VM_ENV_BLOCK_HANDLER(ep));\n");
        fprintf(f, "            vm_env_write(ep, -(int)idx, val);\n");
        fprintf(f, "            VM_ENV_FLAGS_SET(ep, VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM);\n");
        fprintf(f, "        }\n");
        fprintf(f, "        else {\n");
        fprintf(f, "            val = *(ep - idx);\n");
        fprintf(f, "            RB_DEBUG_COUNTER_INC(lvar_get);\n");
        fprintf(f, "            (void)RB_DEBUG_COUNTER_INC_IF(lvar_get_dynamic, level > 0);\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_getblockparam(idx, level) - 1);
        b->stack_size += attr_sp_inc_getblockparam(idx, level);
    }
    fprintf(f, "}\n");
    break;
  case BIN(setblockparam):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(lindex_t idx) = (lindex_t)operands[0];
        MAYBE_UNUSED(rb_num_t level) = (rb_num_t)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");
        fprintf(f, "    MAYBE_UNUSED(lindex_t) idx;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) level;\n");

        fprintf(f, "    idx = (lindex_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    level = (rb_num_t)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    val = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        const VALUE *ep = vm_get_ep(GET_EP(), level);\n");
        fprintf(f, "        VM_ASSERT(VM_ENV_LOCAL_P(ep));\n");
        fprintf(f, "\n");
        fprintf(f, "        vm_env_write(ep, -(int)idx, val);\n");
        fprintf(f, "        RB_DEBUG_COUNTER_INC(lvar_set);\n");
        fprintf(f, "        (void)RB_DEBUG_COUNTER_INC_IF(lvar_set_dynamic, level > 0);\n");
        fprintf(f, "\n");
        fprintf(f, "        VM_ENV_FLAGS_SET(ep, VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM);\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_setblockparam(idx, level);
    }
    fprintf(f, "}\n");
    break;
  case BIN(getspecial):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(rb_num_t key) = (rb_num_t)operands[0];
        MAYBE_UNUSED(rb_num_t type) = (rb_num_t)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) key, type;\n");

        fprintf(f, "    key = (rb_num_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    type = (rb_num_t)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_getspecial(ec, GET_LEP(), key, type);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_getspecial(key, type) - 1);
        b->stack_size += attr_sp_inc_getspecial(key, type);
    }
    fprintf(f, "}\n");
    break;
  case BIN(setspecial):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(rb_num_t key) = (rb_num_t)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) obj;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) key;\n");

        fprintf(f, "    key = (rb_num_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    obj = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        lep_svar_set(ec, GET_LEP(), key, obj);\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_setspecial(key);
    }
    fprintf(f, "}\n");
    break;
  case BIN(getinstancevariable):
#if OPT_IC_FOR_IVAR
{
    MAYBE_UNUSED(ID id) = (ID)operands[0];
    MAYBE_UNUSED(IC ic) = (IC)operands[1];
    IC ic_copy = &(status->is_entries + ((union iseq_inline_storage_entry *)ic - body->is_entries))->cache;
    if (ic_copy->ic_serial) {
        fprintf(f, "{\n");
        fprintf(f, "    VALUE obj = GET_SELF();\n");
        fprintf(f, "    const rb_serial_t ic_serial = (rb_serial_t)%"PRI_SERIALT_PREFIX"u;\n", ic_copy->ic_serial);
        fprintf(f, "    const st_index_t index = %"PRIuSIZE";\n", ic_copy->ic_value.index);
        fprintf(f, "    VALUE val;\n");
        fprintf(f, "    if (LIKELY(RB_TYPE_P(obj, T_OBJECT) && ic_serial == RCLASS_SERIAL(RBASIC(obj)->klass) && index < ROBJECT_NUMIV(obj) && (val = ROBJECT_IVPTR(obj)[index]) != Qundef)) {\n");
        fprintf(f, "        stack[%d] = val;\n", b->stack_size);
        fprintf(f, "    }\n");
        fprintf(f, "    else {\n");
        fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");

        b->stack_size += attr_sp_inc_getinstancevariable(id, ic);
        fprintf(f, "}\n");
        break;
    }
}
#endif /* OPT_IC_FOR_IVAR */
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(ID id) = (ID)operands[0];
        MAYBE_UNUSED(IC ic) = (IC)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(IC) ic;\n");
        fprintf(f, "    MAYBE_UNUSED(ID) id;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        fprintf(f, "    id = (ID)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, (ID)operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    ic = (IC)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_getinstancevariable(GET_SELF(), id, ic);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_getinstancevariable(id, ic) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_getinstancevariable(id, ic) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_getinstancevariable(id, ic);
    }
    fprintf(f, "}\n");
    break;
  case BIN(setinstancevariable):
#if OPT_IC_FOR_IVAR
{
    MAYBE_UNUSED(ID id) = (ID)operands[0];
    MAYBE_UNUSED(IC ic) = (IC)operands[1];
    IC ic_copy = &(status->is_entries + ((union iseq_inline_storage_entry *)ic - body->is_entries))->cache;
    if (ic_copy->ic_serial) {
        fprintf(f, "{\n");
        fprintf(f, "    VALUE obj = GET_SELF();\n");
        fprintf(f, "    const rb_serial_t ic_serial = (rb_serial_t)%"PRI_SERIALT_PREFIX"u;\n", ic_copy->ic_serial);
        fprintf(f, "    const st_index_t index = %"PRIuSIZE";\n", ic_copy->ic_value.index);
        fprintf(f, "    VALUE val = stack[%d];\n", b->stack_size - 1);
        fprintf(f, "    if (LIKELY(RB_TYPE_P(obj, T_OBJECT) && ic_serial == RCLASS_SERIAL(RBASIC(obj)->klass) && index < ROBJECT_NUMIV(obj))) {\n");
        fprintf(f, "        VALUE *ptr = ROBJECT_IVPTR(obj);\n");
        fprintf(f, "        RB_OBJ_WRITE(obj, &ptr[index], val);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    else {\n");
        fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");

        b->stack_size += attr_sp_inc_setinstancevariable(id, ic);
        fprintf(f, "}\n");
        break;
    }
}
#endif /* OPT_IC_FOR_IVAR */
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(ID id) = (ID)operands[0];
        MAYBE_UNUSED(IC ic) = (IC)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(IC) ic;\n");
        fprintf(f, "    MAYBE_UNUSED(ID) id;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        fprintf(f, "    id = (ID)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, (ID)operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    ic = (IC)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    val = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        vm_setinstancevariable(GET_SELF(), id, val, ic);\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_setinstancevariable(id, ic);
    }
    fprintf(f, "}\n");
    break;
  case BIN(getclassvariable):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(ID id) = (ID)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(ID) id;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        fprintf(f, "    id = (ID)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, (ID)operands[0]);
        fprintf(f, "\n");
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = rb_cvar_get(vm_get_cvar_base(rb_vm_get_cref(GET_EP()), GET_CFP()), id);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_getclassvariable(id) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_getclassvariable(id) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_getclassvariable(id);
    }
    fprintf(f, "}\n");
    break;
  case BIN(setclassvariable):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(ID id) = (ID)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(ID) id;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        fprintf(f, "    id = (ID)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, (ID)operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    val = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        vm_ensure_not_refinement_module(GET_SELF());\n");
        fprintf(f, "        rb_cvar_set(vm_get_cvar_base(rb_vm_get_cref(GET_EP()), GET_CFP()), id, val);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_setclassvariable(id) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_setclassvariable(id);
    }
    fprintf(f, "}\n");
    break;
  case BIN(getconstant):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(ID id) = (ID)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(ID) id;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) klass, val;\n");

        fprintf(f, "    id = (ID)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, (ID)operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    klass = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_get_ev_const(ec, klass, id, 0);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_getconstant(id) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_getconstant(id) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_getconstant(id);
    }
    fprintf(f, "}\n");
    break;
  case BIN(setconstant):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(ID id) = (ID)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(ID) id;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) cbase, val;\n");

        fprintf(f, "    id = (ID)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, (ID)operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    val = stack[%d];\n", b->stack_size - 2);
        fprintf(f, "    cbase = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        vm_check_if_namespace(cbase);\n");
        fprintf(f, "        vm_ensure_not_refinement_module(GET_SELF());\n");
        fprintf(f, "        rb_const_set(cbase, id, val);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_setconstant(id) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_setconstant(id);
    }
    fprintf(f, "}\n");
    break;
  case BIN(getglobal):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(GENTRY entry) = (GENTRY)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(GENTRY) entry;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        fprintf(f, "    entry = (GENTRY)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = GET_GLOBAL((VALUE)entry);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_getglobal(entry) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_getglobal(entry) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_getglobal(entry);
    }
    fprintf(f, "}\n");
    break;
  case BIN(setglobal):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(GENTRY entry) = (GENTRY)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(GENTRY) entry;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        fprintf(f, "    entry = (GENTRY)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    val = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        SET_GLOBAL((VALUE)entry, val);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_setglobal(entry) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_setglobal(entry);
    }
    fprintf(f, "}\n");
    break;
  case BIN(putnil):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = Qnil;\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_putnil() - 1);
        b->stack_size += attr_sp_inc_putnil();
    }
    fprintf(f, "}\n");
    break;
  case BIN(putself):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = GET_SELF();\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_putself() - 1);
        b->stack_size += attr_sp_inc_putself();
    }
    fprintf(f, "}\n");
    break;
  case BIN(putobject):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(VALUE val) = (VALUE)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        fprintf(f, "    val = (VALUE)0x%"PRIxVALUE";", operands[0]);
        if (SYMBOL_P((VALUE)operands[0])) comment_id(f, SYM2ID((VALUE)operands[0]));
        fprintf(f, "\n");
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        /* */\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_putobject(val) - 1);
        b->stack_size += attr_sp_inc_putobject(val);
    }
    fprintf(f, "}\n");
    break;
  case BIN(putspecialobject):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(rb_num_t value_type) = (rb_num_t)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) value_type;\n");

        fprintf(f, "    value_type = (rb_num_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        enum vm_special_object_type type;\n");
        fprintf(f, "\n");
        fprintf(f, "        type = (enum vm_special_object_type)value_type;\n");
        fprintf(f, "        val = vm_get_special_object(GET_EP(), type);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_putspecialobject(value_type) - 1);
        b->stack_size += attr_sp_inc_putspecialobject(value_type);
    }
    fprintf(f, "}\n");
    break;
  case BIN(putiseq):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(ISEQ iseq) = (ISEQ)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(ISEQ) iseq;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) ret;\n");

        fprintf(f, "    iseq = (ISEQ)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        ret = (VALUE)iseq;\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = ret;\n", b->stack_size + (int)attr_sp_inc_putiseq(iseq) - 1);
        b->stack_size += attr_sp_inc_putiseq(iseq);
    }
    fprintf(f, "}\n");
    break;
  case BIN(putstring):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(VALUE str) = (VALUE)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) str, val;\n");

        fprintf(f, "    str = (VALUE)0x%"PRIxVALUE";", operands[0]);
        if (SYMBOL_P((VALUE)operands[0])) comment_id(f, SYM2ID((VALUE)operands[0]));
        fprintf(f, "\n");
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = rb_str_resurrect(str);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_putstring(str) - 1);
        b->stack_size += attr_sp_inc_putstring(str);
    }
    fprintf(f, "}\n");
    break;
  case BIN(concatstrings):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(rb_num_t num) = (rb_num_t)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) num;\n");

        fprintf(f, "    num = (rb_num_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = rb_str_concat_literals(num, %s);\n",
                (status->local_stack_p ? "stack + (stack_size - (num))" : "STACK_ADDR_FROM_TOP(num)"));
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_concatstrings(num) - 1);
        b->stack_size += attr_sp_inc_concatstrings(num);
    }
    fprintf(f, "}\n");
    break;
  case BIN(tostring):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) str, val;\n");

        fprintf(f, "    val = stack[%d];\n", b->stack_size - 2);
        fprintf(f, "    str = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = rb_obj_as_string_result(str, val);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_tostring() - 1);
        b->stack_size += attr_sp_inc_tostring();
    }
    fprintf(f, "}\n");
    break;
  case BIN(freezestring):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(VALUE debug_info) = (VALUE)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) debug_info, str;\n");

        fprintf(f, "    debug_info = (VALUE)0x%"PRIxVALUE";", operands[0]);
        if (SYMBOL_P((VALUE)operands[0])) comment_id(f, SYM2ID((VALUE)operands[0]));
        fprintf(f, "\n");
        fprintf(f, "    str = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        vm_freezestring(str, debug_info);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = str;\n", b->stack_size + (int)attr_sp_inc_freezestring(debug_info) - 1);
        b->stack_size += attr_sp_inc_freezestring(debug_info);
    }
    fprintf(f, "}\n");
    break;
  case BIN(toregexp):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(rb_num_t opt) = (rb_num_t)operands[0];
        MAYBE_UNUSED(rb_num_t cnt) = (rb_num_t)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) cnt, opt;\n");

        fprintf(f, "    opt = (rb_num_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    cnt = (rb_num_t)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        const VALUE ary = rb_ary_tmp_new_from_values(0, cnt, %s);\n",
                (status->local_stack_p ? "stack + (stack_size - (cnt))" : "STACK_ADDR_FROM_TOP(cnt)"));
        fprintf(f, "        val = rb_reg_new_ary(ary, (int)opt);\n");
        fprintf(f, "        rb_ary_clear(ary);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_toregexp(opt, cnt) - 1);
        b->stack_size += attr_sp_inc_toregexp(opt, cnt);
    }
    fprintf(f, "}\n");
    break;
  case BIN(intern):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) str, sym;\n");

        fprintf(f, "    str = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        sym = rb_str_intern(str);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = sym;\n", b->stack_size + (int)attr_sp_inc_intern() - 1);
        b->stack_size += attr_sp_inc_intern();
    }
    fprintf(f, "}\n");
    break;
  case BIN(newarray):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(rb_num_t num) = (rb_num_t)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) num;\n");

        fprintf(f, "    num = (rb_num_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = rb_ary_new4(num, %s);\n",
                (status->local_stack_p ? "stack + (stack_size - (num))" : "STACK_ADDR_FROM_TOP(num)"));
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_newarray(num) - 1);
        b->stack_size += attr_sp_inc_newarray(num);
    }
    fprintf(f, "}\n");
    break;
  case BIN(duparray):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(VALUE ary) = (VALUE)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) ary, val;\n");

        fprintf(f, "    ary = (VALUE)0x%"PRIxVALUE";", operands[0]);
        if (SYMBOL_P((VALUE)operands[0])) comment_id(f, SYM2ID((VALUE)operands[0]));
        fprintf(f, "\n");
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = rb_ary_resurrect(ary);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_duparray(ary) - 1);
        b->stack_size += attr_sp_inc_duparray(ary);
    }
    fprintf(f, "}\n");
    break;
  case BIN(duphash):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(VALUE hash) = (VALUE)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) hash, val;\n");

        fprintf(f, "    hash = (VALUE)0x%"PRIxVALUE";", operands[0]);
        if (SYMBOL_P((VALUE)operands[0])) comment_id(f, SYM2ID((VALUE)operands[0]));
        fprintf(f, "\n");
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = rb_hash_resurrect(hash);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_duphash(hash) - 1);
        b->stack_size += attr_sp_inc_duphash(hash);
    }
    fprintf(f, "}\n");
    break;
  case BIN(expandarray):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(rb_num_t num) = (rb_num_t)operands[0];
        MAYBE_UNUSED(rb_num_t flag) = (rb_num_t)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) ary;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) flag, num;\n");

        fprintf(f, "    num = (rb_num_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    flag = (rb_num_t)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    ary = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        vm_expandarray(%s, ary, num, (int)flag);\n", (status->local_stack_p ? "(stack + stack_size)" : "GET_SP()"));
        fprintf(f, "    }\n");
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_expandarray(num, flag) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_expandarray(num, flag);
    }
    fprintf(f, "}\n");
    break;
  case BIN(concatarray):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) ary, ary1, ary2;\n");

        fprintf(f, "    ary1 = stack[%d];\n", b->stack_size - 2);
        fprintf(f, "    ary2 = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        ary = vm_concat_array(ary1, ary2);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = ary;\n", b->stack_size + (int)attr_sp_inc_concatarray() - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_concatarray() + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_concatarray();
    }
    fprintf(f, "}\n");
    break;
  case BIN(splatarray):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(VALUE flag) = (VALUE)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) ary, flag, obj;\n");

        fprintf(f, "    flag = (VALUE)0x%"PRIxVALUE";", operands[0]);
        if (SYMBOL_P((VALUE)operands[0])) comment_id(f, SYM2ID((VALUE)operands[0]));
        fprintf(f, "\n");
        fprintf(f, "    ary = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        obj = vm_splat_array(flag, ary);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = obj;\n", b->stack_size + (int)attr_sp_inc_splatarray(flag) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_splatarray(flag) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_splatarray(flag);
    }
    fprintf(f, "}\n");
    break;
  case BIN(newhash):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(rb_num_t num) = (rb_num_t)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) num;\n");

        fprintf(f, "    num = (rb_num_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        RUBY_DTRACE_CREATE_HOOK(HASH, num);\n");
        fprintf(f, "\n");
        fprintf(f, "        val = rb_hash_new_with_size(num / 2);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (num) {\n");
        fprintf(f, "            rb_hash_bulk_insert(num, %s, val);\n",
                (status->local_stack_p ? "stack + (stack_size - (num))" : "STACK_ADDR_FROM_TOP(num)"));
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_newhash(num) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_newhash(num) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_newhash(num);
    }
    fprintf(f, "}\n");
    break;
  case BIN(newrange):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(rb_num_t flag) = (rb_num_t)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) high, low, val;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) flag;\n");

        fprintf(f, "    flag = (rb_num_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    low = stack[%d];\n", b->stack_size - 2);
        fprintf(f, "    high = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = rb_range_new(low, high, (int)flag);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_newrange(flag) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_newrange(flag) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_newrange(flag);
    }
    fprintf(f, "}\n");
    break;
  case BIN(pop):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        fprintf(f, "    val = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        (void)val;\n");
        fprintf(f, "        /* none */\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_pop();
    }
    fprintf(f, "}\n");
    break;
  case BIN(dup):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val, val1, val2;\n");

        fprintf(f, "    val = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val1 = val2 = val;\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val2;\n", b->stack_size + (int)attr_sp_inc_dup() - 1);
        fprintf(f, "    stack[%d] = val1;\n", b->stack_size + (int)attr_sp_inc_dup() - 2);
        b->stack_size += attr_sp_inc_dup();
    }
    fprintf(f, "}\n");
    break;
  case BIN(dupn):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(rb_num_t n) = (rb_num_t)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) n;\n");

        fprintf(f, "    n = (rb_num_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        void *dst = %s;\n", (status->local_stack_p ? "(stack + stack_size)" : "GET_SP()"));
        fprintf(f, "        void *src = %s;\n",
                (status->local_stack_p ? "stack + (stack_size - (n))" : "STACK_ADDR_FROM_TOP(n)"));
        fprintf(f, "\n");
        fprintf(f, "        MEMCPY(dst, src, VALUE, n);\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_dupn(n);
    }
    fprintf(f, "}\n");
    break;
  case BIN(swap):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) obj, val;\n");

        fprintf(f, "    val = stack[%d];\n", b->stack_size - 2);
        fprintf(f, "    obj = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        /* none */\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_swap() - 1);
        fprintf(f, "    stack[%d] = obj;\n", b->stack_size + (int)attr_sp_inc_swap() - 2);
        b->stack_size += attr_sp_inc_swap();
    }
    fprintf(f, "}\n");
    break;
  case BIN(reverse):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(rb_num_t n) = (rb_num_t)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) n;\n");

        fprintf(f, "    n = (rb_num_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        rb_num_t i;\n");
        fprintf(f, "        VALUE *sp = %s;\n",
                (status->local_stack_p ? "stack + (stack_size - (n))" : "STACK_ADDR_FROM_TOP(n)"));
        fprintf(f, "\n");
        fprintf(f, "        for (i=0; i<n/2; i++) {\n");
        fprintf(f, "            VALUE v0 = sp[i];\n");
        fprintf(f, "            VALUE v1 = %s;\n",
              (status->local_stack_p ? "*(stack + (stack_size - (i) - 1))" : "TOPN(i)"));
        fprintf(f, "            sp[i] = v1;\n");
        fprintf(f, "            %s = v0;\n",
              (status->local_stack_p ? "*(stack + (stack_size - (i) - 1))" : "TOPN(i)"));
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_reverse(n);
    }
    fprintf(f, "}\n");
    break;
  case BIN(reput):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        fprintf(f, "    val = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        /* none */\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_reput() - 1);
        b->stack_size += attr_sp_inc_reput();
    }
    fprintf(f, "}\n");
    break;
  case BIN(topn):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(rb_num_t n) = (rb_num_t)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) n;\n");

        fprintf(f, "    n = (rb_num_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = %s;\n",
              (status->local_stack_p ? "*(stack + (stack_size - (n) - 1))" : "TOPN(n)"));
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_topn(n) - 1);
        b->stack_size += attr_sp_inc_topn(n);
    }
    fprintf(f, "}\n");
    break;
  case BIN(setn):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(rb_num_t n) = (rb_num_t)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) n;\n");

        fprintf(f, "    n = (rb_num_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    val = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        %s = val;\n",
              (status->local_stack_p ? "*(stack + (stack_size - (n) - 1))" : "TOPN(n)"));
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_setn(n) - 1);
        b->stack_size += attr_sp_inc_setn(n);
    }
    fprintf(f, "}\n");
    break;
  case BIN(adjuststack):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(rb_num_t n) = (rb_num_t)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) n;\n");

        fprintf(f, "    n = (rb_num_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        /* none */\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_adjuststack(n);
    }
    fprintf(f, "}\n");
    break;
  case BIN(defined):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(rb_num_t op_type) = (rb_num_t)operands[0];
        MAYBE_UNUSED(VALUE obj) = (VALUE)operands[1];
        MAYBE_UNUSED(VALUE needstr) = (VALUE)operands[2];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) needstr, obj, v, val;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) op_type;\n");

        fprintf(f, "    op_type = (rb_num_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    obj = (VALUE)0x%"PRIxVALUE";", operands[1]);
        if (SYMBOL_P((VALUE)operands[1])) comment_id(f, SYM2ID((VALUE)operands[1]));
        fprintf(f, "\n");
        fprintf(f, "    needstr = (VALUE)0x%"PRIxVALUE";", operands[2]);
        if (SYMBOL_P((VALUE)operands[2])) comment_id(f, SYM2ID((VALUE)operands[2]));
        fprintf(f, "\n");
        fprintf(f, "    v = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_defined(ec, GET_CFP(), op_type, obj, needstr, v);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_defined(op_type, obj, needstr) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_defined(op_type, obj, needstr) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_defined(op_type, obj, needstr);
    }
    fprintf(f, "}\n");
    break;
  case BIN(checkmatch):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(rb_num_t flag) = (rb_num_t)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) pattern, result, target;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) flag;\n");

        fprintf(f, "    flag = (rb_num_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    target = stack[%d];\n", b->stack_size - 2);
        fprintf(f, "    pattern = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        result = vm_check_match(ec, target, pattern, flag);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = result;\n", b->stack_size + (int)attr_sp_inc_checkmatch(flag) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_checkmatch(flag) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_checkmatch(flag);
    }
    fprintf(f, "}\n");
    break;
  case BIN(checkkeyword):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(lindex_t kw_bits_index) = (lindex_t)operands[0];
        MAYBE_UNUSED(lindex_t keyword_index) = (lindex_t)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) ret;\n");
        fprintf(f, "    MAYBE_UNUSED(lindex_t) keyword_index, kw_bits_index;\n");

        fprintf(f, "    kw_bits_index = (lindex_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    keyword_index = (lindex_t)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        ret = vm_check_keyword(kw_bits_index, keyword_index, GET_EP());\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = ret;\n", b->stack_size + (int)attr_sp_inc_checkkeyword(kw_bits_index, keyword_index) - 1);
        b->stack_size += attr_sp_inc_checkkeyword(kw_bits_index, keyword_index);
    }
    fprintf(f, "}\n");
    break;
  case BIN(checktype):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(rb_num_t type) = (rb_num_t)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) ret, val;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) type;\n");

        fprintf(f, "    type = (rb_num_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    val = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        ret = (TYPE(val) == (int)type) ? Qtrue : Qfalse;\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = ret;\n", b->stack_size + (int)attr_sp_inc_checktype(type) - 1);
        b->stack_size += attr_sp_inc_checktype(type);
    }
    fprintf(f, "}\n");
    break;
  case BIN(send):
{
    MAYBE_UNUSED(int pc_moved_p) = FALSE;
    MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
    MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
    MAYBE_UNUSED(ISEQ blockiseq) = (ISEQ)operands[2];
    CALL_CACHE cc_copy = status->cc_entries + (cc - body->cc_entries);
    if (has_valid_method_type(cc_copy)) {
        const rb_iseq_t *iseq;
        unsigned int argc = ci->orig_argc; /* unlike `ci->orig_argc`, `argc` may include blockarg */
        argc += ((ci->flag & VM_CALL_ARGS_BLOCKARG) ? 1 : 0);

        if (!(ci->flag & VM_CALL_TAILCALL) && /* inlining non-tailcall path */
            cc_copy->me->def->type == VM_METHOD_TYPE_ISEQ && inlinable_iseq_p(ci, cc_copy, iseq = def_iseq_ptr(cc_copy->me->def)) /* CC_SET_FASTPATH in vm_callee_setup_arg */) {
            int param_size = iseq->body->param.size; /* TODO: check calling->argc for argument_arity_error */

            fprintf(f, "{\n");
            if (status->local_stack_p) {
                fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
            }

            fprintf(f, "    if (UNLIKELY(GET_GLOBAL_METHOD_STATE() != %"PRI_SERIALT_PREFIX"u ||\n", cc_copy->method_state);
            fprintf(f, "        RCLASS_SERIAL(CLASS_OF(stack[%d])) != %"PRI_SERIALT_PREFIX"u)) {\n", b->stack_size - 1 - argc, cc_copy->class_serial);
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", pos);
            fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
            fprintf(f, "        goto cancel;\n");
            fprintf(f, "    }\n");

        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
            {
                rb_snum_t i, push_size;
                push_size = -attr_sp_inc_send(ci, cc, blockiseq) + 1 - 0;
                fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %ld + 1;\n", push_size); /* POPN(INSN_ATTR(popn)); */
                for (i = 0; i < push_size; i++) {
                    fprintf(f, "    *(reg_cfp->sp + %ld) = stack[%ld];\n", i - push_size, (rb_snum_t)b->stack_size - push_size + i);
                }
            }
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1 - 0); /* POPN(INSN_ATTR(popn)); */
        }

            fprintf(f, "    {\n");
            fprintf(f, "        struct rb_calling_info calling;\n");
            fprintf(f, "        calling.block_handler = vm_caller_setup_arg_block(ec, reg_cfp, (CALL_INFO)0x%"PRIxVALUE", (rb_iseq_t *)0x%"PRIxVALUE", FALSE);\n", operands[0], operands[2]);
            fprintf(f, "        calling.argc = %d;\n", ci->orig_argc);
            fprintf(f, "        calling.recv = stack[%d];\n", b->stack_size - 1 - argc);

            fprintf(f, "        {\n");
            fprintf(f, "            VALUE v;\n");
            fprintf(f, "            vm_call_iseq_setup_normal(ec, reg_cfp, &calling, (const rb_callable_method_entry_t *)0x%"PRIxVALUE", 0, %d, %d);\n",
                    (VALUE)cc_copy->me, param_size, iseq->body->local_table_size); /* rb_simple_iseq_p checks rb_simple_iseq_p, which ensures has_opt == FALSE */
            if (iseq->body->catch_except_p) {
                fprintf(f, "            VM_ENV_FLAGS_SET(ec->cfp->ep, VM_FRAME_FLAG_FINISH);\n");
                fprintf(f, "            v = vm_exec(ec, TRUE);\n");
            }
            else {
                fprintf(f, "            if ((v = mjit_exec(ec)) == Qundef) {\n");
                fprintf(f, "                VM_ENV_FLAGS_SET(ec->cfp->ep, VM_FRAME_FLAG_FINISH);\n"); /* This is vm_call0_body's code after vm_call_iseq_setup */
                fprintf(f, "                v = vm_exec(ec, FALSE);\n");
                fprintf(f, "            }\n");
            }
            fprintf(f, "            stack[%d] = v;\n", b->stack_size - argc - 1);
            fprintf(f, "        }\n");

            fprintf(f, "    }\n");

            fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
            fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_send(ci, cc, blockiseq) + 1);
            if (!pc_moved_p) {
                fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
            }
            fprintf(f, "        goto cancel;\n");
            fprintf(f, "    }\n");

            b->stack_size += attr_sp_inc_send(ci, cc, blockiseq);

            fprintf(f, "}\n");
            break;
        }
    }
}
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
        MAYBE_UNUSED(ISEQ blockiseq) = (ISEQ)operands[2];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(ISEQ) blockiseq;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    blockiseq = (ISEQ)0x%"PRIxVALUE";", operands[2]);
        fprintf(f, "\n");
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
            {
                rb_snum_t i, push_size;
                push_size = -attr_sp_inc_send(ci, cc, blockiseq) + 1 - 0;
                fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %ld + 1;\n", push_size); /* POPN(INSN_ATTR(popn)); */
                for (i = 0; i < push_size; i++) {
                    fprintf(f, "    *(reg_cfp->sp + %ld) = stack[%ld];\n", i - push_size, (rb_snum_t)b->stack_size - push_size + i);
                }
            }
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1 - 0); /* POPN(INSN_ATTR(popn)); */
        }
        fprintf(f, "    {\n");
        fprintf(f, "        struct rb_calling_info calling;\n");
        fprintf(f, "\n");
        fprintf(f, "        calling.block_handler = vm_caller_setup_arg_block(ec, reg_cfp, ci, blockiseq, FALSE);\n");
        fprintf(f, "        calling.recv = TOPN(calling.argc = ci->orig_argc);\n");
        fprintf(f, "        vm_search_method(ci, cc, calling.recv);\n");
        fprintf(f, "        CALL_METHOD(&calling, ci, cc);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_send(ci, cc, blockiseq) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_send(ci, cc, blockiseq) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_send(ci, cc, blockiseq);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_send_without_block):
{
    MAYBE_UNUSED(int pc_moved_p) = FALSE;
    MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
    MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
    CALL_CACHE cc_copy = status->cc_entries + (cc - body->cc_entries);
    if (has_valid_method_type(cc_copy)) {
        const rb_iseq_t *iseq;
        unsigned int argc = ci->orig_argc; /* unlike `ci->orig_argc`, `argc` may include blockarg */

        if (!(ci->flag & VM_CALL_TAILCALL) && /* inlining non-tailcall path */
            cc_copy->me->def->type == VM_METHOD_TYPE_ISEQ && inlinable_iseq_p(ci, cc_copy, iseq = def_iseq_ptr(cc_copy->me->def)) /* CC_SET_FASTPATH in vm_callee_setup_arg */) {
            int param_size = iseq->body->param.size; /* TODO: check calling->argc for argument_arity_error */

            fprintf(f, "{\n");
            if (status->local_stack_p) {
                fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
            }

            fprintf(f, "    if (UNLIKELY(GET_GLOBAL_METHOD_STATE() != %"PRI_SERIALT_PREFIX"u ||\n", cc_copy->method_state);
            fprintf(f, "        RCLASS_SERIAL(CLASS_OF(stack[%d])) != %"PRI_SERIALT_PREFIX"u)) {\n", b->stack_size - 1 - argc, cc_copy->class_serial);
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", pos);
            fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
            fprintf(f, "        goto cancel;\n");
            fprintf(f, "    }\n");

        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
            {
                rb_snum_t i, push_size;
                push_size = -attr_sp_inc_opt_send_without_block(ci, cc) + 1 - 0;
                fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %ld + 1;\n", push_size); /* POPN(INSN_ATTR(popn)); */
                for (i = 0; i < push_size; i++) {
                    fprintf(f, "    *(reg_cfp->sp + %ld) = stack[%ld];\n", i - push_size, (rb_snum_t)b->stack_size - push_size + i);
                }
            }
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1 - 0); /* POPN(INSN_ATTR(popn)); */
        }

            fprintf(f, "    {\n");
            fprintf(f, "        struct rb_calling_info calling;\n");
            fprintf(f, "        calling.block_handler = VM_BLOCK_HANDLER_NONE;\n");
            fprintf(f, "        calling.argc = %d;\n", ci->orig_argc);
            fprintf(f, "        calling.recv = stack[%d];\n", b->stack_size - 1 - argc);

            fprintf(f, "        {\n");
            fprintf(f, "            VALUE v;\n");
            fprintf(f, "            vm_call_iseq_setup_normal(ec, reg_cfp, &calling, (const rb_callable_method_entry_t *)0x%"PRIxVALUE", 0, %d, %d);\n",
                    (VALUE)cc_copy->me, param_size, iseq->body->local_table_size); /* rb_simple_iseq_p checks rb_simple_iseq_p, which ensures has_opt == FALSE */
            if (iseq->body->catch_except_p) {
                fprintf(f, "            VM_ENV_FLAGS_SET(ec->cfp->ep, VM_FRAME_FLAG_FINISH);\n");
                fprintf(f, "            v = vm_exec(ec, TRUE);\n");
            }
            else {
                fprintf(f, "            if ((v = mjit_exec(ec)) == Qundef) {\n");
                fprintf(f, "                VM_ENV_FLAGS_SET(ec->cfp->ep, VM_FRAME_FLAG_FINISH);\n"); /* This is vm_call0_body's code after vm_call_iseq_setup */
                fprintf(f, "                v = vm_exec(ec, FALSE);\n");
                fprintf(f, "            }\n");
            }
            fprintf(f, "            stack[%d] = v;\n", b->stack_size - argc - 1);
            fprintf(f, "        }\n");

            fprintf(f, "    }\n");

            fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
            fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_opt_send_without_block(ci, cc) + 1);
            if (!pc_moved_p) {
                fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
            }
            fprintf(f, "        goto cancel;\n");
            fprintf(f, "    }\n");

            b->stack_size += attr_sp_inc_opt_send_without_block(ci, cc);

            fprintf(f, "}\n");
            break;
        }
    }
}
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
            {
                rb_snum_t i, push_size;
                push_size = -attr_sp_inc_opt_send_without_block(ci, cc) + 1 - 0;
                fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %ld + 1;\n", push_size); /* POPN(INSN_ATTR(popn)); */
                for (i = 0; i < push_size; i++) {
                    fprintf(f, "    *(reg_cfp->sp + %ld) = stack[%ld];\n", i - push_size, (rb_snum_t)b->stack_size - push_size + i);
                }
            }
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1 - 0); /* POPN(INSN_ATTR(popn)); */
        }
        fprintf(f, "    {\n");
        fprintf(f, "        struct rb_calling_info calling;\n");
        fprintf(f, "        calling.block_handler = VM_BLOCK_HANDLER_NONE;\n");
        fprintf(f, "        vm_search_method(ci, cc, calling.recv = TOPN(calling.argc = ci->orig_argc));\n");
        fprintf(f, "        CALL_METHOD(&calling, ci, cc);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_send_without_block(ci, cc) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_opt_send_without_block(ci, cc) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_opt_send_without_block(ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_str_freeze):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(VALUE str) = (VALUE)operands[0];
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[1];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[2];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) str, val;\n");

        fprintf(f, "    str = (VALUE)0x%"PRIxVALUE";", operands[0]);
        if (SYMBOL_P((VALUE)operands[0])) comment_id(f, SYM2ID((VALUE)operands[0]));
        fprintf(f, "\n");
        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[1]);
        comment_id(f, ((CALL_INFO)operands[1])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[2]);
        fprintf(f, "\n");
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_str_freeze(str, BOP_FREEZE, idFreeze);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        fprintf(f, "            PUSH(rb_str_resurrect(str));\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_str_freeze(str, ci, cc) - 1);
        b->stack_size += attr_sp_inc_opt_str_freeze(str, ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_str_uminus):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(VALUE str) = (VALUE)operands[0];
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[1];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[2];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) str, val;\n");

        fprintf(f, "    str = (VALUE)0x%"PRIxVALUE";", operands[0]);
        if (SYMBOL_P((VALUE)operands[0])) comment_id(f, SYM2ID((VALUE)operands[0]));
        fprintf(f, "\n");
        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[1]);
        comment_id(f, ((CALL_INFO)operands[1])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[2]);
        fprintf(f, "\n");
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_str_freeze(str, BOP_UMINUS, idUMinus);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        fprintf(f, "            PUSH(rb_str_resurrect(str));\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_str_uminus(str, ci, cc) - 1);
        b->stack_size += attr_sp_inc_opt_str_uminus(str, ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_newarray_max):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(rb_num_t num) = (rb_num_t)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) num;\n");

        fprintf(f, "    num = (rb_num_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_newarray_max(num, %s);\n",
                (status->local_stack_p ? "stack + (stack_size - (num))" : "STACK_ADDR_FROM_TOP(num)"));
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_newarray_max(num) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_opt_newarray_max(num) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_opt_newarray_max(num);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_newarray_min):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(rb_num_t num) = (rb_num_t)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) num;\n");

        fprintf(f, "    num = (rb_num_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_newarray_min(num, %s);\n",
                (status->local_stack_p ? "stack + (stack_size - (num))" : "STACK_ADDR_FROM_TOP(num)"));
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_newarray_min(num) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_opt_newarray_min(num) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_opt_newarray_min(num);
    }
    fprintf(f, "}\n");
    break;
  case BIN(invokesuper):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
        MAYBE_UNUSED(ISEQ blockiseq) = (ISEQ)operands[2];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(ISEQ) blockiseq;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    blockiseq = (ISEQ)0x%"PRIxVALUE";", operands[2]);
        fprintf(f, "\n");
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
            {
                rb_snum_t i, push_size;
                push_size = -attr_sp_inc_invokesuper(ci, cc, blockiseq) + 1 - 0;
                fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %ld + 1;\n", push_size); /* POPN(INSN_ATTR(popn)); */
                for (i = 0; i < push_size; i++) {
                    fprintf(f, "    *(reg_cfp->sp + %ld) = stack[%ld];\n", i - push_size, (rb_snum_t)b->stack_size - push_size + i);
                }
            }
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1 - 0); /* POPN(INSN_ATTR(popn)); */
        }
        fprintf(f, "    {\n");
        fprintf(f, "        struct rb_calling_info calling;\n");
        fprintf(f, "\n");
        fprintf(f, "        calling.block_handler = vm_caller_setup_arg_block(ec, reg_cfp, ci, blockiseq, TRUE);\n");
        fprintf(f, "        calling.recv = TOPN(calling.argc = ci->orig_argc);\n");
        fprintf(f, "        vm_search_super_method(ec, GET_CFP(), &calling, ci, cc);\n");
        fprintf(f, "        CALL_METHOD(&calling, ci, cc);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_invokesuper(ci, cc, blockiseq) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_invokesuper(ci, cc, blockiseq) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_invokesuper(ci, cc, blockiseq);
    }
    fprintf(f, "}\n");
    break;
  case BIN(invokeblock):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
            {
                rb_snum_t i, push_size;
                push_size = -attr_sp_inc_invokeblock(ci) + 1 - 0;
                fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %ld + 1;\n", push_size); /* POPN(INSN_ATTR(popn)); */
                for (i = 0; i < push_size; i++) {
                    fprintf(f, "    *(reg_cfp->sp + %ld) = stack[%ld];\n", i - push_size, (rb_snum_t)b->stack_size - push_size + i);
                }
            }
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1 - 0); /* POPN(INSN_ATTR(popn)); */
        }
        fprintf(f, "    {\n");
        fprintf(f, "        struct rb_calling_info calling;\n");
        fprintf(f, "        VALUE block_handler;\n");
        fprintf(f, "\n");
        fprintf(f, "        calling.argc = ci->orig_argc;\n");
        fprintf(f, "        calling.block_handler = VM_BLOCK_HANDLER_NONE;\n");
        fprintf(f, "        calling.recv = Qundef; /* should not be used */\n");
        fprintf(f, "\n");
        fprintf(f, "        block_handler = VM_CF_BLOCK_HANDLER(GET_CFP());\n");
        fprintf(f, "        if (block_handler == VM_BLOCK_HANDLER_NONE) {\n");
        fprintf(f, "            rb_vm_localjump_error(\"no block given (yield)\", Qnil, 0);\n");
        fprintf(f, "        }\n");
        fprintf(f, "\n");
        fprintf(f, "        val = vm_invoke_block(ec, GET_CFP(), &calling, ci, block_handler);\n");
        fprintf(f, "        if (val == Qundef) {\n");
        fprintf(f, "            EXEC_EC_CFP(val);\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_invokeblock(ci) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_invokeblock(ci) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_invokeblock(ci);
    }
    fprintf(f, "}\n");
    break;
  case BIN(leave):
    if (b->stack_size != 1) {
        if (mjit_opts.warnings || mjit_opts.verbose)
            fprintf(stderr, "MJIT warning: Unexpected JIT stack_size on leave: %d\n", b->stack_size);
        status->success = FALSE;
    }
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        fprintf(f, "    val = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
            {
                rb_snum_t i, push_size;
                push_size = -attr_sp_inc_leave() + 1 - 1;
                fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %ld + 1;\n", push_size); /* POPN(INSN_ATTR(popn)); */
                for (i = 0; i < push_size; i++) {
                    fprintf(f, "    *(reg_cfp->sp + %ld) = stack[%ld];\n", i - push_size, (rb_snum_t)b->stack_size - push_size + i);
                }
            }
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1 - 1); /* POPN(INSN_ATTR(popn)); */
        }
        fprintf(f, "    {\n");
        fprintf(f, "        if (OPT_CHECKED_RUN) {\n");
        fprintf(f, "            const VALUE *const bp = vm_base_ptr(reg_cfp);\n");
        fprintf(f, "            if (reg_cfp->sp != bp) {\n");
        fprintf(f, "                vm_stack_consistency_error(ec, reg_cfp, bp);\n");
        fprintf(f, "            }\n");
        fprintf(f, "        }\n");
        fprintf(f, "\n");
        fprintf(f, "        RUBY_VM_CHECK_INTS(ec);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (vm_pop_frame(ec, GET_CFP(), GET_EP())) {\n");
        fprintf(f, "#if OPT_CALL_THREADED_CODE\n");
        fprintf(f, "            rb_ec_thread_ptr(ec)->retval = val;\n");
        fprintf(f, "            return 0;\n");
        fprintf(f, "#else\n");
        fprintf(f, "            return val;\n");
        fprintf(f, "#endif\n");
        fprintf(f, "        }\n");
        fprintf(f, "        else {\n");
        fprintf(f, "#if OPT_CALL_THREADED_CODE\n");
        fprintf(f, "            rb_ec_thread_ptr(ec)->retval = val;\n");
        fprintf(f, "            return 0;\n");
        fprintf(f, "#else\n");
        fprintf(f, "            return val;\n");
        fprintf(f, "#endif\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_leave() - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_leave() + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_leave();
    }
    fprintf(f, "}\n");
    b->finish_p = TRUE;
    break;
  case BIN(throw):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(rb_num_t throw_state) = (rb_num_t)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) throwobj, val;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) throw_state;\n");

        fprintf(f, "    throw_state = (rb_num_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    throwobj = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        RUBY_VM_CHECK_INTS(ec);\n");
        fprintf(f, "        val = vm_throw(ec, GET_CFP(), throw_state, throwobj);\n");
        fprintf(f, "        THROW_EXCEPTION(val);\n");
        fprintf(f, "        /* unreachable */\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_throw(throw_state) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_throw(throw_state) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_throw(throw_state);
    }
    fprintf(f, "}\n");
    b->finish_p = TRUE;
    break;
  case BIN(jump):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(OFFSET dst) = (OFFSET)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(OFFSET) dst;\n");

        fprintf(f, "    dst = (OFFSET)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        RUBY_VM_CHECK_INTS(ec);\n");
        next_pos = pos + insn_len(insn) + (unsigned int)dst;
        fprintf(f, "            goto label_%d;\n", next_pos);
        fprintf(f, "    }\n");
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_jump(dst) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_jump(dst);
    }
    fprintf(f, "}\n");
    break;
  case BIN(branchif):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(OFFSET dst) = (OFFSET)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(OFFSET) dst;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        fprintf(f, "    dst = (OFFSET)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    val = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        if (RTEST(val)) {\n");
        fprintf(f, "            RUBY_VM_CHECK_INTS(ec);\n");
        next_pos = pos + insn_len(insn) + (unsigned int)dst;
        fprintf(f, "            goto label_%d;\n", next_pos);
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_branchif(dst) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_branchif(dst);
    }
    fprintf(f, "}\n");
    compile_insns(f, body, b->stack_size, pos + insn_len(insn), status);
    break;
  case BIN(branchunless):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(OFFSET dst) = (OFFSET)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(OFFSET) dst;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        fprintf(f, "    dst = (OFFSET)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    val = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        if (!RTEST(val)) {\n");
        fprintf(f, "            RUBY_VM_CHECK_INTS(ec);\n");
        next_pos = pos + insn_len(insn) + (unsigned int)dst;
        fprintf(f, "            goto label_%d;\n", next_pos);
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_branchunless(dst) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_branchunless(dst);
    }
    fprintf(f, "}\n");
    compile_insns(f, body, b->stack_size, pos + insn_len(insn), status);
    break;
  case BIN(branchnil):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(OFFSET dst) = (OFFSET)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(OFFSET) dst;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        fprintf(f, "    dst = (OFFSET)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    val = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        if (NIL_P(val)) {\n");
        fprintf(f, "            RUBY_VM_CHECK_INTS(ec);\n");
        next_pos = pos + insn_len(insn) + (unsigned int)dst;
        fprintf(f, "            goto label_%d;\n", next_pos);
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_branchnil(dst) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_branchnil(dst);
    }
    fprintf(f, "}\n");
    compile_insns(f, body, b->stack_size, pos + insn_len(insn), status);
    break;
  case BIN(opt_getinlinecache):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(OFFSET dst) = (OFFSET)operands[0];
        MAYBE_UNUSED(IC ic) = (IC)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(IC) ic;\n");
        fprintf(f, "    MAYBE_UNUSED(OFFSET) dst;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        fprintf(f, "    dst = (OFFSET)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    ic = (IC)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        if (vm_ic_hit_p(ic, GET_EP())) {\n");
        fprintf(f, "            val = ic->ic_value.value;\n");
        fprintf(f, "            stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_getinlinecache(dst, ic) - 1);
        next_pos = pos + insn_len(insn) + (unsigned int)dst;
        fprintf(f, "            goto label_%d;\n", next_pos);
        fprintf(f, "        }\n");
        fprintf(f, "        else {\n");
        fprintf(f, "            val = Qnil;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_getinlinecache(dst, ic) - 1);
        b->stack_size += attr_sp_inc_opt_getinlinecache(dst, ic);
    }
    fprintf(f, "}\n");
    compile_insns(f, body, b->stack_size, pos + insn_len(insn), status);
    break;
  case BIN(opt_setinlinecache):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(IC ic) = (IC)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(IC) ic;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        fprintf(f, "    ic = (IC)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    val = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        vm_ic_update(ic, val, GET_EP());\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_setinlinecache(ic) - 1);
        b->stack_size += attr_sp_inc_opt_setinlinecache(ic);
    }
    fprintf(f, "}\n");
    break;
  case BIN(once):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(ISEQ iseq) = (ISEQ)operands[0];
        MAYBE_UNUSED(ISE ise) = (ISE)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(ISE) ise;\n");
        fprintf(f, "    MAYBE_UNUSED(ISEQ) iseq;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        fprintf(f, "    iseq = (ISEQ)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    ise = (ISE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
            {
                rb_snum_t i, push_size;
                push_size = -attr_sp_inc_once(iseq, ise) + 1 - 0;
                fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %ld + 1;\n", push_size); /* POPN(INSN_ATTR(popn)); */
                for (i = 0; i < push_size; i++) {
                    fprintf(f, "    *(reg_cfp->sp + %ld) = stack[%ld];\n", i - push_size, (rb_snum_t)b->stack_size - push_size + i);
                }
            }
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1 - 0); /* POPN(INSN_ATTR(popn)); */
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_once_dispatch(ec, iseq, ise);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_once(iseq, ise) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_once(iseq, ise) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_once(iseq, ise);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_case_dispatch):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CDHASH hash) = (CDHASH)operands[0];
        MAYBE_UNUSED(OFFSET else_offset) = (OFFSET)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CDHASH) hash;\n");
        fprintf(f, "    MAYBE_UNUSED(OFFSET) else_offset;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) key;\n");

        fprintf(f, "    hash = (CDHASH)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    else_offset = (OFFSET)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    key = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        OFFSET dst = vm_case_dispatch(hash, else_offset, key);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (dst) {\n");
        {
            struct case_dispatch_var arg;
            arg.f = f;
            arg.base_pos = pos + insn_len(insn);
            arg.last_value = Qundef;

            fprintf(f, "    switch (dst) {\n");
            st_foreach(RHASH_TBL_RAW(hash), compile_case_dispatch_each, (VALUE)&arg);
            fprintf(f, "      case %lu:\n", else_offset);
            fprintf(f, "        goto label_%lu;\n", arg.base_pos + else_offset);
            fprintf(f, "    }\n");
        }
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_opt_case_dispatch(hash, else_offset);
    }
    fprintf(f, "}\n");
    compile_insns(f, body, b->stack_size, pos + insn_len(insn), status);
    break;
  case BIN(opt_plus):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) obj, recv, val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    recv = stack[%d];\n", b->stack_size - 2);
        fprintf(f, "    obj = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_plus(recv, obj);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_plus(ci, cc) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_opt_plus(ci, cc) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_opt_plus(ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_minus):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) obj, recv, val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    recv = stack[%d];\n", b->stack_size - 2);
        fprintf(f, "    obj = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_minus(recv, obj);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_minus(ci, cc) - 1);
        b->stack_size += attr_sp_inc_opt_minus(ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_mult):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) obj, recv, val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    recv = stack[%d];\n", b->stack_size - 2);
        fprintf(f, "    obj = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_mult(recv, obj);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_mult(ci, cc) - 1);
        b->stack_size += attr_sp_inc_opt_mult(ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_div):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) obj, recv, val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    recv = stack[%d];\n", b->stack_size - 2);
        fprintf(f, "    obj = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_div(recv, obj);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_div(ci, cc) - 1);
        b->stack_size += attr_sp_inc_opt_div(ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_mod):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) obj, recv, val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    recv = stack[%d];\n", b->stack_size - 2);
        fprintf(f, "    obj = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_mod(recv, obj);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_mod(ci, cc) - 1);
        b->stack_size += attr_sp_inc_opt_mod(ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_eq):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) obj, recv, val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    recv = stack[%d];\n", b->stack_size - 2);
        fprintf(f, "    obj = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = opt_eq_func(recv, obj, ci, cc);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_eq(ci, cc) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_opt_eq(ci, cc) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_opt_eq(ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_neq):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci_eq) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc_eq) = (CALL_CACHE)operands[1];
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[2];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[3];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc, cc_eq;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci, ci_eq;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) obj, recv, val;\n");

        fprintf(f, "    ci_eq = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc_eq = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[2]);
        comment_id(f, ((CALL_INFO)operands[2])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[3]);
        fprintf(f, "\n");
        fprintf(f, "    recv = stack[%d];\n", b->stack_size - 2);
        fprintf(f, "    obj = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_neq(ci, cc, ci_eq, cc_eq, recv, obj);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_neq(ci_eq, cc_eq, ci, cc) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_opt_neq(ci_eq, cc_eq, ci, cc) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_opt_neq(ci_eq, cc_eq, ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_lt):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) obj, recv, val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    recv = stack[%d];\n", b->stack_size - 2);
        fprintf(f, "    obj = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_lt(recv, obj);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_lt(ci, cc) - 1);
        b->stack_size += attr_sp_inc_opt_lt(ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_le):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) obj, recv, val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    recv = stack[%d];\n", b->stack_size - 2);
        fprintf(f, "    obj = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_le(recv, obj);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_le(ci, cc) - 1);
        b->stack_size += attr_sp_inc_opt_le(ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_gt):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) obj, recv, val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    recv = stack[%d];\n", b->stack_size - 2);
        fprintf(f, "    obj = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_gt(recv, obj);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_gt(ci, cc) - 1);
        b->stack_size += attr_sp_inc_opt_gt(ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_ge):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) obj, recv, val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    recv = stack[%d];\n", b->stack_size - 2);
        fprintf(f, "    obj = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_ge(recv, obj);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_ge(ci, cc) - 1);
        b->stack_size += attr_sp_inc_opt_ge(ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_ltlt):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) obj, recv, val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    recv = stack[%d];\n", b->stack_size - 2);
        fprintf(f, "    obj = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_ltlt(recv, obj);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_ltlt(ci, cc) - 1);
        b->stack_size += attr_sp_inc_opt_ltlt(ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_and):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) obj, recv, val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    recv = stack[%d];\n", b->stack_size - 2);
        fprintf(f, "    obj = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_and(recv, obj);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_and(ci, cc) - 1);
        b->stack_size += attr_sp_inc_opt_and(ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_or):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) obj, recv, val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    recv = stack[%d];\n", b->stack_size - 2);
        fprintf(f, "    obj = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_or(recv, obj);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_or(ci, cc) - 1);
        b->stack_size += attr_sp_inc_opt_or(ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_aref):
{
    MAYBE_UNUSED(int pc_moved_p) = FALSE;
    MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
    MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
    CALL_CACHE cc_copy = status->cc_entries + (cc - body->cc_entries);
    if (has_valid_method_type(cc_copy)) {
        const rb_iseq_t *iseq;
        unsigned int argc = ci->orig_argc; /* unlike `ci->orig_argc`, `argc` may include blockarg */

        if (!(ci->flag & VM_CALL_TAILCALL) && /* inlining non-tailcall path */
            cc_copy->me->def->type == VM_METHOD_TYPE_ISEQ && inlinable_iseq_p(ci, cc_copy, iseq = def_iseq_ptr(cc_copy->me->def)) /* CC_SET_FASTPATH in vm_callee_setup_arg */) {
            int param_size = iseq->body->param.size; /* TODO: check calling->argc for argument_arity_error */

            fprintf(f, "{\n");
            if (status->local_stack_p) {
                fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
            }

            fprintf(f, "    if (UNLIKELY(GET_GLOBAL_METHOD_STATE() != %"PRI_SERIALT_PREFIX"u ||\n", cc_copy->method_state);
            fprintf(f, "        RCLASS_SERIAL(CLASS_OF(stack[%d])) != %"PRI_SERIALT_PREFIX"u)) {\n", b->stack_size - 1 - argc, cc_copy->class_serial);
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", pos);
            fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
            fprintf(f, "        goto cancel;\n");
            fprintf(f, "    }\n");

        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
            {
                rb_snum_t i, push_size;
                push_size = -attr_sp_inc_opt_send_without_block(ci, cc) + 1 - 0;
                fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %ld + 1;\n", push_size); /* POPN(INSN_ATTR(popn)); */
                for (i = 0; i < push_size; i++) {
                    fprintf(f, "    *(reg_cfp->sp + %ld) = stack[%ld];\n", i - push_size, (rb_snum_t)b->stack_size - push_size + i);
                }
            }
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1 - 0); /* POPN(INSN_ATTR(popn)); */
        }

            fprintf(f, "    {\n");
            fprintf(f, "        struct rb_calling_info calling;\n");
            fprintf(f, "        calling.block_handler = VM_BLOCK_HANDLER_NONE;\n");
            fprintf(f, "        calling.argc = %d;\n", ci->orig_argc);
            fprintf(f, "        calling.recv = stack[%d];\n", b->stack_size - 1 - argc);

            fprintf(f, "        {\n");
            fprintf(f, "            VALUE v;\n");
            fprintf(f, "            vm_call_iseq_setup_normal(ec, reg_cfp, &calling, (const rb_callable_method_entry_t *)0x%"PRIxVALUE", 0, %d, %d);\n",
                    (VALUE)cc_copy->me, param_size, iseq->body->local_table_size); /* rb_simple_iseq_p checks rb_simple_iseq_p, which ensures has_opt == FALSE */
            if (iseq->body->catch_except_p) {
                fprintf(f, "            VM_ENV_FLAGS_SET(ec->cfp->ep, VM_FRAME_FLAG_FINISH);\n");
                fprintf(f, "            v = vm_exec(ec, TRUE);\n");
            }
            else {
                fprintf(f, "            if ((v = mjit_exec(ec)) == Qundef) {\n");
                fprintf(f, "                VM_ENV_FLAGS_SET(ec->cfp->ep, VM_FRAME_FLAG_FINISH);\n"); /* This is vm_call0_body's code after vm_call_iseq_setup */
                fprintf(f, "                v = vm_exec(ec, FALSE);\n");
                fprintf(f, "            }\n");
            }
            fprintf(f, "            stack[%d] = v;\n", b->stack_size - argc - 1);
            fprintf(f, "        }\n");

            fprintf(f, "    }\n");

            fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
            fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_opt_send_without_block(ci, cc) + 1);
            if (!pc_moved_p) {
                fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
            }
            fprintf(f, "        goto cancel;\n");
            fprintf(f, "    }\n");

            b->stack_size += attr_sp_inc_opt_send_without_block(ci, cc);

            fprintf(f, "}\n");
            break;
        }
    }
}
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) obj, recv, val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    recv = stack[%d];\n", b->stack_size - 2);
        fprintf(f, "    obj = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_aref(recv, obj);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_aref(ci, cc) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_opt_aref(ci, cc) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_opt_aref(ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_aset):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) obj, recv, set, val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    recv = stack[%d];\n", b->stack_size - 3);
        fprintf(f, "    obj = stack[%d];\n", b->stack_size - 2);
        fprintf(f, "    set = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_aset(recv, obj, set);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_aset(ci, cc) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_opt_aset(ci, cc) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_opt_aset(ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_aset_with):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(VALUE key) = (VALUE)operands[0];
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[1];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[2];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) key, recv, val;\n");

        fprintf(f, "    key = (VALUE)0x%"PRIxVALUE";", operands[0]);
        if (SYMBOL_P((VALUE)operands[0])) comment_id(f, SYM2ID((VALUE)operands[0]));
        fprintf(f, "\n");
        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[1]);
        comment_id(f, ((CALL_INFO)operands[1])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[2]);
        fprintf(f, "\n");
        fprintf(f, "    recv = stack[%d];\n", b->stack_size - 2);
        fprintf(f, "    val = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        VALUE tmp = vm_opt_aset_with(recv, key, val);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (tmp != Qundef) {\n");
        fprintf(f, "            val = tmp;\n");
        fprintf(f, "        }\n");
        fprintf(f, "        else {\n");
        fprintf(f, "#ifndef MJIT_HEADER\n");
        fprintf(f, "            %s = rb_str_resurrect(key);\n",
              (status->local_stack_p ? "*(stack + (stack_size - (0) - 1))" : "TOPN(0)"));
        fprintf(f, "            PUSH(val);\n");
        fprintf(f, "#endif\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_aset_with(key, ci, cc) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_opt_aset_with(key, ci, cc) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_opt_aset_with(key, ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_aref_with):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(VALUE key) = (VALUE)operands[0];
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[1];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[2];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) key, recv, val;\n");

        fprintf(f, "    key = (VALUE)0x%"PRIxVALUE";", operands[0]);
        if (SYMBOL_P((VALUE)operands[0])) comment_id(f, SYM2ID((VALUE)operands[0]));
        fprintf(f, "\n");
        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[1]);
        comment_id(f, ((CALL_INFO)operands[1])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[2]);
        fprintf(f, "\n");
        fprintf(f, "    recv = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_aref_with(recv, key);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        fprintf(f, "#ifndef MJIT_HEADER\n");
        fprintf(f, "            PUSH(rb_str_resurrect(key));\n");
        fprintf(f, "#endif\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_aref_with(key, ci, cc) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_opt_aref_with(key, ci, cc) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_opt_aref_with(key, ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_length):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) recv, val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    recv = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_length(recv, BOP_LENGTH);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_length(ci, cc) - 1);
        b->stack_size += attr_sp_inc_opt_length(ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_size):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) recv, val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    recv = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_length(recv, BOP_SIZE);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_size(ci, cc) - 1);
        b->stack_size += attr_sp_inc_opt_size(ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_empty_p):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) recv, val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    recv = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_empty_p(recv);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_empty_p(ci, cc) - 1);
        b->stack_size += attr_sp_inc_opt_empty_p(ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_succ):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) recv, val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    recv = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_succ(recv);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_succ(ci, cc) - 1);
        b->stack_size += attr_sp_inc_opt_succ(ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_not):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) recv, val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    recv = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_not(ci, cc, recv);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_not(ci, cc) - 1);
        b->stack_size += attr_sp_inc_opt_not(ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_regexpmatch1):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(VALUE recv) = (VALUE)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) obj, recv, val;\n");

        fprintf(f, "    recv = (VALUE)0x%"PRIxVALUE";", operands[0]);
        if (SYMBOL_P((VALUE)operands[0])) comment_id(f, SYM2ID((VALUE)operands[0]));
        fprintf(f, "\n");
        fprintf(f, "    obj = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || TRUE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_regexpmatch1(recv, obj);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_regexpmatch1(recv) - 1);
        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_global_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_opt_regexpmatch1(recv) + 1);
        if (!pc_moved_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_opt_regexpmatch1(recv);
    }
    fprintf(f, "}\n");
    break;
  case BIN(opt_regexpmatch2):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        MAYBE_UNUSED(CALL_CACHE cc) = (CALL_CACHE)operands[1];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_CACHE) cc;\n");
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) obj1, obj2, val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");
        fprintf(f, "    cc = (CALL_CACHE)0x%"PRIxVALUE";", operands[1]);
        fprintf(f, "\n");
        fprintf(f, "    obj2 = stack[%d];\n", b->stack_size - 2);
        fprintf(f, "    obj1 = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = vm_opt_regexpmatch2(obj2, obj1);\n");
        fprintf(f, "\n");
        fprintf(f, "        if (val == Qundef) {\n");
        if (status->local_stack_p) {
            fprintf(f, "            reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "            reg_cfp->pc = original_body_iseq + %d;\n", pos);
        fprintf(f, "            goto cancel;\n");
        fprintf(f, "        }\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_opt_regexpmatch2(ci, cc) - 1);
        b->stack_size += attr_sp_inc_opt_regexpmatch2(ci, cc);
    }
    fprintf(f, "}\n");
    break;
  case BIN(bitblt):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) ret;\n");

        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        ret = rb_str_new2(\"a bit of bacon, lettuce and tomato\");\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = ret;\n", b->stack_size + (int)attr_sp_inc_bitblt() - 1);
        b->stack_size += attr_sp_inc_bitblt();
    }
    fprintf(f, "}\n");
    break;
  case BIN(answer):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) ret;\n");

        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        ret = INT2FIX(42);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = ret;\n", b->stack_size + (int)attr_sp_inc_answer() - 1);
        b->stack_size += attr_sp_inc_answer();
    }
    fprintf(f, "}\n");
    break;
  case BIN(getlocal_WC_0):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(lindex_t idx) = (lindex_t)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");
        fprintf(f, "    MAYBE_UNUSED(lindex_t) idx;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) level;\n");

        fprintf(f, "    level = 0;\n");
        fprintf(f, "    idx = (lindex_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = *(vm_get_ep(GET_EP(), level) - idx);\n");
        fprintf(f, "        RB_DEBUG_COUNTER_INC(lvar_get);\n");
        fprintf(f, "        (void)RB_DEBUG_COUNTER_INC_IF(lvar_get_dynamic, level > 0);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_getlocal_WC_0(idx) - 1);
        b->stack_size += attr_sp_inc_getlocal_WC_0(idx);
    }
    fprintf(f, "}\n");
    break;
  case BIN(getlocal_WC_1):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(lindex_t idx) = (lindex_t)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");
        fprintf(f, "    MAYBE_UNUSED(lindex_t) idx;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) level;\n");

        fprintf(f, "    level = 1;\n");
        fprintf(f, "    idx = (lindex_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        val = *(vm_get_ep(GET_EP(), level) - idx);\n");
        fprintf(f, "        RB_DEBUG_COUNTER_INC(lvar_get);\n");
        fprintf(f, "        (void)RB_DEBUG_COUNTER_INC_IF(lvar_get_dynamic, level > 0);\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_getlocal_WC_1(idx) - 1);
        b->stack_size += attr_sp_inc_getlocal_WC_1(idx);
    }
    fprintf(f, "}\n");
    break;
  case BIN(setlocal_WC_0):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(lindex_t idx) = (lindex_t)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");
        fprintf(f, "    MAYBE_UNUSED(lindex_t) idx;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) level;\n");

        fprintf(f, "    level = 0;\n");
        fprintf(f, "    idx = (lindex_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    val = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        vm_env_write(vm_get_ep(GET_EP(), level), -(int)idx, val);\n");
        fprintf(f, "        RB_DEBUG_COUNTER_INC(lvar_set);\n");
        fprintf(f, "        (void)RB_DEBUG_COUNTER_INC_IF(lvar_set_dynamic, level > 0);\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_setlocal_WC_0(idx);
    }
    fprintf(f, "}\n");
    break;
  case BIN(setlocal_WC_1):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        MAYBE_UNUSED(lindex_t idx) = (lindex_t)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");
        fprintf(f, "    MAYBE_UNUSED(lindex_t) idx;\n");
        fprintf(f, "    MAYBE_UNUSED(rb_num_t) level;\n");

        fprintf(f, "    level = 1;\n");
        fprintf(f, "    idx = (lindex_t)0x%"PRIxVALUE";", operands[0]);
        fprintf(f, "\n");
        fprintf(f, "    val = stack[%d];\n", b->stack_size - 1);
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        vm_env_write(vm_get_ep(GET_EP(), level), -(int)idx, val);\n");
        fprintf(f, "        RB_DEBUG_COUNTER_INC(lvar_set);\n");
        fprintf(f, "        (void)RB_DEBUG_COUNTER_INC_IF(lvar_set_dynamic, level > 0);\n");
        fprintf(f, "    }\n");
        b->stack_size += attr_sp_inc_setlocal_WC_1(idx);
    }
    fprintf(f, "}\n");
    break;
  case BIN(putobject_INT2FIX_0_):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        fprintf(f, "    val = INT2FIX(0);\n");
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        /* */\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_putobject_INT2FIX_0_() - 1);
        b->stack_size += attr_sp_inc_putobject_INT2FIX_0_();
    }
    fprintf(f, "}\n");
    break;
  case BIN(putobject_INT2FIX_1_):
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(int pc_moved_p) = FALSE;
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        fprintf(f, "    val = INT2FIX(1);\n");
        if (body->catch_except_p || FALSE) {
            fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
            pc_moved_p = TRUE;
        }
        if (status->local_stack_p) {
        }
        else {
            fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + 1);
        }
        fprintf(f, "    {\n");
        fprintf(f, "        /* */\n");
        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_putobject_INT2FIX_1_() - 1);
        b->stack_size += attr_sp_inc_putobject_INT2FIX_1_();
    }
    fprintf(f, "}\n");
    break;
  default:
    if (mjit_opts.warnings || mjit_opts.verbose)
        fprintf(stderr, "MJIT warning: Skipped to compile unsupported instruction: %s\n", insn_name(insn));
    status->success = FALSE;
    break;
}
